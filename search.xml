<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习笔记（六）朴素贝叶斯</title>
    <url>/2020/08/03/Bayes/</url>
    <content><![CDATA[<h2 id="1-朴素贝叶斯原理"><a href="#1-朴素贝叶斯原理" class="headerlink" title="1 朴素贝叶斯原理"></a>1 朴素贝叶斯原理</h2><p>朴素贝叶斯是一种直接衡量标签和特征之间的概率关系的有监督学习算法，是一种专注分类的算法</p>
<p>贝叶斯理论等式：</p>
<p>$$P(Y|X)=\frac{P(X|Y) * P(Y)}{P(X)}$$</p>
<p>我们可以把特征$X$当成是我们的条件事件，而我们要求解的标签Y当成是我们被满足条件后会被影响的结果，而两者之间的概率关系就是$P(Y|X)$，这个概率在机器学习中，被称为是标签的后验概率。而标签Y被写作$P(Y)$，被称为标签的先验概率</p>
<a id="more"></a>

<p>假设我们只有两个特征$X_1,X_2$，由联合概率公式</p>
<p>$$P(X_1,X_2|Y=1)=\frac{X_1,X_2,Y=1}{P(Y=1)}$$<br>$$=\frac{P(X_1,X_2,Y=1)}{P(X_2,Y=1)} * \frac{P(X_2,Y=1)}{P(Y=1)}$$<br>$$=P(X_1|X_2,Y=1) * P(X_2|Y=1)$$</p>
<p><strong>将(X_2,Y=1)看成一个条件</strong></p>
<p><strong>当X_1,X_2是独立时$$P(X_1|X_2,Y=1)等于P(X_1|Y=1)$$</strong><br>$$=P(X_1|Y=1) * P(X_2|Y=1)$$</p>
<p>推广到n个$X$，则有：</p>
<p>$$P(X|Y=1)=\prod_{i=1}^{n}P(X_i=x_i|Y=1)$$</p>
<p><strong>假设特征之间是有条件独立的，可以解决众多问题，也简化了很多计算过程，这是朴素贝叶斯被称为“朴素”的理由</strong></p>
<p>因此，贝叶斯在特征之间有较多相关性的数据集上表现不佳。</p>
<p>分母的求解可以根据全概率公式<br>$$P(X)=\sum_{i=1}^mP(y_i) * P(X|Y_i)$$</p>
<p>其中m代表标签的种类，对于二分类：<br>$$P(X)=P(Y=1) * P(X|Y=1)+P(Y=0) * P(X|Y=0)$$</p>
<h2 id="2-不同分布下的贝叶斯"><a href="#2-不同分布下的贝叶斯" class="headerlink" title="2 不同分布下的贝叶斯"></a>2 不同分布下的贝叶斯</h2><h3 id="2-1-高斯朴素贝叶斯GaussianNB"><a href="#2-1-高斯朴素贝叶斯GaussianNB" class="headerlink" title="2.1 高斯朴素贝叶斯GaussianNB"></a>2.1 高斯朴素贝叶斯GaussianNB</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sklearn.naive_bayes.GaussianNB (priors&#x3D;None, var_smoothing&#x3D;1e-09)</span><br></pre></td></tr></table></figure>

<p>高斯朴素贝叶斯，通过假设$P(x_i|Y)$是服从高斯分布</p>
<p>$$P(x_i|Y)=f(x_i;\mu,\sigma) * \epsilon$$<br>$$=\frac{1}{\sqrt{2\pi \sigma_y^2}}exp(-\frac{(x_i-\mu_y)^2}{2\sigma_y^2})$$</p>
<h3 id="2-2-多项式朴素贝叶斯MultinomialNB"><a href="#2-2-多项式朴素贝叶斯MultinomialNB" class="headerlink" title="2.2 多项式朴素贝叶斯MultinomialNB"></a>2.2 多项式朴素贝叶斯MultinomialNB</h3><p>假设概率分布是服从一个简单多项式分布，具体可解释为：实验包括n次重复实验，每项实验都有不同的可能结果，在任何给定的实验中，特定结果发生的概率是不变的。</p>
<ol>
<li>多项式分布擅长的是分类型变量，在其原理假设中的概率是离散的，并且不同下的相互独立，互不影响。虽然sklearn中的多项式分布也可以处理连续型变量，但现实中，如果我们真的想要处理连续型变量，使用高斯朴素贝叶斯。</li>
<li>多项式实验中的实验结果都很具体，它所涉及的特征往往是次数，频率，计数，出现与否这样的概念，这些概念都是离散的正整数，因此sklearn中的多项式朴素贝叶斯不接受负值的输入。</li>
</ol>
<h3 id="2-3-伯努利朴素贝叶斯BernoulliNB"><a href="#2-3-伯努利朴素贝叶斯BernoulliNB" class="headerlink" title="2.3 伯努利朴素贝叶斯BernoulliNB"></a>2.3 伯努利朴素贝叶斯BernoulliNB</h3><p>多项式朴素贝叶斯可同时处理二项分布（抛硬币）和多项分布（掷骰子），其中二项分布又叫做伯努利分布，它是一种现实中常见，并且拥有很多优越数学性质的分布。因此，既然有着多项式朴素贝叶斯，我们自然也就又专门用来处理二项分布的朴素贝叶斯：伯努利朴素贝叶斯。</p>
<h3 id="2-4-改进多项式朴素贝叶斯：补集朴素贝叶斯ComplementNB"><a href="#2-4-改进多项式朴素贝叶斯：补集朴素贝叶斯ComplementNB" class="headerlink" title="2.4 改进多项式朴素贝叶斯：补集朴素贝叶斯ComplementNB"></a>2.4 改进多项式朴素贝叶斯：补集朴素贝叶斯ComplementNB</h3><p>补集朴素贝叶斯（complement naive Bayes，CNB）算法是标准多项式朴素贝叶斯算法的改进。CNB的发明小组创造出CNB的初衷是为了解决贝叶斯中的“朴素”假设带来的各种问题，他们希望能够创造出数学方法以逃避朴素贝叶斯中的朴素假设，让算法能够不去关心所有特征之间是否是条件独立的。以此为基础，他们创造出了能够解决样本不平衡问题，并且能够一定程度上忽略朴素假设的补集朴素贝叶斯。在实验中，CNB的参数估计已经被证明比普通多项式朴素贝叶斯更稳定，并且它特别适合于样本不平衡的数据集。有时候，CNB在文本分类任务上的表现有时能够优于多项式朴素贝叶斯，因此现在补集朴素贝叶斯也开始逐渐流行。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（三）：树与二叉树</title>
    <url>/2020/08/14/Data3/</url>
    <content><![CDATA[<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h1><h2 id="1-1-二叉树的定义及其主要特性"><a href="#1-1-二叉树的定义及其主要特性" class="headerlink" title="1.1 二叉树的定义及其主要特性"></a>1.1 二叉树的定义及其主要特性</h2><p>二叉树是有序的，即使树中节点只有一颗子树，也要区分它是左子树还是右子树</p>
<p>二叉树具有的性质：</p>
<ol>
<li>一颗非空二叉树的第$i$层上最多有$2^{i-1}$个结点$（i&gt;=1）$</li>
<li>一颗深度为$k$的二叉树中，最多具有$2^k-1$个结点</li>
<li>对于一颗非空的二叉树，如果叶子节点数为$n_0$，度数为2的结点数为$n_2$，则有$n_0=n_2+1$</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>具有$n$个结点的完全二叉树的深度为$\lfloor log_2n \rfloor+1$</li>
<li>对于一个有$n$个结点的全完二叉树（深度为$\lfloor log_2n \rfloor+1$），按照从根结点起，自上而下，从左到右的约定对所有结点从1到n进行编号，则对任意的编号为i的结点$(1&lt;=i&lt;=n)$有以下性质<ul>
<li>如果$i=1$，则结点$i$是二叉树的根，无双亲</li>
<li>如果$i&gt;1$，则双亲结点编号$\lfloor i/2 \rfloor$</li>
<li>如果$2i&gt;n$，则结点$i$无左孩子（结点$i$为叶子结点），否则其左孩子结点是$2i$</li>
<li>如果$2i+1&gt;n$，则结点$i$无右孩子，否则其右孩子结点$2i+1$</li>
</ul>
</li>
</ol>
<h2 id="1-2-二叉树的顺序存储结构和链式存储结构"><a href="#1-2-二叉树的顺序存储结构和链式存储结构" class="headerlink" title="1.2 二叉树的顺序存储结构和链式存储结构"></a>1.2 二叉树的顺序存储结构和链式存储结构</h2><p>（1）顺序存储结构</p>
<p>用一组连续的存储单元存放二叉树中的结点，一般按照二叉树结点从上至下、从左到右的顺序存储，依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映出结点之间的逻辑关系</p>
<p>对于一般的二叉树，只有添加一些并不存在的空结点，使之成为一颗完全二叉树的形式，然后再用一维数组顺序存储</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/FFBEBB8C44AB4B52B84F5D6BE7F80AC9?method=download&shareKey=59baeb75b97d01169c42ae3332c597ed" alt></p>
<p>（2）链式存储结构</p>
<ol>
<li>二叉链表：包括三个域，数据域和左、右指针域，分别指向该结点的左孩子和右孩子</li>
<li>三叉链表：为了方便检索结点的双亲或祖先结点，在结构中增加一个指向其双亲结点的指针域</li>
</ol>
<h2 id="1-3-二叉树的遍历"><a href="#1-3-二叉树的遍历" class="headerlink" title="1.3 二叉树的遍历"></a>1.3 二叉树的遍历</h2><p>（1）先序遍历 </p>
<ol>
<li>访问根结点</li>
<li>先序遍历结点的左子树</li>
<li>先序遍历结点的右子树</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PreOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">	if(b!&#x3D;NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	Visit(b-&gt;data); &#x2F;&#x2F;访问结点的数据域</span><br><span class="line">	PreOrder(b-&gt;lchild); &#x2F;&#x2F;先序遍历b的左子树</span><br><span class="line">	PreOrder(b-&gt;rchild); &#x2F;&#x2F;先序遍历b的右子树</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>（2）中序遍历</p>
<ol>
<li>中序遍历根结点的左子树</li>
<li>访问根结点</li>
<li>中序遍历根结点的右子树</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">	if(b!&#x3D;NULL)&#123;</span><br><span class="line">	InOrder(b-&gt;lchild); &#x2F;&#x2F;中序递归遍历b的左子树</span><br><span class="line">	Vist(b-&gt;data); &#x2F;&#x2F; 访问结点的数据域</span><br><span class="line">	InOrder(b-&gt;rchild); &#x2F;&#x2F;中序递归遍历b的右子树</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（3）后序遍历</p>
<ol>
<li>后序遍历根结点的左子树</li>
<li>后序遍历根结点的右子树</li>
<li>访问根结点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PostOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">	if(b!&#x3D;NULL)&#123;</span><br><span class="line">	PostOrder(b-&gt;lchild); &#x2F;&#x2F;后续遍历b的左子树</span><br><span class="line">	PostOrder(b-&gt;rchild); &#x2F;&#x2F;后续遍历b的右子树</span><br><span class="line">	Vist(b-&gt;data); &#x2F;&#x2F;访问结点的数据域</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）层次遍历<br>在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根结点开始，首先将根结点指针入队列，然后从头取出一个元素，每取一个元素，执行下面两个操作：</p>
<ol>
<li>访问该元素所指结点</li>
<li>若该元素所指结点的左、右孩子结点非空，则将该元素所指结点的左孩子指针和右孩子指针顺序入队</li>
</ol>
<p>此过程不断进行，当队列为空时，二叉树的层次遍历结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">void LevelorderTraverse(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">	BTNode *Queue[MAX_NODE], *p &#x3D; T</span><br><span class="line">	int front&#x3D;0, rear&#x3D;0;</span><br><span class="line">	if(p!&#x3D;NULL)</span><br><span class="line">	&#123;	</span><br><span class="line">		Queue[++rear]&#x3D;p; # 根结点入队</span><br><span class="line">	</span><br><span class="line">	while(front&lt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; Queue[++front]</span><br><span class="line">		visit(p-&gt;dta);</span><br><span class="line">		if(p-&gt;Lchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 左结点入队</span><br><span class="line">		if(p-&gt;Rchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 右结点入队</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）遍历与恢复</p>
<p>已知结点的先序遍历和中序遍历，可以唯一确定这颗二叉树</p>
<p>已知二叉树的后续序列和中序序列也可以唯一地确定一颗二叉树</p>
<p>（6）遍历的应用</p>
<ol>
<li>按满二叉树方式建立链式二叉树，在建立过程中借助一个一维数组$S[n]$，编号为$i$的结点指针保存在$S[i]$中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">typedef struct BTNode</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BTNode *Lchild, *Child;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *Create_BTree(void)</span><br><span class="line">&#123;</span><br><span class="line">	BTNode *T, *p, *s[MAX_NODE];</span><br><span class="line">	char ch;</span><br><span class="line">	int i,j;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">		if(i&#x3D;&#x3D;0) break; # 输入0结束</span><br><span class="line">		else&#123;</span><br><span class="line">			ch&#x3D;getchar();</span><br><span class="line">			p&#x3D;(BTNode *)malloc(sizeof(BTNode));</span><br><span class="line">			p-&gt;data&#x3D;ch;</span><br><span class="line">			p-&gt;Lchild&#x3D;p-&gt;Rchild&#x3D;NULL;</span><br><span class="line">			s[i]&#x3D;p;</span><br><span class="line">			if(i&#x3D;&#x3D;1) T&#x3D;p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			j &#x3D; i&#x2F;2 # j是i的双亲结点编号</span><br><span class="line">			if(i%2&#x3D;&#x3D;0) s[j]-&gt;Lchild&#x3D;p;</span><br><span class="line">			else s[j]-Rchild&#x3D;p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>按先序遍历对一颗二叉树进行扩充</li>
</ol>
<p>读入一棵二叉树对应的扩充二叉树的前序遍历的结点值序列。每读入一个结点值就进行分析：</p>
<ul>
<li>若是扩充结点值：令根指针为 NULL；</li>
<li>若是(正常)结点值：动态地为根指针分配一个结点，将该值赋给根结点，然后递归地  创建根的左子树和右子树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NULLKY &#39;?&#39;</span><br><span class="line">#define MAX_NODE 50</span><br><span class="line">typedef struct BTNode</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct BTNode *Lchild, *Rchild;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *Preorder_Create_BTree(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	ch &#x3D; getchar(); getchar();</span><br><span class="line">	if(ch&#x3D;&#x3D;NULLKY)</span><br><span class="line">	&#123;</span><br><span class="line">		T&#x3D;NULL;</span><br><span class="line">		return T;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		T&#x3D;(BTNode *)malloc(sizeof(BTNode));</span><br><span class="line">		T-&gt;data&#x3D;ch;</span><br><span class="line">		Preorder_Creat_BTree(T-&gt;Lchild);</span><br><span class="line">		Preorder_Creat_BTree(T-&gt;Rchild);</span><br><span class="line">		return T;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>求二叉树的深度</li>
</ol>
<p>利用层次遍历可以直接求得二叉树的深度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">int search_depth(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">	BTNode *Queue[MAX_NODE], *p&#x3D;T;</span><br><span class="line">	int front&#x3D;0,rear&#x3D;0,depth&#x3D;0,level; # level总是指向访问层的最后一个结点在队列的位置</span><br><span class="line">	if(T!&#x3D;NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		Queue[++rear]&#x3D;p; # 根结点入队</span><br><span class="line">		level &#x3D; rear; # 根是第一层的最后一个结点</span><br><span class="line">		while(front&lt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			p&#x3D;Queue[++front];</span><br><span class="line">			if(p-&gt;Lchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 左结点入队</span><br><span class="line">			if(p-&gt;Rchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 右结点入队</span><br><span class="line">			# 正好访问的是当前层的最后一个结点</span><br><span class="line">			if(front&#x3D;&#x3D;level)&#123;</span><br><span class="line">				depth++;</span><br><span class="line">				level&#x3D;rear;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-线索二叉树的基本概念和构造"><a href="#1-4-线索二叉树的基本概念和构造" class="headerlink" title="1.4 线索二叉树的基本概念和构造"></a>1.4 线索二叉树的基本概念和构造</h2><p>（1）线索二叉树的定义</p>
<p>为了保留结点在某种遍历序列中直接前驱和直接后继的位置信息，可以利用具有$n$个结点的二叉树中的叶子节点和一度节点的$n+1$的空指针域来表示。线索二叉树便利时可不需要栈，也不需要递归了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct BiTreeNode *Lchild, *Rchild;</span><br><span class="line">	int Ltag, Rtag;</span><br><span class="line">&#125;BiThrNode;</span><br></pre></td></tr></table></figure>

<p>（2）线索二叉树的结构</p>
<table>
<thead>
<tr>
<th align="center">lchild</th>
<th align="center">LTag</th>
<th align="center">data</th>
<th align="center">RTag</th>
<th align="center">rchild</th>
</tr>
</thead>
</table>
<p>若节点有左子树，则左指针lchild指示其左孩子（LTag=0）；否则，令指针指示其前驱（LTag=1）<br>若节点有右子树，则右指针rchild指示其右孩子（RTag=0）；否则，令指针指示其后继（RTag=1）</p>
<p>由于序列可由不同的遍历方法得到，因此线索树有先序线索二叉树、中序线索二叉树和后续线索二叉树</p>
<h1 id="2-树和森林"><a href="#2-树和森林" class="headerlink" title="2 树和森林"></a>2 树和森林</h1><h2 id="2-1-树的存储结构"><a href="#2-1-树的存储结构" class="headerlink" title="2.1 树的存储结构"></a>2.1 树的存储结构</h2><p>树的存储有多种方式，既可以是顺序存储也可以使链式存储，但是无论采用何种存储方式，都要求存储结构不但能够存储各结点本身的数据信息，还要能唯一地反映树中各结点之间的逻辑关系。</p>
<p>（1）双亲表示法</p>
<p>每个结点都有唯一的一个双亲结点，根据这一特性，可用有一组连续的存储空间（一维数组）存储树中的各个结点，数组中的一个元素表示树中的一个结点，数组元素为结构体类型，其中包含结点本身的信息以及结点的双亲结点在数组中的序号</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/75607BFFC3A8450EA03EE96468E42F6D?method=download&shareKey=5539f5c0d7c04ef62aca513e038e96d0" alt></p>
<p>（2）孩子链表示法</p>
<p>主体是一个与结点个数一样大小的一维数组，数组的每一个元素有两个域组成，一个域用来存放结点信息，另一个用来存放指针，该指针指向由该节点孩子组成的单链表的首位置。单链表的结构也由两个域组成，一个存放孩子结点在一维数组中的序号，另一个是指针域，指向下一个孩子。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/8A42544EBBA44326BBA5666F33BE24A1?method=download&shareKey=4c688f9694b88b0728ab777026686f16" alt></p>
<p>（3）孩子兄弟表示法</p>
<p>在树中，每个结点除信息域外，再增加两个分别指向该节点的第一个孩子结点和下一个兄弟结点的指针</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/FA250D1719794C3C9882EF5BCF3D863F?method=download&shareKey=91bbd9735987030fe5179f337c18e88a" alt></p>
<h2 id="2-2-森林和二叉树的转换"><a href="#2-2-森林和二叉树的转换" class="headerlink" title="2.2 森林和二叉树的转换"></a>2.2 森林和二叉树的转换</h2><p>（1）树转换为二叉树</p>
<ol>
<li>树中所有相邻兄弟之间加一条连线</li>
<li>对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</li>
<li>以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/EE4E54CB8140417F94E0F1FBD4E8935E?method=download&shareKey=178b6538a41ec660e9715ef1be1eb972" alt></p>
<p>（2）二叉树转为树</p>
<ol>
<li>加虚线，若某结点$i$是其父结点的左子树的根结点，则将该结点$i$的右子结点以及沿右子链不断地搜索所有的右子结点，将所有这些右子结点与$i$结点的父结点之间加虚线相连</li>
<li>去连线，去掉二叉树所有父结点与其右子结点之间的连线</li>
<li>规整化，将各结点按层次排列且将所有的虚线变为实线</li>
</ol>
<p>（3）森林转为二叉树</p>
<ol>
<li>将森林中的每棵树转化成相应的二叉树</li>
<li>第一课二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时得到的二叉树就是由森林转换得到的二叉树</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/1396EA2DA83C47B99970805C171BF8FA?method=download&shareKey=dd8d3b3b3470844848c0236d36c194eb" alt></p>
<p>（4）二叉树转为森林</p>
<ol>
<li>去连线，将二叉树B的根结点与其右子结点以及沿右子结点链方向的所有右子结点的连线全部去掉，得到若干棵孤立的二叉树，每一颗就是原来森林F中的树一次对应的二叉树</li>
<li>二叉树的还原，将各棵孤立的二叉树按二叉树还原为树的方法还原成一般的树</li>
</ol>
<h2 id="2-3-树和森林的遍历"><a href="#2-3-树和森林的遍历" class="headerlink" title="2.3 树和森林的遍历"></a>2.3 树和森林的遍历</h2><h3 id="2-3-1-树的遍历"><a href="#2-3-1-树的遍历" class="headerlink" title="2.3.1 树的遍历"></a>2.3.1 树的遍历</h3><p>（1）先根遍历</p>
<ol>
<li>访问根结点</li>
<li>按照从左到右的顺序先根遍历根结点的每一颗子树</li>
</ol>
<p>（2）后根遍历</p>
<ol>
<li>按照从左到右的顺序后根遍历结点的每一颗子树</li>
<li>访问根结点</li>
</ol>
<p>树的先根遍历与其转换的相应二叉树的先序遍历的结果序列相同；</p>
<p>树的后根遍历与其转换的相应二叉树的中序遍历结果序列相同</p>
<h3 id="2-3-2-森林的遍历"><a href="#2-3-2-森林的遍历" class="headerlink" title="2.3.2 森林的遍历"></a>2.3.2 森林的遍历</h3><p>（1）前序遍历</p>
<ol>
<li>访问森林中第一棵树的根结点</li>
<li>前序遍历第一课树的根结点的子树</li>
<li>前序遍历去掉地棵树后的子森林</li>
</ol>
<p>（2）中序遍历</p>
<ol>
<li>中序遍历第一课树的根结点的子树</li>
<li>访问森林中第一棵树的根结点</li>
<li>中序遍历去掉第一棵树后的子森林</li>
</ol>
<p>森林的前序遍历和中序遍历与所转换的二叉树的先序遍历和中序遍历的结果序列相同</p>
<h1 id="3-树的应用"><a href="#3-树的应用" class="headerlink" title="3 树的应用"></a>3 树的应用</h1><h2 id="3-1-二叉排序树"><a href="#3-1-二叉排序树" class="headerlink" title="3.1 二叉排序树"></a>3.1 二叉排序树</h2><p>（1）二叉排序树的性质</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于根节点的恶值；若右子树不空，则右子树所有结点的值均大于根结点的值</li>
<li>左右子树也都是二叉排序树</li>
</ol>
<p>若按中序遍历一颗二叉排序树，所得到的结点序列是一个递增序列，通常取二叉链表作为二叉排序树的存储结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	KeyType key; # 关键字</span><br><span class="line">	...# 其他数据域</span><br><span class="line">	struct Node *Lchild, *Rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure>

<p>（2）二叉排序树查找过程</p>
<ol>
<li>若查找树为空，查找失败</li>
<li>查找树非空，将给定值key与查找树的根结点关键码比较</li>
<li>若相等，查找成功，结束查找过程，否则<ul>
<li>当key小于根结点关键码，查找将在以左孩子为根的子树上继续进行，转1</li>
<li>当给key大于根结点关键码，查找将在以右孩子为根的子树上继续进行，转1</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）递归算法</span><br><span class="line">BSNode *BST_Search(BSTNode *T, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	if(T&#x3D;&#x3D;NULL) return NULL;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(T-&gt;key&#x3D;&#x3D;key) return T;</span><br><span class="line">		else if(key&lt; T-&gt;key) return BST_Search(T-&gt;Lchild,key);</span><br><span class="line">		else return BST_Search(T-&gt;Rchild,key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(2) 非递归算法</span><br><span class="line">BSTNode *BST_Search(BSTNode *T, keyType key)</span><br><span class="line">&#123;</span><br><span class="line">	BSTNode p&#x3D;T;</span><br><span class="line">	while(p!&#x3D;NULL &amp;&amp; p-&gt;key!&#x3D;key)</span><br><span class="line">	&#123;</span><br><span class="line">		if(key&lt; p-key) p&#x3D;p-&gt;Lchild;</span><br><span class="line">		else p&#x3D;p-&gt;Rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p!&#x3D;NULL) return p;</span><br><span class="line">	else return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）二叉排序树插入操作和构造一棵二叉排序树</p>
<p>设待插入节点的关键码为key，为将其插入，先要在二叉排序树中进行查找，若查找成功，不用插入；若查找不成功，则插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）递归算法</span><br><span class="line">void Insert_BST(BSTNode *T, keyType key)</span><br><span class="line">&#123;</span><br><span class="line">	BSTNode *x;</span><br><span class="line">	x &#x3D; (BSTNode *)malloc(sizeof(BSTNode));</span><br><span class="line">	x-&gt;key &#x3D; key; x-&gt;Lchild&#x3D;x-&gt;Rchild&#x3D;NULL;</span><br><span class="line">	if(T&#x3D;&#x3D;NULL) T&#x3D;x;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(T-&gt;key&#x3D;&#x3D; x-&gt;key) return; # 已有结点</span><br><span class="line">		else if(x-&gt;key &lt; T-&gt;key)&#123;</span><br><span class="line">				Inser_BST(T-&gt;Lchild,key);</span><br><span class="line">			&#125;</span><br><span class="line">		else Insert_BST(T-&gt;Rchild, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）非递归写法</span><br><span class="line">void Insert_BST(BSTNode *T, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	BSTNode *x, *p, *q;</span><br><span class="line">	x &#x3D; (BSTNode *)malloc(sizeof(BSTNode));</span><br><span class="line">	x-&gt;key&#x3D;key; x-&gt;Lchild &#x3D; x-&gt;Rchild&#x3D;NULL;</span><br><span class="line">	if(T&#x3D;&#x3D;NULL) T&#x3D;x;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;T;</span><br><span class="line">		while(p!&#x3D;NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				if(p-&gt;key&#x3D;&#x3D;x-&gt;key) return;</span><br><span class="line">				q&#x3D;p;</span><br><span class="line">				if(x-&gt;key &lt; p-&gt;key) p&#x3D;p-&gt;Lchild;</span><br><span class="line">				else p&#x3D;p-&gt;Rchild;&#125;</span><br><span class="line">		if(x-&gt;key &lt; q-&gt;key) q-&gt;Lchild&#x3D;x;</span><br><span class="line">		else q-&gt;Rchild&#x3D;x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）二叉排序树删除操作<br>从BST树上删除一个节点，仍然要保证删除后满足BST的性质，设被删除结点为p，其父结点为f</p>
<p>（前驱和后继是指中序遍历中的）</p>
<ol>
<li>若 p 是叶子结点： 直接删除 p。</li>
<li>若 p 只有一棵子树(左子树或右子树)：直接用 p 的左子树(或右子树)取代 p 的位置而成为 f 的一棵子树。原来 p 是 f 的左子树，则 p 的子树为 f 的左子树；原来 p 是 f 的右子树，则 p 的子树为 f 的右子树。</li>
<li>若 p 既有左子树又有右子树 ：<ul>
<li>a、用 p 的直接前驱结点代替 p。即从 p 的左子树中选择值最大的结点 s 放在 p 的位置(用结点 s 的内容替换结点 p 内容)，然后删除结点 s。s 是 p 的左子树中的最右边的结点且没有右子树，对 s 的删除同 2</li>
<li>b、用 p 的直接后继结点代替p。即从 p 的右子树中选择值最小的结点 s 放在 p 的位置(用结点 s 的内容替换结点 p 内容)，然后删除结点 s。s 是 p 的右子树中的最左边的结点且没有左子树，对 s 的删除同 2</li>
</ul>
</li>
</ol>
<h2 id="3-2-平衡二叉树"><a href="#3-2-平衡二叉树" class="headerlink" title="3.2 平衡二叉树"></a>3.2 平衡二叉树</h2><p>具有下列性质的二叉排序树：左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差的绝对值不超过一</p>
<p>结点类型定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BNode</span><br><span class="line">&#123;</span><br><span class="line">	KeyType key; # 关键字域</span><br><span class="line">	int Bfactoe; # 平衡因子域</span><br><span class="line">	... # 其它数据域</span><br><span class="line">	struct BNode *Lchild, *Rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure>

<p>（1）LL在结点a的左孩子的左子树进行插入，插入使结点a失去平衡</p>
<p>通过顺时针旋转调整</p>
<ol>
<li>用b取代a的位置</li>
<li>a成为b的右子树的根结点</li>
<li>b原来的右子树作为a的左子树<br><img src="https://note.youdao.com/yws/api/personal/file/A8C880E9070E4BCC80D88E2C693BA16A?method=download&shareKey=a1fb1ffd7ee5d74e98528ca8bebe6d57" alt></li>
</ol>
<p>（2）LR在结点a的左孩子的右子树上进行插入，插入使结点a失去平衡</p>
<p>通过LR旋转</p>
<ol>
<li>先以b进行一次逆时针旋转（将以b为根的子树旋转为以c为根）</li>
<li>以a进行一次顺时针旋转，将整棵子树旋转以c为根</li>
<li>c的右子树移到a的左子树位置，c的左子树移到b的右子树位置</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/F6D908CCFFB6491F8511CF4CC0C3B1AB?method=download&shareKey=ee74a5e0fd169044915253fc53c2e363" alt></p>
<p>（3）RL在结点a的右孩子的左子树上进行插入，插入使结点a失去平衡，与LR型正好对称</p>
<p>通过RL旋转</p>
<ol>
<li>先以b进行一次顺时针旋转</li>
<li>再以a进行一次逆时针旋转，将整棵子树（以a为根）旋转为以c为根</li>
<li>c的右子树移到b的左子树，c的左子树移到a的右子树</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/10E450C657424D2DA03FBD2C10AE1EE5?method=download&shareKey=e078245da33388048e5785f4c9fbaef0" alt></p>
<p>（4）RR在结点a的右孩子的右子树上进行插入，插入使结点a失去平衡</p>
<p>要进行一次逆时针旋转，和LL旋转正好对称</p>
<ol>
<li>用b取代a的位置</li>
<li>a作为b的左子树的根结点</li>
<li>b原来的左子树作为a的右子树</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/EAD2CBB56809414793546497AD6114FC?method=download&shareKey=d48eb4d2a65c980204ed747905b4ef89" alt></p>
<h2 id="3-3-哈夫曼树和哈夫曼编码"><a href="#3-3-哈夫曼树和哈夫曼编码" class="headerlink" title="3.3 哈夫曼树和哈夫曼编码"></a>3.3 哈夫曼树和哈夫曼编码</h2><p>（1）Huffman树的构造</p>
<ol>
<li>根据n个权值，构造哈夫曼树</li>
<li>选取两棵根结点权值最小的树作为左、右子树构造一棵新的二叉树，且新的二叉树根结点权值为其左、右子树根结点的权值之和</li>
<li>重复2操作，知道所有权值都使用上</li>
</ol>
<p>（2）Huffman编码</p>
<p>规定左分支代表“0”，右分支代表“1”。从根结点到每个叶子结点所经历的路径上的字符串，为该节点所对应的编码</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库与SQL知识总结</title>
    <url>/2020/08/29/DB/</url>
    <content><![CDATA[<h2 id="1-常见问题总结"><a href="#1-常见问题总结" class="headerlink" title="1 常见问题总结"></a>1 常见问题总结</h2><h2 id="1-1-什么是MySQL"><a href="#1-1-什么是MySQL" class="headerlink" title="1.1 什么是MySQL"></a>1.1 什么是MySQL</h2><p>MySQL是一种关系型数据库，默认端口号是33006，默认的存储引擎是InnoDB，只有InnoDB是事务性存储引擎</p>
<p><strong>MyISAM和InnoDB区别</strong></p>
<p>MyISAM是MySQL的默认数据引擎（5.5版之前）虽然性能极佳，但是不支持事务和行级锁，却最大的缺陷就是崩溃后无法安全恢复，在5.5版之后，MySQL就引入了InnoDB(事务性数据库引擎)</p>
<a id="more"></a>

<p><strong>两者对比</strong></p>
<ol>
<li>是否支持行级锁</li>
<li>是否支持事务和崩溃后的安全恢复</li>
<li>是否支持外键</li>
<li>是否支持MVCC</li>
</ol>
<p><strong>字符集和校对规则</strong></p>
<p>字符集指的是一种从二进制编码到某类字符符号的映射，校对规则是指某种字符集下的排序规则</p>
<p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承</p>
<p><strong>索引</strong></p>
<p>MySQL索引使用的数据结构主要有BTree索引和哈希索引，对哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单挑记录查询的时候，可以选择哈希索引，查询性能最快，其余大部分场景，建议选择BTree索引</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的</p>
<ul>
<li>MyISAM：B+树叶结点的data域存放的是数据记录地址，在检索索引的时候，先按照B+树搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，被称为非聚簇索引</li>
<li>InnoDB：其数据本身就是索引文件，索引文件和数据文件是分离的，其表数据文件本身就是按B+树组织的一个索引结构，树的叶结点data域保存了完整的数据记录，这个索引key时数据表的主键，因此InonoDB表数据文件本身就是主索引。这被称为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。</li>
</ul>
<p>在根据主索引搜索时，直到找到key所在的结点即取出数据，在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引，因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非常单调的字段作为主键，这样会造成主索引频繁分裂</p>
<h2 id="1-2-什么是事务？"><a href="#1-2-什么是事务？" class="headerlink" title="1.2 什么是事务？"></a>1.2 什么是事务？</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p>
<p>事务的四大特性（ACID）</p>
<ol>
<li>原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li>
<li>一致性（Consistency）：执行事务前后，数据保持一致，多个事务对统一数据读取的结果是相同的</li>
<li>隔离性（IsoIation）：并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库时独立的</li>
<li>持久性（Durability）：一个事务被提交之后。对数据库中数据的改变是永久的，即使数据库发送故障也不应该对齐有任何影响</li>
</ol>
<p><strong>并发事务带来哪些问题？</strong></p>
<ul>
<li>脏度（Dirty read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到这个数据是“脏数据”，依据“脏”数据所做的操作可能是不正确的</li>
<li>丢失修改（Lost to modify）：指一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失</li>
<li>不可重复读（Unrepeatableread）：指一个事务内多次读同一个数据，这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，就发生了在一个事务内两次读到的数据是不一样的情况</li>
<li>幻读（Phantom read）：幻读与不可重复读类似，它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录</li>
</ul>
<p><strong>不可重复读和幻读的区别</strong></p>
<p>不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，比如多读取一条记录发现记录增多或减少了</p>
<p><strong>事务隔离级别有哪些？MySQL的默认隔离级别是？</strong></p>
<p>SQL标准定义了四个隔离级别：</p>
<ul>
<li>READ-UNCOMMITTED（读取未提交）：最低的隔离界别，允许读取尚未提交的数据，可能会导致脏度，幻读，不可重复读</li>
<li>READ-COMMITTED（读取已提交）：允许读取并发事务已提交的数据，可以阻止脏度，但是幻读和不可重复读还是有可能发生</li>
<li>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据被本身事务自己所修改，可以阻止脏度和不可重复读，但幻读仍有可能发生</li>
<li>SERIALIZABLE（可串行化）：最高的隔离级别，完全俯冲ACID的隔离级别，所有事务依次逐个执行</li>
</ul>
<p>注意：与SQL标准不同的地方在于InnoDB存储引擎在<strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的Next-key Lock锁算法，因此可以避免幻读的产生。已经可以完全保证了事务的隔离性要求</p>
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别</p>
<p><strong>锁机制与InnoDB锁算法</strong></p>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁</li>
<li>InnoDB支持行级锁和表级锁，默认为行级锁</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗较少，不会出现死锁，但出发锁冲突的概率最高，并发度最低</li>
<li>行级锁：MySQL中粒度最小的一种锁，只针对当前的行进行加锁，行级锁能大大减少数据库操作的冲突，其并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li>
</ul>
<p><strong>大表优化</strong></p>
<p>当MySQL单表记录过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li>限定数据的范围</li>
<li>读/写分离</li>
<li>垂直分区：根据数据库里数据表的相关性进行拆分，把一张列比较多的表拆分为多张表</li>
<li>水平分区：数据表行的拆分</li>
</ol>
<p><strong>池化设计思想，什么是数据库连接池？为什么需要数据库连接池？</strong></p>
<p>数据库连接本质是一个socket连接，数据库服务端还要维护一些缓存和用户权限信息之类的，可以把数据库连接池看作是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，即昂贵又浪费资源。在连接池中，创建链接后，将其放置池中，并再次使用它，因此不必建立新的连接，如果使用了所有连接，则建立一个新连接并将其添加到池中。</p>
<h1 id="2-MySQL与SQL常用操作命令"><a href="#2-MySQL与SQL常用操作命令" class="headerlink" title="2 MySQL与SQL常用操作命令"></a>2 MySQL与SQL常用操作命令</h1><h2 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Windows服务 *&#x2F;</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath&#x3D; mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">&#x2F;* 连接与断开服务器 *&#x2F;</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure>

<h2 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 数据库操作 *&#x2F; ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure>

<h2 id="2-3-表的操作"><a href="#2-3-表的操作" class="headerlink" title="2.3 表的操作"></a>2.3 表的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET &#x3D; charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE &#x3D; engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory&#x2F;Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    	AUTO_INCREMENT &#x3D; 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT &#x3D; &#39;string&#39;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &#39;pattern&#39;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表结构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 &#x2F; DESCRIBE 表名 &#x2F; EXPLAIN 表名 &#x2F; SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE&#x3D;MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h2 id="2-4-数据操作"><a href="#2-4-数据操作" class="headerlink" title="2.4 数据操作"></a>2.4 数据操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 数据操作 *&#x2F; ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名&#x3D;值[, 字段名&#x3D;值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名&#x3D;新值[, 字段名&#x3D;新值] [更新条件]</span><br></pre></td></tr></table></figure>

<h2 id="2-5-字符集编码"><a href="#2-5-字符集编码" class="headerlink" title="2.5 字符集编码"></a>2.5 字符集编码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 字符集编码 *&#x2F; ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 &#x3D; 变量值</span><br><span class="line">    SET character_set_client &#x3D; gbk;</span><br><span class="line">    SET character_set_results &#x3D; gbk;</span><br><span class="line">    SET character_set_connection &#x3D; gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]&#x2F;SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure>

<h2 id="2-6-数据类型（列类型）"><a href="#2-6-数据类型（列类型）" class="headerlink" title="2.6 数据类型（列类型）"></a>2.6 数据类型（列类型）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 数据类型（列类型） *&#x2F; ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2&#x3D;65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset&#x3D;utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)&#x2F;3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );</span><br><span class="line">    insert into tab values (&#39;男, 女&#39;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure>

<h2 id="2-7-列属性（列约束）"><a href="#2-7-列属性（列约束）" class="headerlink" title="2.7 列属性（列约束）"></a>2.7 列属性（列约束）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 列属性（列约束） *&#x2F; ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &#39;val&#39;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment &#x3D; x进行设置，或 alter table tbl auto_increment &#x3D; x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &#39;注释内容&#39;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint &#96;t1_t2_fk&#96; foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure>

<h2 id="2-8-建表规范"><a href="#2-8-建表规范" class="headerlink" title="2.8 建表规范"></a>2.8 建表规范</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 建表规范 *&#x2F; ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure>

<h2 id="2-9-SELECT"><a href="#2-9-SELECT" class="headerlink" title="2.9 SELECT"></a>2.9 SELECT</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* SELECT *&#x2F; ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            &#x3D;, &lt;&#x3D;&gt;, &lt;&gt;, !&#x3D;, &lt;&#x3D;, &lt;, &gt;&#x3D;, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is&#x2F;is not 加上ture&#x2F;false&#x2F;unknown，检验某个值的真假</span><br><span class="line">            &lt;&#x3D;&gt;与&lt;&gt;功能相同，&lt;&#x3D;&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段&#x2F;别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段&#x2F;别名 排序方式 [,排序字段&#x2F;别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure>


<h2 id="2-10-UNION"><a href="#2-10-UNION" class="headerlink" title="2.10 UNION"></a>2.10 UNION</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* UNION *&#x2F; ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure>

<h2 id="2-11-子查询"><a href="#2-11-子查询" class="headerlink" title="2.11 子查询"></a>2.11 子查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 子查询 *&#x2F; ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money &#x3D; (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    !&#x3D; all()    相当于 not in</span><br><span class="line">    &#x3D; some()    相当于 in。any 是 some 的别名</span><br><span class="line">    !&#x3D; some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure>

<h2 id="2-12-连接查询-join"><a href="#2-12-连接查询-join" class="headerlink" title="2.12 连接查询(join)"></a>2.12 连接查询(join)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 连接查询(join) *&#x2F; ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num &#x3D; extra_info.stu_id;</span><br></pre></td></tr></table></figure>

<h2 id="2-13-TRUNCATE"><a href="#2-13-TRUNCATE" class="headerlink" title="2.13 TRUNCATE"></a>2.13 TRUNCATE</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* TRUNCATE *&#x2F; ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure>

<h2 id="2-14-备份与还原"><a href="#2-14-备份与还原" class="headerlink" title="2.14 备份与还原"></a>2.14 备份与还原</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 备份与还原 *&#x2F; ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure>

<h2 id="2-15-视图"><a href="#2-15-视图" class="headerlink" title="2.15 视图"></a>2.15 视图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure>

<h2 id="2-16-事务"><a href="#2-16-事务" class="headerlink" title="2.16 事务"></a>2.16 事务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据完整性方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit &#x3D; 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure>

<h2 id="2-17-锁表"><a href="#2-17-锁表" class="headerlink" title="2.17 锁表"></a>2.17 锁表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 锁表 *&#x2F;</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<h2 id="2-18-触发器"><a href="#2-18-触发器" class="headerlink" title="2.18 触发器"></a>2.18 触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 触发器 *&#x2F; ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure>

<h2 id="2-19-SQL编程"><a href="#2-19-SQL编程" class="headerlink" title="2.19 SQL编程"></a>2.19 SQL编程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* SQL编程 *&#x2F; ------------------</span><br><span class="line">--&#x2F;&#x2F; 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--&#x2F;&#x2F; 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var &#x3D; value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免&#x3D;被当作关系运算符看待，使用:&#x3D;代替。（set语句可以使用&#x3D; 和 :&#x3D;）。</span><br><span class="line">select @var:&#x3D;20;</span><br><span class="line">select @v1:&#x3D;id, @v2&#x3D;name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:&#x3D;30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var&#x3D;10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--&#x2F;&#x2F; 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--&#x2F;&#x2F; 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) &#x3D; 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) &#x3D; 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) &#x3D; 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) &#x3D; 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3&#x3D;1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分</span><br><span class="line">time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分</span><br><span class="line">date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--&#x2F;&#x2F; 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &#39;partten&#39;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--&#x2F;&#x2F; 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure>

<h2 id="2-10-存储过程"><a href="#2-10-存储过程" class="headerlink" title="2.10 存储过程"></a>2.10 存储过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 存储过程 *&#x2F; ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h2 id="2-11-用户和权限管理"><a href="#2-11-用户和权限管理" class="headerlink" title="2.11 用户和权限管理"></a>2.11 用户和权限管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 用户和权限管理 *&#x2F; ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE &#96;user&#96; SET PASSWORD&#x3D;PASSWORD(&quot;密码&quot;) WHERE &#96;user&#96; &#x3D; &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 &#x3D; PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限&#x2F;添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON &#96;pms&#96;.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure>

<h2 id="2-12-表维护"><a href="#2-12-表维护" class="headerlink" title="2.12 表维护"></a>2.12 表维护</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 表维护 *&#x2F;</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h2 id="2-13-杂项"><a href="#2-13-杂项" class="headerlink" title="2.13 杂项"></a>2.13 杂项</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 杂项 *&#x2F; ------------------</span><br><span class="line">1. 可用反引号（&#96;）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 &#x2F;* 注释内容 *&#x2F;</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#39;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（一）：线性表</title>
    <url>/2020/08/11/Data/</url>
    <content><![CDATA[<h1 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h1><h2 id="1-1-线性表的定义和基本操作"><a href="#1-1-线性表的定义和基本操作" class="headerlink" title="1.1 线性表的定义和基本操作"></a>1.1 线性表的定义和基本操作</h2><p>1.线性结构的特点是：在数据元素的非空有限集中</p>
<ul>
<li>存在唯一的一个被称作“第一个”的数据元素</li>
<li>存在唯一一个被称作“最后一个”的数据元素</li>
<li>除第一个之外，集合中的每个元素均只有一个前驱</li>
<li>除最后一个之外，集合中每个元素均只有一个后继</li>
</ul>
<p>2.线性表示一种线性结构，在一个线性表中数据元素的类型是相同的，长度可以根据需要增长或缩短</p>
<a id="more"></a>

<h2 id="1-2-线性表的实现"><a href="#1-2-线性表的实现" class="headerlink" title="1.2 线性表的实现"></a>1.2 线性表的实现</h2><h3 id="1-2-1-顺序存储"><a href="#1-2-1-顺序存储" class="headerlink" title="1.2.1 顺序存储"></a>1.2.1 顺序存储</h3><p>1.顺序表的定义<br>线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/96E6535559A647A3B6F63C3AE1535948?method=download&shareKey=7b053e18c9fb7504affa8b8851745fd7" alt></p>
<p>2.顺序表上基本运算的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; - -一一一线性表的动态分配顺序存储结构一一</span><br><span class="line">define LIST_INIT_SIZE 100 &#x2F;&#x2F;线性表存储空间的初始分量</span><br><span class="line"></span><br><span class="line">define LISTINCREMNT 10 &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line"></span><br><span class="line">1）静态结构：表一旦装满，不能扩充</span><br><span class="line">define MAX_SIZE 100</span><br><span class="line">typdef int Status;</span><br><span class="line">typdef int ElemType;</span><br><span class="line">typdef struct sqlist</span><br><span class="line">&#123;</span><br><span class="line">	ElemType Elem_array[Max_SIZE];</span><br><span class="line">	int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">2) 动态结构，可以扩充，新的大小计入数据成员maxSize中</span><br><span class="line">typedef struct sqlist&#123;</span><br><span class="line">ElempType *elem; &#x2F;&#x2F;存储数组int length</span><br><span class="line">int length &#x2F;&#x2F;当前表元素个数</span><br><span class="line">int maxSize; &#x2F;&#x2F;表的最大长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>(1)顺序表的初始化</p>
<p>将L设为引用参数，首先动态分配存储空间，然后将length置为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status Init_SqList(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">	L-&gt;elem &#x3D; (ElemType *)malloc(MAX_SIZE*sizeof(ElemType));</span><br><span class="line">	if (!L-&gt;elem)</span><br><span class="line">		return ERROR;</span><br><span class="line">	else&#123;</span><br><span class="line">		L-&gt;length &#x3D; 0;</span><br><span class="line">		return OK;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)插入运算</p>
<p>在第i个位置上插入x，从$a_i-a_n$都要向下移动一个位置，共需要移动$n-i+1$个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status Insert_SqList(Sqlist *L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	if (i&lt;0 || i-&gt;L-&gt;length+1) return ERROR;</span><br><span class="line">	if (L-&gt;length&gt;&#x3D;MAX_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(“溢出！\n”);</span><br><span class="line">			return ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	for (j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;* i-1位置以后的所有结点往后移 *&#x2F;</span><br><span class="line">			L-&gt;Elem_array[j+1]&#x3D;L-&gt;Elem_array[j];&#125;</span><br><span class="line">	L-&gt;Elem_array[i-1] &#x3D; e;</span><br><span class="line">	&#x2F;* 在i-1个位置插入*&#x2F;</span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)删除运算</p>
<p>删除第i个元素，其后面的元素$a_{i+1}-a_n$都要向上移动，共移动了$n-i$个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElemType Delete_SqList(Sqlist *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	int k;</span><br><span class="line">	ElemTpye x;</span><br><span class="line">	if (L-&gt;length&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(“要删除的数据元素不存在!\n”);</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		x&#x3D;L-&gt;Elem_array[i-1]; # 保存结点的值</span><br><span class="line">		for(k&#x3D;i; k &lt; L-&gt;length; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;Elem_array[k-1]&#x3D;L-&gt;Elem_array[k]; # i位置以后的所有结点前移</span><br><span class="line">		&#125;</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	reutrn x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/api/personal/file/A5E9B6356BA5483D8C339A5E599C9D35?method=download&shareKey=ffe88d5b4391046d95eebfc796a71a70" alt></p>
<p>3.顺序线性表的查找定位删除</p>
<p>在线性表$L=(a_1,a_2,\dots,a_n)$删除值为$x$的第一个节点</p>
<p>(1)在线性表L查找值为x的第一个数据元素</p>
<p>(2)将从找到的位置至最后一个结点依次向前移动一个位置</p>
<p>(3)线性表长度减1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status Locate_Delete_SqList(Sqlist *L, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D;0,k;</span><br><span class="line">	while(i&lt; L-&gt;length) # 查找值为x的第一个结点</span><br><span class="line">	&#123;</span><br><span class="line">		if(L-&gt;Elem_array[i]!&#x3D;x) i++;&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		for(k &#x3D; i+1; k&lt; L-&gt;length; k++) </span><br><span class="line">			L-&gt;Elem_array[k-1]&#x3D;L-&gt;Elem_array[k];</span><br><span class="line">		L-&gt;length--;</span><br><span class="line">		break;</span><br><span class="line">	&#125;	</span><br><span class="line">	if (i&gt;L-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;要删除的数据元素不存在！\n&quot;);</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.顺序表的合并问题</p>
<p>对于有序顺序表$L_a,L_b$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int MergeList(SqList La, SqList Lb, SqList *Lc)</span><br><span class="line">&#123;</span><br><span class="line">	Lc-&gt;listsize &#x3D; Lc.length &#x3D; La.lenth + Lb.length;</span><br><span class="line">	Pc &#x3D; Lc-&gt;elem &#x3D; (ElemType *)malloc(Lc.listsize * sizeof(ElemType));</span><br><span class="line">	if(!Lc.elem) exit(overflow);</span><br><span class="line">	pa_last &#x3D; La.elem + La.length-1;</span><br><span class="line">	pb_last &#x3D; Lb.elem + Lb.length-1;</span><br><span class="line">	while(pa&lt;&#x3D;pa_last &amp;&amp; pb &lt;&#x3D; pb_last)&#123;</span><br><span class="line">		if(*pa&lt;&#x3D;*pb)</span><br><span class="line">			*pc++&#x3D;*pa++;</span><br><span class="line">		else</span><br><span class="line">			*pc++&#x3D;*pb++;</span><br><span class="line">	&#125;</span><br><span class="line">	while(pa&lt;pa_last) *pc++&#x3D;*pa++;</span><br><span class="line">	while(pb&lt;&#x3D;pb_last) *pc++&#x3D;*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-链式存储"><a href="#1-2-2-链式存储" class="headerlink" title="1.2.2 链式存储"></a>1.2.2 链式存储</h3><p>1.单链表</p>
<p>线性表的链式存储结构特点是用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以使不连续的）</p>
<p>定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode* next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>


<p>2.单链表基本运算实现</p>
<p>（1）建立单链表</p>
<ul>
<li>头插法————在链表的头部插入节点建立单链表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *create_LinkList(void) # 头插法创建单链表，头结点head作为返回值</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	LNode *head, *p;</span><br><span class="line">	head &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">	head-&gt;next &#x3D; NULL # 创建链表的头结点head</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">		if(data&#x3D;&#x3D;327667) break;</span><br><span class="line">		p&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">		p-&gt;data &#x3D; data; # 数据域赋值</span><br><span class="line">		p-&gt;next &#x3D; head-&gt;next;</span><br><span class="line">		head-&gt;next &#x3D; p; # 钩链，新创建的结点总是作为第一个结点</span><br><span class="line">	&#125;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/8849B8BB9FE946FC8CC970D8022939A1?method=download&shareKey=e854f232f11469e6c244f77d5f73ab42" alt></p>
<ul>
<li>尾插法————头插法虽然简单但是读入的数据元素顺序与生成的链表中元素是相反的，为了次序一致，可以使用尾插法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *create_LinkList(void) # 尾插法创建单链表，头结点head作为返回值</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	LNode *head, *last, *q;</span><br><span class="line">	head &#x3D; p &#x3D; (LNode *)malloc(sizeof(LNode))</span><br><span class="line">	p-&gt;next&#x3D;NULL # 创建单链表的头结点head</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">		if(data&#x3D;&#x3D;32767) break;</span><br><span class="line">		q &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">		q-&gt;data&#x3D;data # 数据域赋值</span><br><span class="line">		q-&gt;next &#x3D; last-&gt;next;</span><br><span class="line">		last-&gt;next&#x3D;q;</span><br><span class="line">		last&#x3D;q; # 钩链，新创建的结点总是作为最后一个结点</span><br><span class="line">	&#125;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/A17A2DAD6A0B44F8B383E21B37DFBC81?method=download&shareKey=6b0d21c3a6ea6e2ed2387497e28ee6a0" alt></p>
<p>(2)查找操作</p>
<ul>
<li>按序号查找</li>
</ul>
<p>子单链表中，取得第1个数据元素必须从头指针出发寻找，因此单链表是非随机存取的存储结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElemType Get_Elem(LNode *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	LNode *p;</span><br><span class="line">	if(i&lt;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i太小\n&quot;);</span><br><span class="line">		return;&#125;</span><br><span class="line">	P&#x3D;L-&gt;next; j&#x3D;1 # 使P指向第一个结点</span><br><span class="line">	while(P!&#x3D;NULL &amp;&amp; j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		j++;&#125; # 移动指针p，j计数</span><br><span class="line">	if(p&#x3D;&#x3D;NULL)</span><br><span class="line">		return -32768</span><br><span class="line">	else</span><br><span class="line">		return p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按值查找</li>
</ul>
<p>查找时从开始节点出发，沿链表逐个将节点的值和给定值key作比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *Locate_Note(LNode *L, int key)</span><br><span class="line">&#123;</span><br><span class="line">	LNode *p&#x3D;L-&gt;next;</span><br><span class="line">	while(P!&#x3D;NULL &amp;&amp; p-&gt;data!&#x3D;key) p&#x3D;p-&gt;next;</span><br><span class="line">	if(p-&gt;data&#x3D;&#x3D;key) return p;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;所要查找的结点不存在！\n&quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）插入运算（后插法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Insert_LNode(LNode *L, int i, ElemType e)</span><br><span class="line">&#x2F;*	在以 L 为头结点的单链表的第 i 个位置插入值为 e 的结点 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	int j&#x3D;0; LNode *p, *q;</span><br><span class="line">	if(i&lt;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i太小\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	while(P!&#x3D;NULL &amp;&amp; j&lt;i-1)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">		if(P&#x3D;&#x3D;NULL) printf(&quot;i太大!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		q&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">		q-&gt;data&#x3D;e;</span><br><span class="line">		q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）删除运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Delete_LinkList(LNode *L, int i)</span><br><span class="line">&#x2F;*	删除以 L 为头结点的单链表中的第 i 个结点	*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	int j&#x3D;1; LNode *p,*q;</span><br><span class="line">	if(i&lt;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i太小\n&quot;);</span><br><span class="line">		return;&#125;</span><br><span class="line">	p&#x3D;L; q&#x3D;L-&gt;next;</span><br><span class="line">	while(q!&#x3D;NULL &amp;&amp; j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;q;</span><br><span class="line">		q&#x3D;q-&gt;next;</span><br><span class="line">		j++;&#125;</span><br><span class="line">	if(p&#x3D;&#x3D;NULL) printf(&quot;i太大!\n&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		p-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">		free(q);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.单链表的合并</p>
<p>若La,Lb两个链表的长度分别是m,n，则链表合并的时间复杂度为O(m+n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LNode *Merge_LinkList(LNode *La, LNode *Lb)</span><br><span class="line">&#x2F;*合并以 La，Lb 为头结点的两个有序单链表*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	LNode *Lc, *pa, *pb, *pc, *ptr;</span><br><span class="line">	Lc &#x3D; La; pc &#x3D; La;</span><br><span class="line">	pa&#x3D;La-&gt;next; pb&#x3D;Lb-&gt;next;</span><br><span class="line">	while(pa!&#x3D;NULL &amp;&amp; pb!&#x3D;NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pa-&gt;data &lt; pb-&gt;data)</span><br><span class="line">		&#123;	</span><br><span class="line">			pc-&gt;next&#x3D;pa;</span><br><span class="line">			pc&#x3D;pa;</span><br><span class="line">			pa&#x3D;pa-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		if(pa-&gt;data &gt; pb-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pb;</span><br><span class="line">			pc&#x3D;pb;</span><br><span class="line">			pb&#x3D;pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;* 如果两个值相等，将pa所指结点合并，pb所指结点删除*&#x2F;</span><br><span class="line">		if(pa-&gt;data&#x3D;&#x3D;pb-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pa;</span><br><span class="line">			pc&#x3D;pa;</span><br><span class="line">			pa&#x3D;pa-&gt;next;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(pa!&#x3D;NULL) pc-&gt;next&#x3D;pa;</span><br><span class="line">	else pc-&gt;next&#x3D;pb;</span><br><span class="line">	free(Lb);</span><br><span class="line">	return Lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.循环链表</p>
<p>对于单链表，最后一个节点的指针域是空指针，如果将该链表投指针置入该指针域，则使得链表头尾节点相连，构成了单循环链表</p>
<p>对于单链表只能从头结点开始遍历整个链表，而对于单循环链表则可以从表中任意结点   开始遍历整个链表，不仅如此，有时对链表常做的操作是在表尾、表头进行，此时可以改变   一下链表的标识方法，不用头指针而用一个指向尾结点的指针 R 来标识，可以使得操作效率得以提高。</p>
<ol start="5">
<li>双向链表</li>
</ol>
<table>
<thead>
<tr>
<th align="center">前驱指针域</th>
<th align="center">数据域</th>
<th align="center">后继指针域</th>
</tr>
</thead>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Dulnode</span><br><span class="line">&#123;	ElemType data;</span><br><span class="line">	struct Dulnode	*prior, *next;</span><br><span class="line">&#125;DulNode;</span><br></pre></td></tr></table></figure>

<p>(1)双向链表的插入</p>
<ol>
<li>插入时仅仅指出直接前驱节点，钩链时必须注意先后次序是：“先右后左”</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S&#x3D;(DulNode *)malloc(sizeof(DulNode));</span><br><span class="line">S-&gt;data&#x3D;e;</span><br><span class="line">S-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior&#x3D;S;</span><br><span class="line">p-&gt;next&#x3D;S;</span><br><span class="line">S-&gt;prior&#x3D;p; # 操作次序非常需要</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入时同时指出直接前驱节点p和直接后继节点q，钩链时无需注意先后次序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S&#x3D;(DulNode *)malloc(sizeof(DulNode));</span><br><span class="line">S-&gt;data&#x3D;e;</span><br><span class="line">p-&gt;next&#x3D;S;</span><br><span class="line">S-&gt;next&#x3D;q;</span><br><span class="line">S-&gt;prior&#x3D;p;</span><br><span class="line">q-&gt;prior&#x3D;S;</span><br></pre></td></tr></table></figure>

<p>(2)双向链表中节点的删除</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/9E3F091C1048407BA19F473010DBB842?method=download&shareKey=71f41f90b3a0d26a4b185941b04bd5d9" alt></p>
<p>删除时可以不引入新的辅助指针变量，可以直接先断链，再释放结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;prior-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior&#x3D;p-&gt;prior; </span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure>
<p>注意：与单链表的插入和删除操作不同的是，在双向链表中插入和删除必须同时修改两个方向上的指针域的指向。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（二）：栈、队列和数组</title>
    <url>/2020/08/13/Data2/</url>
    <content><![CDATA[<h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h1><p>限定仅在表尾进行插入或删除操作的线性表</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/E759729F50D449788BC9B52C9C1611E9?method=download&shareKey=4708c48d5e45c8fd0af3e6ec588b1381" alt></p>
<h2 id="1-1-栈的顺序存储结构"><a href="#1-1-栈的顺序存储结构" class="headerlink" title="1.1 栈的顺序存储结构"></a>1.1 栈的顺序存储结构</h2><p>栈的顺序存储结构简称为顺序栈，用一维数组来存储栈。根据数组是否可以根据需要增大，又可分为静态顺序栈和动态顺序栈</p>
<a id="more"></a>

<p>（1）动态顺序栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本操作实现</span><br><span class="line">1 栈的定义</span><br><span class="line"># define STACK_SIZE 100;</span><br><span class="line"># define STACKINCREMENT 10;</span><br><span class="line"># typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct sqstack</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *bottem; # 栈不存在时为NULL</span><br><span class="line">	ElemType *top; # 栈顶指针</span><br><span class="line">	int stacksize; # 当前已分空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">SqStack Init_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	S.bottom &#x3D; (ElemType *)malloc(STACK_SIZE * sizeof(ElemType));</span><br><span class="line">	if (!S.bottom) return ERROR;</span><br><span class="line">	S.top &#x3D; S.bottom; # 栈空时栈顶和栈底指针相同</span><br><span class="line">	S.stacksize &#x3D; STACK_SIZE;</span><br><span class="line">	return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 压栈</span><br><span class="line">Status push(SqStack &amp;S, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if(S.top-S.bottom&gt;&#x3D;S.sstacksize-1)</span><br><span class="line">	&#123;	# 栈满，追加空间</span><br><span class="line">		S.bottom&#x3D;(ElemType *)realloc(S.bottom, (S.STACKINCRMENT+STACK_SIEZE)*sizeof(ElemType));</span><br><span class="line">		if(!S.bottom) return ERROR;</span><br><span class="line">		S.top &#x3D; S.bottom+S.stacksize-1;</span><br><span class="line">		S.stacksize+&#x3D;STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top &#x3D; e; S.top++; # 栈顶指针+1，e称为新的栈顶</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4 弹栈</span><br><span class="line">Status pop(SqStack &amp;S, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">	if(S.top&#x3D;&#x3D;S.bottom) return ERROR;</span><br><span class="line">	S.top--; *e &#x3D; S.top;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）静态顺序栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本操作的实现</span><br><span class="line">1 栈的类型定义</span><br><span class="line"># define MAX_STACK_SIZE 100</span><br><span class="line">typedef int ElemTypde;</span><br><span class="line">typedef struct Sqstack</span><br><span class="line">&#123;</span><br><span class="line">	ElemType stack_array[MAX_STACK_SIZE];</span><br><span class="line">	int top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">SqStack Init_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	S.top &#x3D; 0;</span><br><span class="line">	return S;</span><br><span class="line">&#125;</span><br><span class="line">3 压栈</span><br><span class="line">Status push(SqStack &amp;S, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if(S.top&#x3D;&#x3D;MAX_STACK_SIZE-1) return ERROR;</span><br><span class="line">	S.top++;</span><br><span class="line">	S.stack_array[S.top]&#x3D;e</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line">4 弹栈</span><br><span class="line">Status pop(SqStack &amp;S, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">	if(S.top&#x3D;&#x3D;0) return ERROR;</span><br><span class="line">	*e &#x3D; S.stack_array[S.top];</span><br><span class="line">	S.top--;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）栈的链式存储结构</p>
<p>链栈，是运算受限的单链表，其插入和删除操作只能在表头位置上进行，栈顶指针top就是链表的头指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 栈的定义</span><br><span class="line">typedef struct Stack_Node</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	Struct Stack_Node *next;</span><br><span class="line">&#125;Stack_Node;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">Stack_Node *Init_Link_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">	Stack_Node *top;</span><br><span class="line">	top &#x3D; (Stack_Node *)malloc(sizeof(Stack_Node));</span><br><span class="line">	top-&gt;next&#x3D;NULL;</span><br><span class="line">	return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 压栈</span><br><span class="line">Status push(Stack_Node *top, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	Stack_Node *p;</span><br><span class="line">	p &#x3D; (Stack_Node *)malloc(sizeof(Stack_Node));</span><br><span class="line">	if(!p) return ERROR;</span><br><span class="line">	p-&gt;data &#x3D; e;</span><br><span class="line">	p-&gt;next &#x3D; top-&gt;next;</span><br><span class="line">	top-&gt;next &#x3D; p;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4 出栈</span><br><span class="line">Status pop(Stack_Node *top, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">	Stack_Node *p;</span><br><span class="line">	if(top-&gt;next&#x3D;NULL) return ERROR;</span><br><span class="line">	p &#x3D; top-&gt;next; *e&#x3D;p-&gt;data;</span><br><span class="line">	top-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">	free(p)</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/api/personal/file/179D6F1B2AA8401183DAD94F42E83FE9?method=download&shareKey=2b508c9cf73a4e6f8d5eb58630dc5f0c" alt></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/8ABC92C47E6C482CBEB192D618EF06B8?method=download&shareKey=4d35165ff818a4551ec522a880c9c59a" alt></p>
<h2 id="1-2-栈的应用"><a href="#1-2-栈的应用" class="headerlink" title="1.2 栈的应用"></a>1.2 栈的应用</h2><p>（1）数制转换<br>十进制数N和其他d进制数的转换是计算机实现计算的基本问题，最简单算法基于：$N=(N\ div\ d)* d + N\ mod\ d$</p>
<p>采用静态顺序栈方法实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将十进制数N转化为d进制数</span><br><span class="line">void conversion(int n, int d)</span><br><span class="line">&#123;</span><br><span class="line">	SqStack S; int k, *e;</span><br><span class="line">	S&#x3D;Init_Stack();</span><br><span class="line">	# 求所有的余数，进栈	</span><br><span class="line">	while(n&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		k &#x3D; n%d;</span><br><span class="line">		push(S,k);</span><br><span class="line">		n&#x3D;n&#x2F;d;</span><br><span class="line">	&#125;</span><br><span class="line">	# 栈不空时，输出</span><br><span class="line">	while(S.top!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		pop(S,e);</span><br><span class="line">		printf(&quot;%1d&quot;, *e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）括号匹配</p>
<p>设置一个栈，当读到左括号时，左括号进栈，当读到右括号时，则从栈中弹出一个元素，与读到的左括号进行匹配，若匹配成功则继续读入；否则匹配失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define TRUE 0</span><br><span class="line">#define FALSE -1</span><br><span class="line">SqStack S;</span><br><span class="line">S &#x3D; Init_Stack();</span><br><span class="line">int Match_Brackets()</span><br><span class="line">&#123;</span><br><span class="line">	char ch, x;</span><br><span class="line">	scanf(&quot;%c&quot;, &amp;ch);</span><br><span class="line">	while(asc(ch)!&#x3D;13)</span><br><span class="line">	&#123;</span><br><span class="line">		if((ch&#x3D;&#x3D;&#39;(&#39;)||(ch&#x3D;&#x3D;&#39;[&#39;)) push(S,ch);</span><br><span class="line">		else if(ch&#x3D;&#x3D;&#39;]&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			x&#x3D;pop(S);</span><br><span class="line">			if(x!&#x3D;&#39;[&#39;)</span><br><span class="line">		&#123;	</span><br><span class="line">			printf(&quot;&#39;]&#39;括号不匹配&quot;);</span><br><span class="line">			return FALSE;&#125;&#125;</span><br><span class="line">		else if(ch&#x3D;&#x3D;&#39;)&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			x&#x3D;pop(S);</span><br><span class="line">			if(x!&#x3D;&#39;(&#39;)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;&#39;(&#39;括号不匹配&quot;)，</span><br><span class="line">				return FALSE;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		if(S.top!&#x3D;0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;括号数量不匹配&quot;);</span><br><span class="line">			return FALSE;&#125;</span><br><span class="line">		else return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）递归</p>
<p>为保证递归调用正确执行，系统设立一个“递归工作栈”，作为整个递归调用过程期间使用的数据存储区。每一层包含的信息如：参数，局部变量、上一层的返回地址构建一个“工作记录”。每进入一层递归栈，就产生一个新的工作记录压入栈顶；每退出一层递归，就从栈顶弹出一个工作记录。</p>
<h1 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h1><p>插入在表一端进行，而删除在表的另一端进行，把允许插入的一端叫队尾，允许删除的一端叫队头</p>
<h2 id="2-1-队列的顺序存储结构"><a href="#2-1-队列的顺序存储结构" class="headerlink" title="2.1 队列的顺序存储结构"></a>2.1 队列的顺序存储结构</h2><p><img src="https://note.youdao.com/yws/api/personal/file/6E8BB975C5E840FA836368D66975CA58?method=download&shareKey=dff56d5e9e448f78b30951418edd884a" alt></p>
<p>当尾指针移动到最后，再有元素入队就会溢出，但是此时队列并未真正的“满员”，这种现象称为“假溢出”，为了解决假溢出，可以将队列的数据区看成首尾相接的循环结构，头尾指针的关系不变，将其称为“循环队列”</p>
<p>约定以“队列头指针在队列尾指针的下一位置（指换装的下一位置）”上作为队列满的标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队空特征：front&#x3D;rear;</span><br><span class="line">队满特征：front&#x3D;(rear+1)%MAX_QUEUE_SIZE;</span><br><span class="line">队列长度：L&#x3D;(MAX_QUEUE_SIZE+rear-front)%MAX_QUEUE_SIZE；</span><br><span class="line"></span><br><span class="line">静态顺序队列，其类型定义如下：</span><br><span class="line"># define MAX_QUEUE_SIZE 100</span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">	ElemType Queue_array[MAX_QUEUE_SIZE];</span><br><span class="line">	int front;</span><br><span class="line">	int rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">循环队列的基本操作</span><br><span class="line">1 循环队列的初始化</span><br><span class="line">Status Init_CirQueue(* &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">	Q &#x3D; (SqQueue *)malloc(sizeof(SqQueue));</span><br><span class="line">	if(Q&#x3D;&#x3D;NULL) return ERROR;</span><br><span class="line">	Q-&gt;front&#x3D; Q-&gt;rear&#x3D;0;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2 入队操作</span><br><span class="line">Status Insert_CirQueue(SqQueue *&amp;Q, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if((Q-&gt;rear+1)%MAX_QUEUE_SIZE&#x3D;&#x3D;Q-&gt;front) return ERROR;</span><br><span class="line">	Q-&gt;Queue_array[Q-&gt;rear] &#x3D;e;</span><br><span class="line">	Q-&gt;rear&#x3D;(Q-&gt;rear+1)%MAX_QUEUE_SIZE;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 出队操作</span><br><span class="line">Status Delete_CireQueue(SqQueue *&amp;Q, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">	if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear) return ERROR;</span><br><span class="line">	*x &#x3D; Q-&gt;Queue_array[Q-&gt;front];</span><br><span class="line">	Q-&gt;front &#x3D; (Q-&gt;front+1)% MAX_QUEUE_SIZE;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-队列的链式存储结构"><a href="#2-2-队列的链式存储结构" class="headerlink" title="2.2 队列的链式存储结构"></a>2.2 队列的链式存储结构</h2><p>队列的链式存储结构简称为链队列，是限制仅在表头进行删除操作和表尾进行插入操作的单链表，需要两类不同的结点：数据元素结点，队列的队首指针和队尾指针的结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素结点的定义</span><br><span class="line">typedef struct Qnode</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	Struct Qnode *next;</span><br><span class="line">&#125;QNode;</span><br><span class="line">指针结点类型定义：</span><br><span class="line">typedef struct link_queue</span><br><span class="line">&#123;</span><br><span class="line">	QNode *front, *rear;</span><br><span class="line">&#125;Link_Queue;</span><br></pre></td></tr></table></figure>


<p><img src="https://note.youdao.com/yws/api/personal/file/3B00BB79D4854E1FAD7625888C9A5550?method=download&shareKey=b324c8b770023286850dac1c9c3e30fb" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 链队列初始化</span><br><span class="line">LinkQueue *Init_Link_Queue(void)</span><br><span class="line">&#123;</span><br><span class="line">	Link_Queue *Q; </span><br><span class="line">	QNode *p;</span><br><span class="line">	p &#x3D; (QNode *)malloc(sizeof(QNode)) # 开辟头结点</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	Q &#x3D; (Link_Queue *)malloc(sizeof(Link_Queue)); # 开辟链队的指针结点</span><br><span class="line">	Q.front &#x3D; Q.rear&#x3D;p;</span><br><span class="line">	return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2 链队列的入队</span><br><span class="line">在已知队列的队尾插入一个元素e,即修改队尾指针Q.rear</span><br><span class="line">Status Insert_LinkQueue(Link_Queue *Q, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	QNode *p;</span><br><span class="line">	p &#x3D; (QNode *)malloc(sizeof(QNode)); if(!p) return ERROR;</span><br><span class="line">	p-&gt;data&#x3D;e; p-&gt;next&#x3D;NULL;</span><br><span class="line">	Q-&gt;rear-&gt;next&#x3D;p;</span><br><span class="line">	Q-&gt;rear&#x3D;p;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 链队列的出队</span><br><span class="line">Status Delete_LinkQueue(LinkQueue *Q, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">	QNode *p;</span><br><span class="line">	if(Q-&gt;front &#x3D; Q-&gt;rear) return ERROR;</span><br><span class="line">	p&#x3D;Q-&gt;front-&gt;next;</span><br><span class="line">	*x &#x3D; p-&gt;data;</span><br><span class="line">	Q-&gt;front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	if(p&#x3D;&#x3D;Q-&gt;rear) Q-&gt;rear&#x3D;Q-&gt;front; # 当队列只有一个结点时应防止丢失队尾指针</span><br><span class="line">	free(p);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-特殊矩阵的压缩存储"><a href="#3-特殊矩阵的压缩存储" class="headerlink" title="3 特殊矩阵的压缩存储"></a>3 特殊矩阵的压缩存储</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>数组是一组对偶（下标值，数据元素值）的集合，并且该序列必须存储在一块地址连续的存储单元中</p>
<ul>
<li>数组中的元素数据具有相同数据类型</li>
<li>数组是一种随机存取结构，给定一组下标，就可以访问与其对应的数据元素</li>
<li>数组中的数据元素个数是固定的</li>
</ul>
<p>二维数组是最简单的多维数组，通常有两种顺序存储方式</p>
<p>（1）行优先顺序：将数组元素按行排列，第$i+1$个行向量紧接在第$i$个行向量后面</p>
<p>设有二维数组$A=(a_{ij})m * n$，若每个元素占有的存储单元为1个，$LOC[a_{11}]$表示数组的首地址</p>
<p>二维数组中，任意元素$a_{ij}$的地址是：<br>$$LOC[a_{ij}]=LOC[a_{11}]+[(i-1) * n+(j-1)] * 1$$</p>
<p>（2）列优先顺序：将数组元素按列排列，第$j+1$个列向量紧接在第$j$个列向量后面</p>
<p>二维数组中，任意元素$a_{ij}$的地址是：<br>$$LOC[a_{ij}]=LOC[a_{11}]+[(j-1) * m+(i-1)] * 1$$</p>
<h2 id="3-2-特殊矩阵"><a href="#3-2-特殊矩阵" class="headerlink" title="3.2 特殊矩阵"></a>3.2 特殊矩阵</h2><p>特殊矩阵（对称矩阵，对角矩阵，三角矩阵）压缩矩阵：若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</p>
<p>（1）对称矩阵</p>
<p>关于主对角线对称，因此只需存储上三角或下三角即可</p>
<p>以一维数组$sa[n(n+1)/2]$作为n阶对称矩阵A的存储结构，则$sa[k]$和矩阵元$a_{ij}$之间存在着一一对应的关系：</p>
<p>$$<br>k=<br>\begin{cases}<br>\frac{i(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{j(j-1)}{2}+i-1,\ i&lt;j<br>\end{cases}<br>$$</p>
<p>（2）三角矩阵</p>
<ul>
<li>下三角矩阵</li>
</ul>
<p>在下三角矩阵，主对角线以上的元素是一个常量，存完下三角中的元素之后，紧接着储存对角线上方的常量，因为是同一个常数，所以存一个即可</p>
<p>共存储了$n(n+1)/2$个元素，设存入向量$sa=[k]$中，$k$与$i，j$的对应关系为:</p>
<p>$$<br>k=<br>\begin{cases}<br>\frac{i(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{n(n-1)}{2},\ i&lt;j<br>\end{cases}<br>$$</p>
<ul>
<li>上三角矩阵<br>和下三角矩阵类似，其对应关系如下：<br>$$<br>k=<br>\begin{cases}<br>\frac{(2n-i+2)(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{n(n-1)}{2},\ i&lt;j<br>\end{cases}<br>$$</li>
</ul>
<p>（3）对角矩阵</p>
<p>所有非零元素都集中在以主对角线为中心的对角区域，即除了主对角线和它的上下方若干条对角线的元素外，所有其他元素都为零（或同一个常数C）</p>
<h2 id="3-3-稀疏矩阵"><a href="#3-3-稀疏矩阵" class="headerlink" title="3.3 稀疏矩阵"></a>3.3 稀疏矩阵</h2><p>稀疏矩阵：设矩阵 A 是一个 $n * m$ 的矩阵中有 $s$ 个非零元素，设 $\delta=s/(n * m)$，称$\delta$为稀疏因子，如果某一矩阵的稀疏因子$\delta$满足$\delta&lt;=0.05$ 时称为稀疏矩阵。对于稀疏矩阵，采用压缩存储方法时，只存储非 0 元素。必须存储非 0 元素的行下标值、列下标值、元素值。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/60254E2717D14DB39AF9A804B447F040?method=download&shareKey=cc6925679ea8792332ab7da244769187" alt></p>
<p>（1）三元组顺序表</p>
<p>若以行序为主序，稀疏矩阵中所有非 0 元素的三元组，就可以得构成该稀疏矩阵的一个三元组顺序表。相应的数据结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1） 三元组结点定义</span><br><span class="line">#define MAX_SIZE 101 </span><br><span class="line">typedef int elemtype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;	int row; &#x2F;*	行下标	*&#x2F; </span><br><span class="line">	int col; &#x2F;*		列下标	*&#x2F; </span><br><span class="line">	elemtype value; &#x2F;*	元素值	*&#x2F;</span><br><span class="line">&#125;Triple;</span><br><span class="line">（2） 三元组顺序表定义</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	int rn;	# 行数</span><br><span class="line">	int cn; # 列数</span><br><span class="line">	int tn; # 非零元素个数</span><br><span class="line">	Triple data[MAX_SIZE];</span><br><span class="line">&#125;TMatrix;</span><br></pre></td></tr></table></figure>

<p>（2）十字链表</p>
<p>对于稀疏矩阵，当非 0 元素的个数和位置在操作过程中变化较大时，采用链式存储结构表示比三元组的线性表更方便。<br>矩阵中非 0 元素的结点所含的域有：行、列、值、行指针(指向同一行的下一个非 0 元)、<br>列指针(指向同一列的下一个非 0 元)。其次，十字交叉链表还有一个头结点，结点的结构如图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/9CBAA88EAE7344A29B1EE9251565FE35?method=download&shareKey=9a5a57e9724f4a833bbf4016fc97ce24" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Clnode</span><br><span class="line">&#123;</span><br><span class="line">	int row, col;</span><br><span class="line">	elemtype value;</span><br><span class="line">	struct Clnode *down, *right;</span><br><span class="line">&#125;QLNode;</span><br><span class="line"></span><br><span class="line">typdef struct Clonde</span><br><span class="line">&#123;</span><br><span class="line">	int rn; # 行数</span><br><span class="line">	int cn; # 列数</span><br><span class="line">	int tn; # 非0元素总数</span><br><span class="line">	QLNode *rhead;</span><br><span class="line">	QLNode *chead;</span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/CF1C494E17F841DB90012A6139364334?method=download&shareKey=42bca25aac0ad5118ff7ee86eefe94ea" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（四）：图</title>
    <url>/2020/08/15/Data4/</url>
    <content><![CDATA[<h1 id="1-图的存储及基本操作"><a href="#1-图的存储及基本操作" class="headerlink" title="1 图的存储及基本操作"></a>1 图的存储及基本操作</h1><h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><p>用一维数组存储图中顶点信息，用矩阵表示图中各顶点之间的邻接关系</p>
<p>假设图$G=(V,E)$有$n$个确定的顶点，即$V=\lbrace v_0,v_1,\dots,v_{n-1}\rbrace$,$A[n][n]$存储顶点之间关系的信息</p>
<p>以顶点在vexs数组中的下标代表顶点</p>
<a id="more"></a>

<p>（1）无向图的邻接矩阵一定是一个对称矩阵，只需存放上（或下）三角矩阵的元素即可</p>
<p>（2）对于无向图，邻接矩阵第i行（或第i列）非零元素（或非$\infty$元素）的个数正好是第i个顶点的度$TD(v_i)$</p>
<p>（3）对于有向图，邻接矩阵第i行（或第i列）非零元素（或非$\infty$元素）的个数正好是第i个顶点的出度$OD(v_i)$（或入度$ID(v_i)$）</p>
<p>（4）邻接矩阵要确定图中有多少条边，则必须按行、列对每个元素进行检测，时间代价大，是邻接矩阵存储图的局限性</p>
<h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p>邻接表示图的一种顺序存储与链式存储结合的存储方式。对图G中的每个顶点$v_i$，将所有邻接与$v_i$的顶点$v_j$链成一个单链表，这个单恋表就称为顶点$v_i$的邻接表，再将所有点的邻接表表头放到数组中，构成了图的邻接表。</p>
<p>（1）若无向图中有n个顶点，e条边，则它的邻接表需n个头结点和2e个表结点</p>
<p>（2）在无向图的邻接表中，顶点$v_i$的度恰为第i个链表中的结点数</p>
<p>（3）在有向图中，第i个链表中的结点个数是顶点$v_i$的入度</p>
<p>（4）在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个顶点$v_i,v_j$之间是否有边，则需要搜索第i个或第J个链表，不及邻接矩阵方便</p>
<h1 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h1><h2 id="2-1-深度优先搜索"><a href="#2-1-深度优先搜索" class="headerlink" title="2.1 深度优先搜索"></a>2.1 深度优先搜索</h2><p>DFS类似于树的先根遍历，是树的先根遍历的推广。</p>
<p>其耗费的时间则取决于所采用的存储结构。当用二维数组表示邻接矩阵图的存储结构时，查找每个顶点的邻接点所需时间为$O(n^2)$，其中$n$为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为$O(e)$，其中$e$为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。</p>
<h2 id="2-2-广度优先搜索"><a href="#2-2-广度优先搜索" class="headerlink" title="2.2 广度优先搜索"></a>2.2 广度优先搜索</h2><p>BFS类似于树的按层次遍历的过程。</p>
<p>如果使用邻接表表示图，总时间代价为$O(n+e)$，如果用邻接矩阵，总的时间代价为$O(n^2)$</p>
<h1 id="3-图的应用"><a href="#3-图的应用" class="headerlink" title="3 图的应用"></a>3 图的应用</h1><h2 id="3-1-最小生成树"><a href="#3-1-最小生成树" class="headerlink" title="3.1 最小生成树"></a>3.1 最小生成树</h2><p>（1）Prim算法</p>
<p>假设$G=(V,E)$为一网图，其中$V$为网图中所有顶点的集合，$E$为网图中所有带权边的集合。设置两个新的结合$U$和$T$，集合$U$用于存放$G$的最小生成树的顶点，集合$T$存放$G$的最小生成树的边。令集合$U$的初值为$u=\lbrace u_1 \rbrace$</p>
<ol>
<li>从所有$u\in U , v\in V-U$的边中，选取具有最小权值的边$(u,v)$</li>
<li>将顶点$v$加入集合$U$中，将边$(u,v)$加入集合$T$中，不断重复</li>
<li>直到$U=V$时，最小生成树构造完毕</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/B0434A610F8B457C8FE7C374B1E9C6B2?method=download&shareKey=9d6342c361f13787d7d0bdb6cc2d561f" alt></p>
<p>Prim算法的时间复杂度为$O(n^2)$，与网中的边数无关，适用于求边稠密的网的最小生成树</p>
<p>（2）Kruskal算法</p>
<p>按照网中的权值递增顺序构造最小生成树的方法，需对$e$条边按权值进行排序，时间复杂度为$O(eloge)$（$e$为网中边的数目），因此适用于求边稀疏的网的最小生成树</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/90EF181691074DBCB7EF3CE9D25FD795?method=download&shareKey=e18b362fdc112a35adf5f8e7a9cc78fe" alt></p>
<h2 id="3-2-最短路径"><a href="#3-2-最短路径" class="headerlink" title="3.2 最短路径"></a>3.2 最短路径</h2><p>（1）单源点最短路径</p>
<p>前提：非负权值的图</p>
<p>设给定源点为$V_s$，$S$为已求得最短路径的终点集，开始时令$S=\lbrace V_s \rbrace$，当求得第一条最短路径$(V_s,V_i)$后，S为$\lbrace V_s,V_i \rbrace$</p>
<ol>
<li>令$S=\lbrace V_s \rbrace$，用带权的邻接矩阵表示有向图，对图中每个顶点$V_i$按以下原则设置初值</li>
</ol>
<p>$$<br>dist[i]=<br>\begin{cases}<br>0 &amp; i=s\\<br>W_{si} &amp;i \ne s 且&lt;V_s,V_i&gt; \in E，W_{si}为弧上的权值\\<br>\infty &amp; i\ne s且&lt;V_s,V_i&gt;不属于E<br>\end{cases}<br>$$</p>
<ol start="2">
<li>选择一个顶点$V_j$，使得：<br>$$dist[j]=Min{dist[k]|V_k\in V-S}$$</li>
</ol>
<p>$V_j$就是求得下一条最短路径重点，将$V_j$并入到$S$中，即$S=S\cup \lbrace V_j \rbrace$</p>
<ol start="3">
<li>对$V-S$中的每个顶点$V_k$，修改$dist[k]$，方法是：</li>
</ol>
<p>若$dist[j]+W_{jk}&lt;dist[k]$，则修改为：$dist[k]=dist[j]+W_{jk} (\forall V_k \in V-S)$</p>
<ol start="4">
<li>重复2，3，知道S=V为止</li>
</ol>
<p>时间复杂度$O(n^2)$</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/CA666348EB3F47E38C99A46E2797F5EE?method=download&shareKey=8be271a12c0ec4ed3d00b3aeea6907ae" alt></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/0EC47118409644B89304F162CC011C3A?method=download&shareKey=277330d42d8968178b86457f8c17f636" alt></p>
<p>（3）每一对顶点之间的最短路径</p>
<p>设顶点集$S$（初值为空），用数组$A$的每个元素$A[i][j]$保存$V_i$值经过$S$中的顶点到达$V_j$的最短路径长度，其思想是：</p>
<ol>
<li>设初始时令$S=\lbrace  \rbrace$,$A[i][j]$的赋初值方式是：</li>
</ol>
<p>$$<br>A[i][j]=<br>\begin{cases}<br>0 &amp; i=j\\<br>W_{ii} &amp;i \ne j 且&lt;V_i,V_j&gt; \in E，W_{ij}为弧上的权值\\<br>\infty &amp; i\ne j且&lt;V_i,V_i&gt;不属于E<br>\end{cases}<br>$$</p>
<ol start="2">
<li>将图中一个顶点$V_k$加入到$S$中，修改$A[i][j]$的值，修改方式：</li>
</ol>
<p>$$A[i][j]=Min\lbrace A[i][j],(A[i][k]+A[k][j]) \rbrace$$</p>
<ol start="3">
<li>重复2，直到$G$的所有顶点都 加入到$S$中为止</li>
</ol>
<p>时间复杂度为$O(n^3)$</p>
<p><img src="http://note.youdao.com/noteshare?id=d714a4e0dcbe51a82c7c2fe3047db2db&sub=4977D64EAF3A46D3AF7730228E2A555A" alt></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/6A15DA39F38946F4907806B14FA49471?method=download&shareKey=b17f11c2ac0784dfec9a9c9d44183577" alt></p>
<h2 id="3-3-拓扑排序"><a href="#3-3-拓扑排序" class="headerlink" title="3.3 拓扑排序"></a>3.3 拓扑排序</h2><p>有向无环图</p>
<p>主要用于研究工程项目的工序问题</p>
<ol>
<li>从AVO网中选择一个没有前驱的顶点（入度为0），并且输出它</li>
<li>从网中删除该顶点，并且删除从该顶点发出的全部有向边</li>
<li>重复上述步骤，知道剩余网中不再存在没有前驱的顶点为止</li>
</ol>
<h2 id="3-4-关键路径"><a href="#3-4-关键路径" class="headerlink" title="3.4 关键路径"></a>3.4 关键路径</h2><ol>
<li>利用拓扑排序求出AOE网的一个拓扑序列</li>
<li>从拓扑排序的序列的第一个顶点开始，按拓扑顺序依次计算每个时间的最早发生时间（选择最大的）</li>
<li>从拓扑排序的序列的最后一个顶点开始，按拟拓扑顺序依次计算每个时间的最晚发生时间（选择最小的）</li>
</ol>
<p>最早发生时间等于最晚发生时间的事件为关键事件</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/DDBFB4920153461085F4183EC16B2B8C?method=download&shareKey=eaf12c4b3ff1ea75085c551154dcedc2" alt></p>
<p>其拓扑排序序列为$&lt;V_0,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8&gt;$</p>
<p>计算各事件的$ve(i),vl(i)$值</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/AC8580E97E5E4B5E90D6F48EE738DFF4?method=download&shareKey=27d90648fa2b48f6c99e1ed8a4f4638d" alt></p>
<p>其次计算$e,l$</p>
<p>$e$为对应第一个顶点的$ve(i)$</p>
<p>$l$为对应第二个顶点$vl(i)-ve(i)$</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/83E7282B9C5048C48BBF903E663EDFE2?method=download&shareKey=67ceb99e4d35e5bdf5a4670216a959c2" alt></p>
<p>$e,l$相等的事件为关键事件，其构成的路径为关键路径</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（八）数据预处理与特征工程</title>
    <url>/2020/08/09/Feat/</url>
    <content><![CDATA[<h2 id="数据预处理和特征工程"><a href="#数据预处理和特征工程" class="headerlink" title="数据预处理和特征工程"></a>数据预处理和特征工程</h2><h3 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1 数据预处理"></a>1 数据预处理</h3><h4 id="1-1-数据无量纲化"><a href="#1-1-数据无量纲化" class="headerlink" title="1.1 数据无量纲化"></a>1.1 数据无量纲化</h4><ul>
<li>preprocessing.MinMaxScaler：归一化</li>
</ul>
<p>$$x^{*} = \frac{x-min(x)}{max(x)-min(x)}$$</p>
<ul>
<li>preprocessing.StandardScaler：标准化</li>
</ul>
<p>$$x^{*}=\frac{x-\mu}{\sigma}$$</p>
<ul>
<li>StandardScaler和MinMaxScaler选哪个</li>
</ul>
<p>大多数机器选择算法会选择StandardScaler进行放缩，因为MinMaxScaler对异常值非常敏感</p>
<a id="more"></a>

<h4 id="1-2-缺失值"><a href="#1-2-缺失值" class="headerlink" title="1.2 缺失值"></a>1.2 缺失值</h4><ul>
<li>填充固定值</li>
<li>填充均值</li>
<li>填充中位数</li>
<li>填充众数</li>
<li>填充上下跳的数据</li>
<li>填充插值得到的数据</li>
<li>填充KNN数据</li>
<li>填充模型预测的值</li>
</ul>
<h4 id="1-3-处理分类型特征：编码与哑变量"><a href="#1-3-处理分类型特征：编码与哑变量" class="headerlink" title="1.3 处理分类型特征：编码与哑变量"></a>1.3 处理分类型特征：编码与哑变量</h4><ul>
<li><p>preprocessing.LabelEncoder：标签专用，能够将分类转换为分类数值</p>
</li>
<li><p>preprocessing.OrdinalEncoder：特征专用，能够将分类特征转化为分类数值</p>
</li>
<li><p>preprocessing.OneHotEncoder:独热编码，创建哑变量</p>
</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/671DF765B3D84C68A1C2E1038494B94C?method=download&shareKey=5c723470f1cc5eaed7f35061d1aac324" alt></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/DAC20B5C378C4A4485B373870AAF5971?method=download&shareKey=8ba1b6bb9905782ae7951e742ae79fd0" alt></p>
<p>但是在独热编码后，增加了特征的维数。如果类别有很多种的话可能特征矩阵非常稀疏</p>
<h4 id="1-4-处理连续特征：二值化与分段"><a href="#1-4-处理连续特征：二值化与分段" class="headerlink" title="1.4 处理连续特征：二值化与分段"></a>1.4 处理连续特征：二值化与分段</h4><ul>
<li>sklearn.preprocessing.Binarizer</li>
</ul>
<p>根据阈值将数据二值化，用于处理连续型变量。大于阈值的值映射为1，而小于或等于阈值的值射为0。二值化常用于文本计数数据</p>
<ul>
<li>preprocessing.KBinsDiscretizer</li>
</ul>
<p>将连续型变量划分为分类变量的类，能够将连续型变量排序后按顺序分分箱后编码</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义&amp;输入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n_bins</td>
<td align="left">每个特征中分箱的个数，默认5，一次会被运用到所有导入的特征</td>
</tr>
<tr>
<td align="left">encode</td>
<td align="left">编码的方 式，默 认 “onehot”：做哑变量，之后返回一个稀疏矩阵，每一列是一个特征中的一个类别，含有该类别的样本表示为 1， 不含的表示为0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">“ordinal”：每个特征的每个箱都被编码为一个整数，返回每一列是一个特征，每个特征下含有不同整数编码的箱的矩阵</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">“onehot-dense”：做哑变量，之后返回一个密集数组。</td>
</tr>
<tr>
<td align="left">strategy</td>
<td align="left">用来定义箱宽的方式，默认”quantile”</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">“uniform”：表示等宽分箱，即每个特征中的每个箱的最大值之间的差为（$特征.max()-特征.min()/n_bins$）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">“quantile”：表示等位分箱，即每个特征中的每个箱内的样本数量都相同</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">“kmeans”：表示按聚类分箱，每个箱中的值到最近的一维k均值聚类的簇心得距离都相同</td>
</tr>
</tbody></table>
<h3 id="2-特征选择"><a href="#2-特征选择" class="headerlink" title="2 特征选择"></a>2 特征选择</h3><p>我们有四种方法可以用来选择特征：过滤法、嵌入法、包装法、降维算法</p>
<h4 id="2-1-Filter过滤法"><a href="#2-1-Filter过滤法" class="headerlink" title="2.1 Filter过滤法"></a>2.1 Filter过滤法</h4><p>它是根据各种统计检验中的分数以及相关性的各向指标来选择特征</p>
<h5 id="2-1-1-方差过滤"><a href="#2-1-1-方差过滤" class="headerlink" title="2.1.1 方差过滤"></a>2.1.1 方差过滤</h5><ul>
<li>VarianceThreshold</li>
</ul>
<p>通过特征本身的方差来筛选特征的类。如果一个特征本身的方差很小，就表示这个特征基本没有差异，那这个特征对于样本区分没有什么作用。</p>
<h5 id="2-1-2-相关性过滤"><a href="#2-1-2-相关性过滤" class="headerlink" title="2.1.2 相关性过滤"></a>2.1.2 相关性过滤</h5><p>我们希望选出与标签相关且有意义的特征，这样的特征能够为我们提供大量的信息。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/6A85336AB79345C18D14A5F3F3D1B4B9?method=download&shareKey=a1bc337ffcb61ce727aa8d9300b45809" alt></p>
<ul>
<li>卡方过滤</li>
</ul>
<p>卡方过滤是专门针对离散型标签的相关性过滤，通过卡方检验类feature_selection.chi2结合feature_selection.SelectKBest来选出前K个分数最高的特征类</p>
<ul>
<li>F检验</li>
</ul>
<p>用来捕捉每个特征与标签之间的线性关系的过滤方法，即可以做回归也可以做分类。</p>
<ul>
<li>互信息法</li>
</ul>
<p>互信息法是用来捕捉每个特征与标签之间的任意关系（包括线性和非线性）的过滤方法，也可以做回归和分类。</p>
<h4 id="2-2-Embedded嵌入法"><a href="#2-2-Embedded嵌入法" class="headerlink" title="2.2 Embedded嵌入法"></a>2.2 Embedded嵌入法</h4><p>嵌入法是一种让算法自己决定使用哪些特征的方法，即特征选择和算法训练同时进行。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/B20CE443F91E421FA086F0D7B773F940?method=download&shareKey=329d8ddf018f6e52198b696aafc99c1a" alt></p>
<ul>
<li>feature_selection.SelectFromModel</li>
</ul>
<p>SelectFromModel是一个元变换器，可以与任何在拟合后具有coef_,feature_impoortances_属性或参数中可选惩罚项的评估器一起使用</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">estimator</td>
<td align="left">使用的模型评估器，只要是带feature_importances_或者coef_属性，或带有$l_1$和$l_2$惩罚项的模型都可以使用</td>
</tr>
<tr>
<td align="left">threshold</td>
<td align="left">特征重要性的阈值，重要性低于这个阈值的特征都将被删除</td>
</tr>
<tr>
<td align="left">preﬁt</td>
<td align="left">默认False，判断是否将实例化后的模型直接传递给构造函数。如果为True，则必须直接调用ﬁt和transform，不能使用ﬁt_transform，并且SelectFromModel不能与cross_val_score，GridSearchCV和克隆估计器的类似实用程序一起使用。</td>
</tr>
<tr>
<td align="left">norm_order</td>
<td align="left">k可输入非零整数，正无穷，负无穷，默认值为1在评估器的coef_属性高于一维的情况下，用于过滤低于阈值的系数的向量的范数的阶数。</td>
</tr>
<tr>
<td align="left">max_features</td>
<td align="left">在阈值设定下，要选择的最大特征数。要禁用阈值并仅根据max_features选择，请设置threshold = -np.inf</td>
</tr>
</tbody></table>
<h4 id="3-3-Wrapper包装法"><a href="#3-3-Wrapper包装法" class="headerlink" title="3.3 Wrapper包装法"></a>3.3 Wrapper包装法</h4><p>包装法也是一个特征选择和算法训练同时记性的方法，与嵌入法十分相似，但不同的是，我们往往使用一个目标函数作为黑盒来帮助我们选取特征，而不是自己输入某个评估指标或统计量的阈值。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/2210DFBFBE614558A58D1F7F7C3A207F?method=download&shareKey=a4ee875d7e0cf4e62258f04f111375e1" alt></p>
<ul>
<li>feature_selection.RFE<br>最典型的目标函数是递归特征消除法（Recursive feature elimination, RFE）</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（五）：查找</title>
    <url>/2020/08/17/Data5/</url>
    <content><![CDATA[<h1 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1 查找的基本概念"></a>1 查找的基本概念</h1><p>查找有两种基本形态：静态查找和动态查找</p>
<ul>
<li>静态查找：在查找时只对数据元素进行查询或检索，查找表称为静态查找表</li>
<li>动态查找：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录</li>
</ul>
<p>根据存储结构的不同，查找方法分为三大类：</p>
<ol>
<li>顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较，找到要查找的记录</li>
<li>散列表的查找：根据给定的K值直接访问查找表，从而找到要查找的记录</li>
<li>索引查找表的查找：首先根据索引确定待查找记录所在的块，然后再从块中找到要查找的记录</li>
</ol>
<a id="more"></a>

<p>平均查找长度</p>
<p>为确定数据元素在列表中的位置，需给定值进行比较的关键字个数的期望值</p>
<p>$$ASL = \sum_{i=1}^n p_i * C_i, \  \sum_{i=1}^n p_i = 1$$</p>
<p>$p_i$：查找第$i$个记录的概率<br>$C_i$：查找第$i$个记录需要进行比较的次数</p>
<h1 id="2-顺序查找法"><a href="#2-顺序查找法" class="headerlink" title="2. 顺序查找法"></a>2. 顺序查找法</h1><p>将查找表作为一个线性表，可以是顺序表，也可以使链表，依次进行比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_SIZE 100</span><br><span class="line">typedef struct SSTable</span><br><span class="line">&#123;</span><br><span class="line">	RecType elem[MAX_SIZE]</span><br><span class="line">	int length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line">int Seq_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	int p;</span><br><span class="line">	ST.elem[0].key&#x3D;key; # 设置监视哨兵，失败返回0</span><br><span class="line">	for(p&#x3D;ST.length; ST.elem[p].key!&#x3D;key;p--) return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设查找每个记录的概率相等，即$P_i = 1/n$，查找第$i$个元素成功的比较次数$C_i  = n-i+1$</p>
<p>查找成功时：<br>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$$</p>
<p>查找不成功时：比较次数为$n+1$，概率为$P_1 = 1/(2n)$</p>
<p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{2n}\sum_{i=1}^n(n-i+1)+\frac{n+1}{2}=\frac{3(n+1)}{4}$$</p>
<h1 id="3-分块查找法"><a href="#3-分块查找法" class="headerlink" title="3 分块查找法"></a>3 分块查找法</h1><p>分块查找的基本思想是：将表分成n块，每一块中的关键字不一定有序，但前一块中最大关键字必须小于后一块的最小关键字，即要求表示“分块有序的”。首先查找索引表，因为索引表是有序表，确定待查结点是在哪一块，然后再已确定的块中进行顺序查找</p>
<p>线性表中共有$n$个结点，分成大小相等的$b$块，每块有$s=n/b$个结点，假定对索引表也采用顺序查找，值考虑查找成功的情况，并假定对每个结点的查找概率是相等的</p>
<p>$$E_b = \sum_{i=1}^b(i* \frac{1}{b})=\frac{b+1}{2}$$</p>
<p>$$E_w = \sum_{i=1}^s(i*\frac{1}{s})=\frac{s+1}{2}$$</p>
<p>所以：</p>
<p>$$E(n)=E_b+E_w = \frac{b+1}{2}+\frac{s+1}{2}=\frac{n+s^2}{2s}+1$$</p>
<p>当$s=\sqrt{n}，E(n)取最小值$</p>
<p>$$E(n)=\sqrt{n}+1\approx \sqrt{n}$$</p>
<h1 id="4-折半查找法"><a href="#4-折半查找法" class="headerlink" title="4 折半查找法"></a>4 折半查找法</h1><p>折半查找要求查找表顺序存储结构且各数据元素按关键字有序排序，也就是说折半查找只适用于对有序顺序表进行查找</p>
<p>（1）查找思想<br>用Low、High和Mid表示待查找区间的下界、上届和中间位置指针，初值为Low=1,High=n</p>
<p>取中间位置$Mid: Mid = floor[(Low+High)/2]$</p>
<p>比较中间位置记录的关键字与给定的K值</p>
<ol>
<li>相等:查找成功</li>
<li>大于：待查找记录在区间的前半段，修改上界指针：High = Mid -1,转1</li>
<li>小于：待查记录在区间的后半段，修改下界指针：Low = Mid +1，转1</li>
</ol>
<p>直到越界(Low&gt;High)，查找失败 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Bin_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	int Low&#x3D;1, High&#x3D;ST.length, Mid;</span><br><span class="line">	while(Low&lt;&#x3D;High)</span><br><span class="line">	&#123;</span><br><span class="line">		if(ST.elem[Mid].key&#x3D;&#x3D;key) return Mid;</span><br><span class="line">		else if(ST.elem[Mid].key&lt;key) Low&#x3D;Mid+1;</span><br><span class="line">		else High&#x3D;Mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）算法分析<br>经过每一次查找，查找范围就缩小一半，该过程可用一颗二叉树表示，所得到的二叉树为判定书</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/D88D43B8E643426EAB6B2364BFF63C6F?method=download&shareKey=3fa93bd5fbe81e5e524c115bc248e942" alt></p>
<p>ASL成功 = $(1+2 * 2+4 * 3+4 * 4)/11$</p>
<p>ASL不成功 = $(4 * 3 +8 * 4)/12$</p>
<p>将二叉判定书的第$\lfloor log_2 n \rfloor+1$层上的结点补齐就称为一颗满二叉树，深度不变，$h=\lfloor log_2(n+1) \rfloor$</p>
<p>由满二叉树性质知，第$i$层上的结点数为$2i-1(i&lt;=h)$，设表中每个记录的查找概率相等，即$P_1 = \frac{1}{n}$，查找成功时的平均查找长度ASL：</p>
<p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{j=1}^h j* 2^{j-1}=\frac{n+1}{n}log_2(n+1)-1$$</p>
<p>当$n$很大$(n&gt;50)$，$ASL\approx log_2(n+1)-1$</p>
<h1 id="5-B树及其基本操作、B-树的基本概念"><a href="#5-B树及其基本操作、B-树的基本概念" class="headerlink" title="5 B树及其基本操作、B+树的基本概念"></a>5 B树及其基本操作、B+树的基本概念</h1><p>一颗度m的B树称为m阶的B树，是一颗平衡（平衡因子为0）的查找树（排序树）</p>
<h2 id="5-1-B树"><a href="#5-1-B树" class="headerlink" title="5.1 B树"></a>5.1 B树</h2><p>（1）B树的定义</p>
<p>一棵m阶的B树，或者为空树，或为满足下列特性的m叉树：</p>
<ol>
<li>分枝的数量$\lceil m/2 \rceil&lt;=n&lt;=m$</li>
<li>关键码的数量$\lceil m/2 \rceil-1&lt;=n&lt;=m-1$</li>
</ol>
<p>（2）B树的查找</p>
<p>类似二叉排序树的查找，所不同的是B树每个节点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，按照对应的指针信息指向的子树中查找，当到达叶子节点时，则说明树中没有对应的关键码，查找失败</p>
<p>（3）B树的插入</p>
<ol>
<li>在B树中查找关键字$K$，若找到，表明关键字已存在，返回，否则$K$的查找操作失败于某个叶子结点，转2</li>
<li>将$K$插入到该叶子结点中，插入时，若：<ul>
<li>叶子节点的关键字数$&lt;m-1$:直接插入；</li>
<li>叶子节点的关键字数$=m-1$：将结点“分裂”</li>
</ul>
</li>
</ol>
<p>分裂的方法：</p>
<p>设待“分裂”结点包含信息为：<br>$(m,A_0,K_1,A_1,K_2,A_2,\dots,K_m,A_m)$，从其中间位置分为两个结点：</p>
<p>$$(\lceil m/2 \rceil -1,A_0,K_1,A_1,\dots,K_{\lceil m/2 \rceil-1},A_{\lceil m/2 \rceil-1})$$<br>$$(m-\lceil m/2 \rceil,A_{\lceil m/2 \rceil},K_{\lceil m/2 \rceil+1},A_{\lceil m/2 \rceil+1},\dots,K_{m},A_{m})$$</p>
<p>并将中间关键字$K_{\lceil m/2 \rceil}$插入到父节点中，以分裂后的两个结点作为其子结点</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/E743781A41C048FBACF19AEA3B46CDE3?method=download&shareKey=fff65bef129a9f6c2e47f8fb66bd770a" alt></p>
<p>（4）B树的删除</p>
<p>在$B$树上删除一个关键字$K$，首先找到关键字所在的结点$N$，然后再$N$中进行关键字$K$的删除操作。</p>
<p>若$N$b不是叶子结点，设$K$是$N$的第$i$个关键字，将指针$A_{i-1}$所指子树中的最大关键字（或最小关键字）$K^{‘}$放在$(k)$的位置，然后删除$K^{‘}$，而$K^{‘}$一定在叶子结点上</p>
<p>从叶子结点中删除一个关键字的情况是：<br>（兄弟可借）</p>
<ol>
<li>若结点$N$中的关键字个数$&gt;\lceil m/2 \rceil-1$，在结点直接删除关键字K</li>
<li>若结点$N$中的关键字个数$=\lceil m/2 \rceil-1$，若结点$N$的左（右）兄弟结点中的关键字个数$&gt;\lceil m/2 \rceil-1$，则将节点$N$的左（或右）兄弟结点中的最大（或最小）关键字移到其父结点中，而父结点中大于（或小于）且紧靠上移关键字的关键字下移到结点$N$</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/2C8523525D4F45C494DF2BDD9E038DD6?method=download&shareKey=bb0f372b7208953b8ef2e463e228d3ac" alt></p>
<p>（兄弟不可借——合并结点）<br>3. 若结点$N$和其兄弟结点中的关键字$=\lceil m/2 \rceil-1$：删除结点$N$中的关键字，再将结点$N$中的关键字、指针域其兄弟结点以及分割二者的父结点的某个关键字$K_i$，合并为一个结点，若因此使父结点中的关键个数$&lt;=\lceil m/2 \rceil-1$，则以此类推<br>4. 若所删关键字为非终端结点中的$k_i$，则可以指针$A_i$所指子树中最小关键字$Y$替代$K_i$，然后再相应的结点中删去$Y$</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/97818282DD604A05B09196BEAD6539F0?method=download&shareKey=c6f362679dd80a67908a2d6ca93ef7a4" alt></p>
<h2 id="5-2-B-树"><a href="#5-2-B-树" class="headerlink" title="5.2 $B+$树"></a>5.2 $B+$树</h2><p>$B+$树是文件系统所需要的一种$B$树的变形树，一棵$m$阶的$B+,B$树主要差异在于：</p>
<ol>
<li>有$n$棵子树的结点中含有$n$个关键码；</li>
<li>所有叶子结点中包含了全部关键码的信息，以及指向含有这些关键码记录的指针，且叶子结点本身依赖关键码的大小自小而大的顺序链接</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/1814D7A4B1B64A8F8C2DE97653835F25?method=download&shareKey=5296f5cd12ff30a14d50fb00a0eaa204" alt></p>
<h1 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6 哈希表"></a>6 哈希表</h1><h2 id="6-1-常用的哈希函数"><a href="#6-1-常用的哈希函数" class="headerlink" title="6.1 常用的哈希函数"></a>6.1 常用的哈希函数</h2><p>哈希函数“好坏”的主要评价因素有：散列函数的构造简单；能“均匀”地将散列表中的关键字映射到地址空间（发生冲突的可能性最少）</p>
<p>（1）直接定址法</p>
<p>$$H(key)=key, \ H(key)=a*key+b$$</p>
<p>此方法仅适用于：地址集合的大小等于关键字集合的大小</p>
<p>（2）数字分析法<br>假设关键字集合的每个关键字都是由$s$位数字组成$(k_1,k_2,\dots,k_n)$，分析关键字集中的全体，并从中提取分布均匀的若干位或他们的组合作为地址</p>
<p>（3）平方取中法</p>
<p>若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以扩大差别</p>
<p>（4）折叠法</p>
<p>若关键字的位数特别多，则可将其分割成几部分，然后取他们的叠加和为散列地址</p>
<ol>
<li>位移法：将各部分的最后一位对齐相加</li>
<li>间界叠加法：从一端向另一端沿各个部分分界来回折叠后，最后一位对齐相加</li>
</ol>
<p>适用于关键字的数字位数特别多</p>
<p>（5）除留余数法（重点）</p>
<p>$$H(key)=key\  MOD\  p\ (p&lt;=m)$$</p>
<p>选取适合的$p$很重要，一般选取质数</p>
<p>（6）随机数法</p>
<p>$$H(key)= Random(key)$$</p>
<h2 id="6-2-处理冲突的方法"><a href="#6-2-处理冲突的方法" class="headerlink" title="6.2 处理冲突的方法"></a>6.2 处理冲突的方法</h2><p>（1）开放定址法</p>
<p>一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p>
<ol>
<li>线性探测法</li>
</ol>
<p>$$H_i = (Hash(key)+d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p>
<p>这种方法的特点是：发生冲突，顺序表看表中下一单元，直接找出一个空单元或查遍全表。因此，可能出现很多元素在相邻的散列地址上“堆积”起来，大大降低了查找效率。为此，可采用二次探测法改善</p>
<ol start="2">
<li>二次探测法</li>
</ol>
<p>$$H_i = (Hash(key)\pm d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p>
<p>其中：$Hash(key)$为散列函数，$m$为散列表长度，$m$要求是某个$4k+3$的质数，$d_i$为增量序列$1^2,-1^2,2^2,-2^2,\dots,q^2,-q^2,\ q&lt;=m/2$</p>
<ol start="3">
<li>拉链法</li>
</ol>
<p>将所有散列表地址为$i$的元素构成一个同义词链的单链表，并将单链表的头指针存在散列表的第$i$个单元中</p>
<ol start="4">
<li>建立公共溢出区</li>
</ol>
<p>建立一个溢出表保存与基本表中记录冲突的所有记录</p>
<h2 id="6-3-散列表的查找"><a href="#6-3-散列表的查找" class="headerlink" title="6.3 散列表的查找"></a>6.3 散列表的查找</h2><p>查找过程与造表一致，假设采用开放定址处理冲突，则查找过程：</p>
<ol>
<li>对给定值$K$，计算散列地址$i=H(K)$</li>
<li>若$r[i]=NULL$，则查找不成功</li>
<li>若$r[i].key=k$，则查找成功</li>
<li>否则求下一地址$H_i$，直至$r[H_i]=NULL$（查找不成功），或$r[H_i].key=k$（查找成功）</li>
</ol>
<p>哈希表的填满因子<br>$$\alpha=\frac{表中填入的记录数}{哈希表长度}$$</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（三）线性回归</title>
    <url>/2020/07/22/LinearRegression/</url>
    <content><![CDATA[<h1 id="1-多元线性回归LinearRegression"><a href="#1-多元线性回归LinearRegression" class="headerlink" title="1 多元线性回归LinearRegression"></a>1 多元线性回归LinearRegression</h1><h2 id="1-1-多元线性回归的基本原理"><a href="#1-1-多元线性回归的基本原理" class="headerlink" title="1.1 多元线性回归的基本原理"></a>1.1 多元线性回归的基本原理</h2><p>对于一个$n$个特征的样本$i$而言，回归方程为：<br>$$\hat y_i = w_0 +w_1x_{i1}+w_2x_{i2}+\dots+w_nx_{in}$$</p>
<p>$w_0$被称为截距，$w_1 \sim w_n$被称为回归系数，$w_{i1} \sim x_{in}$是样本$i$上的不同特征，如果考虑我们有m个样本，则回归可以被写作：<br>$$\hat y = w_0 +w_1x_{1}+w_2x_{2}+\dots+w_nx_{n}$$</p>
<a id="more"></a>

<p>其中$y$是包含了m个全部样本回归的列向量，$w$可以被看作是结构为$(n+1,1)$的列矩阵，$X$是一个结构为$(m,n+1)$的特征矩阵，则有：</p>
<p>$$\begin{bmatrix}<br>\hat y_1 \\<br>\hat y_2\\<br>\hat y_3\\<br>\dots\\<br>\hat y_m\\<br>\end{bmatrix}=\begin{bmatrix}<br>1&amp; x_{11} &amp; x_{12} &amp; x_{13} &amp; \dots &amp; x_{1n} \\<br>1&amp; x_{21} &amp; x_{22} &amp; x_{23} &amp; \dots &amp; x_{2n}\\<br>1&amp; x_{31} &amp; x_{32} &amp; x_{33} &amp; \dots &amp; x_{3n}\\<br>\dots\\<br>1&amp; x_{m1} &amp; x_{m2} &amp; x_{m3} &amp; \dots &amp; x_{mn}\\<br>\end{bmatrix} * \begin{bmatrix}<br>w_0 \\<br>w_1 \\<br>w_2 \\<br>\dots\\<br>w_n \\<br>\end{bmatrix}$$</p>
<p>$$\hat y = Xw$$</p>
<p>在多元线性回归中，定义损失函数如下：</p>
<p>$$\sum_{i=1}^m(y_i-\hat y_i)^2=\sum_{i=1}^m(y_i-X_iw)^2$$</p>
<p>其中$y_i$是样本$i$对应的真实标签，$\hat y_i$，也就是$X_iw$样本$i$在一组参数$w$下的预测标签。</p>
<p>因此，最小化损失，将求解目标转化为：<br>$$\min_w||y-Xw||^2_2$$</p>
<p>我们称这个式子为SEE(Sum of Sqaured Error, 误差平方和)或者RSS(Residual Sum of Squares 残差平方和)</p>
<h2 id="1-2-最小二乘法求解多元线性回归的参数"><a href="#1-2-最小二乘法求解多元线性回归的参数" class="headerlink" title="1.2 最小二乘法求解多元线性回归的参数"></a>1.2 最小二乘法求解多元线性回归的参数</h2><p>首先，我们对$w$求导：<br>$$<br>\begin{equation}\begin{split}<br>\frac{\partial RSS}{\partial w}&amp;=\frac{\partial ||y-Xw||^2_2}{\partial w} \\<br>&amp; =\frac{\partial (y-Xw)^T(y-Xw)}{\partial w}<br>\end{split}\end{equation}<br>$$<br>$$\because (A-B)^T = A^T-B^T 并且(AB)^T=B^T*A^T$$<br>$$\therefore =\frac{\partial (y^T-w^TX^T)(y-Xw)}{\partial w}$$<br>$$=\frac{\partial(y^Ty-w^TX^Ty-y^TXw+w^TX^TXw)}{\partial w}$$</p>
<p>$\because$ 矩阵求导中，$a$为常数，有如下规则：<br>$$\frac{\partial a}{\partial A}=0,\frac{\partial A^TB^TC}{\partial A}=B^TC,\frac{\partial C^TBA}{\partial A}=B^TC,\frac{\partial A^TBA}{\partial A}=(B+B^T)A$$</p>
<p>$$=0-X^Ty-X^Ty+2X^TXw$$<br>$$=X^TXw-X^Ty$$</p>
<p>然后让一阶导数为0：<br>$$X^TXw-X^Ty=0$$<br>$$X^TXw=X^Ty$$<br>左乘一个$(X^TX)^{-1}$则有：<br>$$w=(X^TX)^{-1}X^Ty$$</p>
<p>在这里，逆矩阵的充分必要条件是特征矩阵不存在多重共线性。并且在统计学中，使用最小二乘法求解线性回归方程式一种“无偏估计”的方法，也就是标签的分布必须服从正太分布。</p>
<h2 id="1-3-linear-model-LinearRegression"><a href="#1-3-linear-model-LinearRegression" class="headerlink" title="1.3 linear_model.LinearRegression"></a>1.3 linear_model.LinearRegression</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sklearn.linear_model.LinearRegression (ﬁt_intercept&#x3D;True, normalize&#x3D;False, copy_X&#x3D;True, n_jobs&#x3D;None)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ﬁt_intercept</td>
<td align="left">布尔值，可不填，默认为True是否计算此模型的截距。如果设置为False，则不会计算截距</td>
</tr>
<tr>
<td align="left">normalize</td>
<td align="left">布尔值，可不填，默认为False当ﬁt_intercept设置为False时，将忽略此参数。如果为True，则特征矩阵X在进入回归之前将会被减去均值（中心化）并除以L2范式（缩放）。如果你希望进行标准化，请在ﬁt数据之前   使用preprocessing模块中的标准化专用类StandardScaler</td>
</tr>
<tr>
<td align="left">copy_X</td>
<td align="left">布尔值，可不填，默认为True如果为真，将在X.copy()上进行操作，否则的话原本的特征矩阵X可能被线性回归影响并覆盖</td>
</tr>
<tr>
<td align="left">n_jobs</td>
<td align="left">整数或者None，可不填，默认为None用于计算的作业数。只在多标签的回归和数据量足够大的时候才生效。除非None在joblib.parallel_backend上下文中，否则None统一表示为1。如果输入 -1，则表示使用全部的CPU来进行计算。</td>
</tr>
</tbody></table>
<h1 id="2-多重共线性：岭回归与Lasso"><a href="#2-多重共线性：岭回归与Lasso" class="headerlink" title="2 多重共线性：岭回归与Lasso"></a>2 多重共线性：岭回归与Lasso</h1><h2 id="2-1-多重共线性"><a href="#2-1-多重共线性" class="headerlink" title="2.1 多重共线性"></a>2.1 多重共线性</h2><p><img src="https://note.youdao.com/yws/api/personal/file/A616BDB61AA6498B98A1A83048F5B23F?method=download&shareKey=8d479565cbc667165d0e688acf357ea0" alt></p>
<ul>
<li>多重共线性与相关性</li>
</ul>
<p>多重共线性如果存在，则线性回归就无法使用最小二乘法求解，但是不代表不能存在相关性——机器学习不要求特征之间必须独立，只要不是高度相关就好。</p>
<h2 id="2-2-岭回归"><a href="#2-2-岭回归" class="headerlink" title="2.2 岭回归"></a>2.2 岭回归</h2><h3 id="2-2-1-岭回归解决多重共线性问题"><a href="#2-2-1-岭回归解决多重共线性问题" class="headerlink" title="2.2.1 岭回归解决多重共线性问题"></a>2.2.1 岭回归解决多重共线性问题</h3><p>岭回归在多元线性回归的损失函数上加了正则项，表达为系数$w$的$L_2$范式乘以正则化系数$\alpha$，岭回归的损失函数的完整表达式写作：<br>$$\min_w||Xw-y||^2_2+\alpha||w||_2^2$$</p>
<p>现在对$w$进行求导：<br>$$\frac{\partial(RSS+\alpha||w||^2_2)}{\partial w}=\frac{\partial(||y-Xw||^2_2+\alpha||w||^2_2)}{\partial w}$$<br>$$=\frac{\partial(y-Xw)^T(y-Xw)}{\partial w}+\frac{\partial \alpha||w||^2_2}{\partial w}$$<br>$$=0-2X^Ty+2X^TXw+2\alpha$$<br>将含有$w$的项合并，其中$\alpha$为常数<br>为了实现矩阵相加，乘以一个结构为$n*n$的单位矩阵$I$:<br>$$=(X^TX+\alpha I)w-X^Ty$$<br>$$(X^TX+\alpha I)w=X^Ty$$</p>
<p>现在，只要$(X^TX+\alpha I)$存在逆矩阵，就可以解出$w$。一个矩阵存在逆举证的充分必要条件是这个矩阵的行列式不为0.</p>
<p>假设原本的特征矩阵$X^TX$不满秩：</p>
<p>$$X^TX=\begin{vmatrix}<br>\alpha_{11} &amp; \alpha_{12} &amp;\alpha_{13}&amp;\dots &amp;\alpha_{1n} \\<br>0 &amp; \alpha_{22} &amp;\alpha_{23}&amp;\dots &amp;\alpha_{2n} \\<br>0 &amp; 0 &amp;\alpha_{33}&amp;\dots &amp;\alpha_{3n} \\<br>&amp; &amp; \dots &amp;\\<br>0 &amp; 0 &amp;0&amp;\dots &amp;0 \\<br>\end{vmatrix}$$</p>
<p>然而，加上了$\alpha I$后：</p>
<p>$$X^TX+\alpha I=\begin{vmatrix}<br>\alpha_{11}+\alpha &amp; \alpha_{12} &amp;\alpha_{13}&amp;\dots &amp;\alpha_{1n} \\<br>0 &amp; \alpha_{22} &amp;\alpha_{23}+\alpha&amp;\dots &amp;\alpha_{2n} \\<br>0 &amp; 0 &amp;\alpha_{33}&amp;\dots &amp;\alpha_{3n}+\alpha \\<br>&amp; &amp; \dots &amp;\\<br>0 &amp; 0 &amp;0&amp;\dots &amp;\alpha \\<br>\end{vmatrix}$$</p>
<p>现在，这个行列式不存在全0行或者全0列了，除非：</p>
<ol>
<li>$\alpha=0$</li>
<li>原本矩阵$X^TX$存在对角线上元素为$-\alpha$，其他元素都为0的行或者列</li>
</ol>
<p>因此，$w$就可以写作：<br>$$w=(X^TX+\alpha I)^{-1}X^Ty$$</p>
<h3 id="2-2-2-linear-model-Ridge"><a href="#2-2-2-linear-model-Ridge" class="headerlink" title="2.2.2 linear_model.Ridge"></a>2.2.2 linear_model.Ridge</h3><p>在sklearn中，岭回归由线性模型库中的Ridge类来调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sklearn.linear_model.Ridge (alpha&#x3D;1.0, ﬁt_intercept&#x3D;True, normalize&#x3D;False, copy_X&#x3D;True, max_iter&#x3D;None, tol&#x3D;0.001, solver&#x3D;’auto’, random_state&#x3D;None)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Lasso"><a href="#2-3-Lasso" class="headerlink" title="2.3 Lasso"></a>2.3 Lasso</h2><h3 id="2-3-1-Lasso与多重共线性"><a href="#2-3-1-Lasso与多重共线性" class="headerlink" title="2.3.1 Lasso与多重共线性"></a>2.3.1 Lasso与多重共线性</h3><p>Lasso使用的是系数$w$的$L_1$范式乘以正则化系数$\alpha$，因此Lasso的损失函数表达式为：<br>$$\min_w||Xw-y||^2_2+\alpha||w||_1$$</p>
<p>对损失函数进行求导：</p>
<p>$$\frac{\partial(RSS+||w||_1)}{\partial w}=\frac{\partial(||y-Xw||^2_2)+\alpha||w||_1}{\partial w}$$<br>$$=\frac{\partial(y-Xw)^T(y-Xw)}{\partial w}+\frac{\partial \alpha||w||_1}{\partial w}$$<br>$$=0-2X^Ty+2X^TXw+\alpha$$<br>将含有$w$的项合并，其中$\alpha$为常数</p>
<p>为实现矩阵相加，乘以一个结构为$n*n$的单位矩阵$I:$<br>$$=X^TXw-X^Ty+\frac{\alpha I}{2}$$<br>$$X^TXw=X^Ty-\frac{\alpha I}{2}$$</p>
<p>而$L_1$范式所带的正则项$\alpha$在求导之后并不带有$w$这个项，因此<strong>Lasso无法解决特征之间“精确相关”的问题</strong></p>
<p>假设方阵$X^TX$的逆是一定存在的，那我们可以有：<br>$$w=(X^TX)^{-1}(X^Ty-\frac{\alpha I}{2})$$</p>
<p>通过增大$\alpha$，可以为$w$的计算增肌按一个负项，从而限制参数估计中$w$的大小，而防止多重共线性引起的失准问题。因此<strong>Lasso不是从根本上解决多重共线性问题，而是限制多重共线性带来的影响</strong></p>
<p>$L_1,L_2$正则化一个核心差异就是他们对系数$w$的影响：两个正则化都会压缩系数$w$的大小，对标签贡献更少的特征系数会更小，也会更容易被压缩，不过$L_2$正则化只会将系数压缩到尽可能接近0，但$L_1$正则化主导稀疏性，会将系数压缩到0，这个性质让Lasso称为了线性模型中的特征选择工具首选。</p>
<h3 id="2-3-2-Lasso的核心作用：特征选择"><a href="#2-3-2-Lasso的核心作用：特征选择" class="headerlink" title="2.3.2 Lasso的核心作用：特征选择"></a>2.3.2 Lasso的核心作用：特征选择</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sklearn.linear_model.Lasso (alpha&#x3D;1.0, ﬁt_intercept&#x3D;True, normalize&#x3D;False, precompute&#x3D;False, copy_X&#x3D;True, max_iter&#x3D;1000, tol&#x3D;0.0001, warm_start&#x3D;False, positive&#x3D;False, random_state&#x3D;None, selection&#x3D;’cyclic’)</span><br></pre></td></tr></table></figure>


<h1 id="3-非线性问题：多项式回归"><a href="#3-非线性问题：多项式回归" class="headerlink" title="3 非线性问题：多项式回归"></a>3 非线性问题：多项式回归</h1><h2 id="3-1-“线性”概念"><a href="#3-1-“线性”概念" class="headerlink" title="3.1 “线性”概念"></a>3.1 “线性”概念</h2><h3 id="3-1-1-变量之间的线性关系"><a href="#3-1-1-变量之间的线性关系" class="headerlink" title="3.1.1 变量之间的线性关系"></a>3.1.1 变量之间的线性关系</h3><p>两个变量之间的关系可以展示为一条直线</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/97AE26C1073A4E8F862543C4AD9A3223?method=download&shareKey=e4b169f42f176d2c0e21bfa46b06d126" alt></p>
<h3 id="3-1-2-数据的线性与非线性"><a href="#3-1-2-数据的线性与非线性" class="headerlink" title="3.1.2 数据的线性与非线性"></a>3.1.2 数据的线性与非线性</h3><p>一组数据由多个特征和标签组成。当这些特征分别与标签存在线性关系的时候，我们就说这一组数据是线性数据。当需要用三角函数，指数函数等来定义，则说这种数据叫作“非线性数据”</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/D4B139AFD9FA4DF19C2C2E9CA44526FC?method=download&shareKey=f750e469a64f7fe5ed9af4c120d7772c" alt></p>
<h3 id="3-1-3-线性模型和非线性模型"><a href="#3-1-3-线性模型和非线性模型" class="headerlink" title="3.1.3 线性模型和非线性模型"></a>3.1.3 线性模型和非线性模型</h3><p>线性回归方程中，其自变量都是一次项，线性模型可以用来拟合非线性数据，而非线性模型也可以用来拟合线性数据，有的模型既可以使线性也可以使非线性模型。</p>
<ul>
<li>非线性模型拟合线性数据</li>
</ul>
<p>非线性模型几乎都可以在线性可分数据上有不逊于线性模型的表现<br><img src="https://note.youdao.com/yws/api/personal/file/1D70B4CDFF03423E97ABC37F0C1B8733?method=download&shareKey=f3b9556697932b23dedc04c06ae3a3cd" alt></p>
<ul>
<li>线性模型拟合非线性数据</li>
</ul>
<p>但是相反的，线性模型用来拟合非线性数据，通常表现糟糕。改善线性模型在非线性数据上的效果的方法之一是进行分箱，甚至可以搞过一些非线性模型。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/A2F08F0D7A8D4761B16B779877453614?method=download&shareKey=36e49e3e63725e9534077264653e4574" alt></p>
<ul>
<li>即是线性，也是非线性的模型</li>
</ul>
<p>有一些模型，即可以处理线性数据又可以处理非线性数据，比如支持向量机。这个模型的线性和非线性取决于它的核函数。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/19A7E95570314268BD269B76FF89ED2E?method=download&shareKey=5c1d7a4c6fd76e78ffad5e1fb8a91204" alt></p>
<h2 id="3-2-使用分箱处理非线性问题"><a href="#3-2-使用分箱处理非线性问题" class="headerlink" title="3.2 使用分箱处理非线性问题"></a>3.2 使用分箱处理非线性问题</h2><p>让线性回归在非线性数据上表现提升的核心方法之一是对数据进行分箱，也就是离散化。</p>
<p>在工业中，大量离散化变量与线性模型连用的实例很多，在深度学习出现之前，这种模式甚至一度统治一些工业中的机器学习应用场景，可见效果优秀，应用广泛。对于现在的很多工业场景而言，大量离散化特征的情况可能已经不是那么多了，不过大家依然需要对“分箱能够解决线性模型无法处理非线性数据的问题”有所了解。</p>
<h2 id="3-3-多项式回归PolynomialFeatures"><a href="#3-3-多项式回归PolynomialFeatures" class="headerlink" title="3.3 多项式回归PolynomialFeatures"></a>3.3 多项式回归PolynomialFeatures</h2><h3 id="3-3-1-多项式对数据做了什么"><a href="#3-3-1-多项式对数据做了什么" class="headerlink" title="3.3.1 多项式对数据做了什么"></a>3.3.1 多项式对数据做了什么</h3><p>除了分箱之外，另一种更普遍的用于解决”线性回归只能处理线性数据“问题的手段，就是使用多项式回归对线性回归进行改进。这样的手法是机器学习研究者们从支持向量机中获得的：支持向量机通过升维可以将非线性可分数据转化为线性可分，然后使用核函数在低维空间中进行计算，这是一种“高维呈现，低维解释”的思维。那我们为什么不能让线性回归使用类似于升维的转换，将数据由非线性转换为线性，从而为线性回归赋予处理非线性数据的能力呢？当然可以。<br><img src="https://note.youdao.com/yws/api/personal/file/176FBDF502BB4D36ADAB608843183733?method=download&shareKey=0326e48215aac4f9a94d6ef3365e2d11" alt></p>
<p>接下来，我们就来看看线性模型中的升维工具：多项式变化。这是一种通过增加自变量上的次数，而将数据映射到高维空间的方法，只要我们设定一个自变量上的次数（大于1），就可以相应地获得数据投影在高次方的空间中的结果。这种方法可以非常容易地通过sklearn中的类PolynomialFeatures来实现。我们先来简单看看这个类是如何使用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sklearn.preprocessing.PolyinomialFeatures(degree&#x3D;2, interaction_only&#x3D;False,include_bias&#x3D;True)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-多项式回归的可解释性"><a href="#3-3-2-多项式回归的可解释性" class="headerlink" title="3.3.2 多项式回归的可解释性"></a>3.3.2 多项式回归的可解释性</h3><p>多项式回归的可解释性还存在，并且我们可以通过这样的手段做特征工程——特征创造。多项式帮助我们进行了一些列特征之间相乘的结合，若讷讷够找出组合起来后对标签贡献巨大的特征，那我们就是创造了新的有效特征，对任何学科而言发现新特征都是非常有价值的。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结（六）：排序</title>
    <url>/2020/08/18/Data6/</url>
    <content><![CDATA[<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>逐个向有序表中进行插入操作</p>
<p>初始关键字序列：  [7]    4    -2    19    13    6    ；<br>第一趟排序后：    [4    7]    -2    19    13    6    ；<br>第二趟排序后：    [-2    4    7]    19    13    6    ；<br>第三趟排序后：    [-2    4    7    19]    13    6    ；<br>第四趟排序后：    [-2    4    7    13    19]    6    ；<br>第五趟排序后：    [-2    4    6    7    13    19]    ；</p>
<a id="more"></a>

<p><img src="https://note.youdao.com/yws/api/personal/file/FF99682334F14D6C8BDC28A7D301BB17?method=download&shareKey=18c14c8e31ea2e76032d125fea69224f" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insertionSort(arr): </span><br><span class="line">  </span><br><span class="line">    for i in range(1, len(arr)): </span><br><span class="line">  </span><br><span class="line">        key &#x3D; arr[i] </span><br><span class="line">  </span><br><span class="line">        j &#x3D; i-1</span><br><span class="line">        while j &gt;&#x3D;0 and key &lt; arr[j] : </span><br><span class="line">                arr[j+1] &#x3D; arr[j] </span><br><span class="line">                j -&#x3D; 1</span><br><span class="line">        arr[j+1] &#x3D; key </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6] </span><br><span class="line">insertionSort(arr) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(len(arr)): </span><br><span class="line">    print (&quot;%d&quot; %arr[i])</span><br></pre></td></tr></table></figure>



<p>性能分析：</p>
<p>（1）空间效率：仅用了一个辅助单元，空间复杂度为$O(1)$</p>
<p>（2）时间效率：向有序表逐个插入记录操作，进行了$n-1$趟，每趟操作分为比较关键码和移动记录，直接插入最好情况为$O(n)$，平均时间复杂度$O(n^2)$</p>
<p>（3）稳定性：稳定</p>
<h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>折半插入排序是利用折半查找实现在有序表$R[1,i-1]$中查找$R[i]$的插入位置</p>
<p>对下列序列进行排序：{30，13，70，85，39，42，6，20}，并写出排序的过程。<br>对排序表：30，13，70，85，39，42，6，20 进行划分<br>设初始状态：</p>
<p>第一趟排序：    (30) 13    70    85    39    42    6 20<br>第二趟排序：    (13    30)    70    85    39    42    6 20<br>第三趟排序：    (13    30    70)    85    39    42    6 20<br>第七趟排序：    (6    13    30    39    42    70    85)    20<br>第八趟排序：    (6    13    30    39    42    70    85)    20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def binaryInsert(a):</span><br><span class="line"># 折半插入排序: 小-&gt;大</span><br><span class="line"># 在直接插入排序的基础上使用了折半查找的方法 </span><br><span class="line">    for i in xrange(1, len(a)):</span><br><span class="line">        index &#x3D; a[i]</span><br><span class="line">        low &#x3D; 0</span><br><span class="line">        hight &#x3D; i - 1</span><br><span class="line">        while low &lt;&#x3D; hight:</span><br><span class="line">            mid &#x3D; (low + hight) &#x2F; 2</span><br><span class="line">            if index &gt; a[mid]:</span><br><span class="line">                low &#x3D; mid + 1</span><br><span class="line">            else:</span><br><span class="line">                hight &#x3D; mid - 1</span><br><span class="line">        # 跳出循环后 low, mid 都是一样的, hight &#x3D; low - 1</span><br><span class="line">        for j in xrange(i, low, -1):</span><br><span class="line">            a[j] &#x3D; a[j - 1]</span><br><span class="line">        a[low] &#x3D; index</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h2><p>交换排序是通过两两比较待排序记录的关键码，若发生排序要求相逆，则交换之</p>
<p>对下列序列排序{23，38，22，45，23，67，31，15，41}写出冒泡排序的过程。</p>
<p>初始关键字序列：  23    38    22    45    23    67    31    15    41；<br>第一趟排序后：    23    22    38    33    45    31    15    41    61；<br>第二趟排序后：    22    23    23    38    31    15    41    45    67；<br>第三趟排序后：    22    23    23    31    15    38    41    45    67；<br>第四趟排序后：    22    23    23    15    31    38    41    45    67；<br>第五趟排序后：    22    23    15    23    31    38    41    45    67；<br>第六趟排序后：    22    15    23    23    31    38    41    45    67；<br>第七趟排序后：    15    22    23    23    31    38    41    45    67；</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/7761644612D44FC58115EF304F360F80?method=download&shareKey=16637b3bb70a29545e6cd6dcae641d40" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def bubbleSort(arr):</span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line"> </span><br><span class="line">    # 遍历所有数组元素</span><br><span class="line">    for i in range(n):</span><br><span class="line"> </span><br><span class="line">        # Last i elements are already in place</span><br><span class="line">        for j in range(0, n-i-1):</span><br><span class="line"> </span><br><span class="line">            if arr[j] &gt; arr[j+1] :</span><br><span class="line">                arr[j], arr[j+1] &#x3D; arr[j+1], arr[j]</span><br><span class="line"> </span><br><span class="line">arr &#x3D; [64, 34, 25, 12, 22, 11, 90]</span><br><span class="line"> </span><br><span class="line">bubbleSort(arr)</span><br><span class="line"> </span><br><span class="line">print (&quot;排序后的数组:&quot;)</span><br><span class="line">for i in range(len(arr)):</span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure>

<p>性能分析：</p>
<p>（1）空间效率：$O(1)$</p>
<p>（2）时间效率：最好情况$O(n)$，平均时间复杂度为$O(n^2)$</p>
<p>（3）稳定性：稳定</p>
<h1 id="3-简单选择排序"><a href="#3-简单选择排序" class="headerlink" title="3 简单选择排序"></a>3 简单选择排序</h1><p>从无序序列$R[i..n]$的$n-i+1$记录中选出关键字最小的记录加入有序序列</p>
<p>对下列序列排序{49，14，38，74，96，65，49，8，55，27}；</p>
<p>第 1 趟之后：8    14    38    74    96    65    49    49    55    27<br>第 2 趟之后：8    14    38    74    96    65    49    49    55    27<br>（在本位就不用交换）<br>第 3 趟之后：8    14    27    74    96    65    49    49    55    38<br>第 4 趟之后：8    14    27    49    96    65    74    49    55    38</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/6A3A3EAE3343434E8E6699BAA353F38F?method=download&shareKey=58632ab023763519c4fb1b6d1bbd7abf" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys </span><br><span class="line">A &#x3D; [64, 25, 12, 22, 11] </span><br><span class="line">  </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line">    min_idx &#x3D; i </span><br><span class="line">    for j in range(i+1, len(A)): </span><br><span class="line">        if A[min_idx] &gt; A[j]: </span><br><span class="line">            min_idx &#x3D; j </span><br><span class="line">                </span><br><span class="line">    A[i], A[min_idx] &#x3D; A[min_idx], A[i] </span><br><span class="line">  </span><br><span class="line">print (&quot;排序后的数组：&quot;) </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">    print(&quot;%d&quot; %A[i]),</span><br></pre></td></tr></table></figure>


<p>性能分析：</p>
<p>（1）空间效率：$O(1)$</p>
<p>（2）时间效率：最好和平均时间复杂度均为$O(n^2)$</p>
<p>（3）稳定性：从前往后比较稳定，从后往前比较不稳定</p>
<h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h1><p>直接插入排序的改进版本，希尔排序把序列按一定间隔分组，对每组使用直接插入排序；随着间隔减小，一直到1，使得整个序列有序</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/7A971CDA8CA34300AE79B58854A8067B?method=download&shareKey=a6c84b288f98376985ad2214b2179a2f" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def shellSort(arr): </span><br><span class="line">  </span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line">    gap &#x3D; int(n&#x2F;2)</span><br><span class="line">  </span><br><span class="line">    while gap &gt; 0: </span><br><span class="line">  </span><br><span class="line">        for i in range(gap,n): </span><br><span class="line">  </span><br><span class="line">            temp &#x3D; arr[i] </span><br><span class="line">            j &#x3D; i </span><br><span class="line">            while  j &gt;&#x3D; gap and arr[j-gap] &gt;temp: </span><br><span class="line">                arr[j] &#x3D; arr[j-gap] </span><br><span class="line">                j -&#x3D; gap </span><br><span class="line">            arr[j] &#x3D; temp </span><br><span class="line">        gap &#x3D; int(gap&#x2F;2)</span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 34, 54, 2, 3] </span><br><span class="line">  </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序前:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]), </span><br><span class="line">  </span><br><span class="line">shellSort(arr) </span><br><span class="line">  </span><br><span class="line">print (&quot;\n排序后:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]),</span><br></pre></td></tr></table></figure>

<p>性能分析：</p>
<p>（1）空间效率：$O(1)$</p>
<p>（2）时间效率：依赖于步长的选取</p>
<p>（3）稳定性：不稳定</p>
<h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h1><p>以某个记录为界（该点称为支点）,将待排序列分成两部分。其中，一部分所有记录的关键码大于等于支点记录的关键码，另一部分所有记录的关键码小于支点记录的关键码，将此过程称为一次划分，对各部分不断划分，直到整个序列按关键码有序</p>
<p>设置指针low,high，初始值为第一个和最后一个记录的位置，设两个变量$i,j$，令$i=low，j=high$，以$R[low].key$作为基准（将$R[low]保存在R[0]$）</p>
<ol>
<li><p>从$j$所指位置向前搜索：将$R[0].key$与$R[j].key$进行比较</p>
<ul>
<li>若$R[0].key&lt;=R[j].key$：令$j=j-1$，然后继续进行比较，直到$i=j$或$R[0].key&gt;=R[j].key$为止；</li>
<li>若$R[0].key&gt;R[j].key$：$R[j]=R[i]$，腾出$R[j]$的位置，且令$i=i+1$;</li>
</ul>
</li>
<li><p>从$i$所指位置起向后搜索：将$R[0].key$与$R[i].key$进行比较：</p>
<ul>
<li>若$R[0].key&gt;=R[i].key$:令$i=i+1$，然后进行比较，直到$i=j$或$R[0].key&lt;R[i].key$为止；</li>
<li>若$R[0].key&lt;R[i].key$:令$R[i]=R[j]$，腾出$R[i]$的位置，且令$j=j-1$;</li>
</ul>
</li>
<li><p>重复1，2直至$i=j$为止，$i$就是$R[0]$所应放置的位置</p>
</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/519327C530694B5594AF6E9DFE3077DF?method=download&shareKey=7556ec6121cdbc1262ee7d150e0de45e" alt></p>
<p>当进行一趟快速排序后，采用相同方法分别对两个子序列快速排序，直至子序列记录个为1为止<br><img src="https://note.youdao.com/yws/api/personal/file/4A0267871158449CBE0A83CCA16D8393?method=download&shareKey=da100567e02c7e17747e6d32b1edba56" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def partition(arr,low,high): </span><br><span class="line">    i &#x3D; ( low-1 )         # 最小元素索引</span><br><span class="line">    pivot &#x3D; arr[high]     </span><br><span class="line">  </span><br><span class="line">    for j in range(low , high): </span><br><span class="line">  </span><br><span class="line">        # 当前元素小于或等于 pivot </span><br><span class="line">        if   arr[j] &lt;&#x3D; pivot: </span><br><span class="line">          </span><br><span class="line">            i &#x3D; i+1 </span><br><span class="line">            arr[i],arr[j] &#x3D; arr[j],arr[i] </span><br><span class="line">  </span><br><span class="line">    arr[i+1],arr[high] &#x3D; arr[high],arr[i+1] </span><br><span class="line">    return ( i+1 ) </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"># arr[] --&gt; 排序数组</span><br><span class="line"># low  --&gt; 起始索引</span><br><span class="line"># high  --&gt; 结束索引</span><br><span class="line">  </span><br><span class="line"># 快速排序函数</span><br><span class="line">def quickSort(arr,low,high): </span><br><span class="line">    if low &lt; high: </span><br><span class="line">  </span><br><span class="line">        pi &#x3D; partition(arr,low,high) </span><br><span class="line">  </span><br><span class="line">        quickSort(arr, low, pi-1) </span><br><span class="line">        quickSort(arr, pi+1, high) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [10, 7, 8, 9, 1, 5] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">quickSort(arr,0,n-1) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure>

<p>性能分析：</p>
<p>（1）空间效率：$O(nlog_2n)$</p>
<p>（2）时间效率：最好$O(nlog_2n)$，最坏$O(n^2)$</p>
<p>（3）稳定性：不稳定</p>
<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h1><h2 id="6-1-堆的性质"><a href="#6-1-堆的性质" class="headerlink" title="6.1 堆的性质"></a>6.1 堆的性质</h2><ol>
<li>堆是一棵采用顺序存储结构的完全二叉树，$k_1$是根结点</li>
<li>根结点是关键字序列中最小（或最大）值，分别称为小（或大）根堆</li>
<li>从根结点到每一叶子结点路径上的元素组成的序列都是按元素值非递减（或非递增）</li>
<li>堆中的任一子树也是堆</li>
</ol>
<p>利用堆顶记录的关键字最小（或最大）性质，从当前待排序的记录中依次选取关键字最小（或最大）的记录，实现对数据记录的排序，称为堆排序</p>
<h2 id="6-2-堆排序思想"><a href="#6-2-堆排序思想" class="headerlink" title="6.2 堆排序思想"></a>6.2 堆排序思想</h2><ol>
<li>对一组待排序的记录，按堆定义建堆</li>
<li>将堆顶记录和最后一个记录交换位置，则前$n-1$个记录是无序的，最后一个记录有序的</li>
<li>堆顶记录被交换后，前$n-1$个记录不再是堆，需要重新调整为一个堆，重复2操作，直到全部记录排好序</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/548842621E8D4AACAB1CD7FD7DC5DD5A?method=download&shareKey=b859872f37b596a5ded5f420bf786943" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def heapify(arr, n, i): </span><br><span class="line">    largest &#x3D; i  </span><br><span class="line">    l &#x3D; 2 * i + 1     # left &#x3D; 2*i + 1 </span><br><span class="line">    r &#x3D; 2 * i + 2     # right &#x3D; 2*i + 2 </span><br><span class="line">  </span><br><span class="line">    if l &lt; n and arr[i] &lt; arr[l]: </span><br><span class="line">        largest &#x3D; l </span><br><span class="line">  </span><br><span class="line">    if r &lt; n and arr[largest] &lt; arr[r]: </span><br><span class="line">        largest &#x3D; r </span><br><span class="line">  </span><br><span class="line">    if largest !&#x3D; i: </span><br><span class="line">        arr[i],arr[largest] &#x3D; arr[largest],arr[i]  # 交换</span><br><span class="line">  </span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">  </span><br><span class="line">def heapSort(arr): </span><br><span class="line">    n &#x3D; len(arr) </span><br><span class="line">  </span><br><span class="line">    # Build a maxheap. </span><br><span class="line">    for i in range(n, -1, -1): </span><br><span class="line">        heapify(arr, n, i) </span><br><span class="line">  </span><br><span class="line">    # 一个个交换元素</span><br><span class="line">    for i in range(n-1, 0, -1): </span><br><span class="line">        arr[i], arr[0] &#x3D; arr[0], arr[i]   # 交换</span><br><span class="line">        heapify(arr, i, 0) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 11, 13, 5, 6, 7] </span><br><span class="line">heapSort(arr) </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序后&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure>

<p>性能分析：</p>
<p>（1）空间效率：$O(1)$</p>
<p>（2）时间效率：$O(nlog_2n)$</p>
<p>（3）稳定性：不稳定</p>
<h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h1><ol>
<li>将序列划分成$n$个待排的长度为1的子序列</li>
<li>对所有子序列进行两两归并，得到$n/2$个长度为2或1的有序子序列</li>
<li>重复2，直到得到长度为n的有序序列为止</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/550329FAA2224DA1909CCE2C53C7C862?method=download&shareKey=75cb313577311fe8a6540ffb19003dd3" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def merge(arr, l, m, r): </span><br><span class="line">    n1 &#x3D; m - l + 1</span><br><span class="line">    n2 &#x3D; r- m </span><br><span class="line">  </span><br><span class="line">    # 创建临时数组</span><br><span class="line">    L &#x3D; [0] * (n1)</span><br><span class="line">    R &#x3D; [0] * (n2)</span><br><span class="line">  </span><br><span class="line">    # 拷贝数据到临时数组 arrays L[] 和 R[] </span><br><span class="line">    for i in range(0 , n1): </span><br><span class="line">        L[i] &#x3D; arr[l + i] </span><br><span class="line">  </span><br><span class="line">    for j in range(0 , n2): </span><br><span class="line">        R[j] &#x3D; arr[m + 1 + j] </span><br><span class="line">  </span><br><span class="line">    # 归并临时数组到 arr[l..r] </span><br><span class="line">    i &#x3D; 0     # 初始化第一个子数组的索引</span><br><span class="line">    j &#x3D; 0     # 初始化第二个子数组的索引</span><br><span class="line">    k &#x3D; l     # 初始归并子数组的索引</span><br><span class="line">  </span><br><span class="line">    while i &lt; n1 and j &lt; n2 : </span><br><span class="line">        if L[i] &lt;&#x3D; R[j]: </span><br><span class="line">            arr[k] &#x3D; L[i] </span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else: </span><br><span class="line">            arr[k] &#x3D; R[j] </span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 L[] 的保留元素</span><br><span class="line">    while i &lt; n1: </span><br><span class="line">        arr[k] &#x3D; L[i] </span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 R[] 的保留元素</span><br><span class="line">    while j &lt; n2: </span><br><span class="line">        arr[k] &#x3D; R[j] </span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">def mergeSort(arr,l,r): </span><br><span class="line">    if l &lt; r: </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        m &#x3D; int((l+(r-1))&#x2F;2)</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+1, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6, 7] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;给定的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]), </span><br><span class="line">  </span><br><span class="line">mergeSort(arr,0,n-1) </span><br><span class="line">print (&quot;\n\n排序后的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure>

<p>性能分析：<br>（1）空间复杂度：$O(n)$</p>
<p>（2）时间复杂度：$O(nlog_2n)$</p>
<p>（3）稳定性：稳定</p>
<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h1><ol>
<li>待排序记录以指针相链，构成一个链表</li>
<li>分配时，按当前关键字所取值，将记录分配到不同的链队列中，每个队列中记录的关键字相同</li>
<li>收集时，按当前关键字位取值从小到大将各队列首尾相链成一个链表</li>
<li>对每个关键字位均重复2，3</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/E9DF1FF414E54E1286F6D076F1E31085?method=download&shareKey=9810a1638a78b374beff7ec84f5f424b" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def countSort(arr): </span><br><span class="line">  </span><br><span class="line">    output &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    count &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    ans &#x3D; [&quot;&quot; for _ in arr] </span><br><span class="line">  </span><br><span class="line">    for i in arr: </span><br><span class="line">        count[ord(i)] +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(256): </span><br><span class="line">        count[i] +&#x3D; count[i-1] </span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        output[count[ord(arr[i])]-1] &#x3D; arr[i] </span><br><span class="line">        count[ord(arr[i])] -&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        ans[i] &#x3D; output[i] </span><br><span class="line">    return ans  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; &quot;wwwrunoobcom&quot;</span><br><span class="line">ans &#x3D; countSort(arr) </span><br><span class="line">print ( &quot;字符数组排序 %s&quot;  %(&quot;&quot;.join(ans)) )</span><br></pre></td></tr></table></figure>

<p>性能分析：</p>
<p>（1）空间效率：$O(rd)$</p>
<p>（2）时间效率：$O(d(n+rd))$</p>
<p>（3）稳定性：稳定</p>
<h1 id="9-各排序算法性能总结"><a href="#9-各排序算法性能总结" class="headerlink" title="9 各排序算法性能总结"></a>9 各排序算法性能总结</h1><table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均时间性能</th>
<th align="center">最好时间性能</th>
<th align="center">最坏性能</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直接插入</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">简单选择</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(nlog_2n)-O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(nlog_2n)-O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(d(n+rd))$</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(n+rd)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p>基数排序中，$r$代表关键字的基数，$d$代表长度，$n$代表关键字的个数</p>
<p>关于时间复杂度：</p>
<ol>
<li>平方阶（$O(n^2)$）排序，各类简单排序：直接插入、直接选择、冒泡排序</li>
<li>线性对数阶（$O(nlog2n)$）排序：快速排序，堆排序和归并排序</li>
<li>$O(n1+\epsilon)$：希尔排序</li>
<li>线性阶$O(n)$：计数排序</li>
</ol>
<p>关于稳定性：</p>
<ol>
<li>稳定：冒泡、插入、归并、计数</li>
<li>不稳定：选择、快速、希尔、堆排序</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（四）逻辑回归</title>
    <url>/2020/07/24/LogisticRegression/</url>
    <content><![CDATA[<p>逻辑回归，是一种名为“回归”的线性分类器，其本质是由线性回归变化而来，一种广泛使用于分类问题的广义回归算法。</p>
<h2 id="1-逻辑回归原理"><a href="#1-逻辑回归原理" class="headerlink" title="1 逻辑回归原理"></a>1 逻辑回归原理</h2><p>理解逻辑回归，先要理解线性回归，线性回归的方程为：<br>$$z=\theta_0+\theta_1x_1+\theta_2x_2+\dots+\theta_nx_n$$</p>
<p>其中，$\theta$被统称为模型的参数，其中$\theta_0$被称为截距，$\theta_1\sim\theta_n$被称为系数，用矩阵来表示这个方程，其中$x,\theta$都可以被看作是一个列矩阵，则有：</p>
<a id="more"></a>

<p>$$z=\begin{bmatrix}\theta_0,\theta_1,\theta_2,\dots,\theta_n \end{bmatrix}*<br>\begin{bmatrix}x_0\\<br>x_1\\<br>x_2\\<br>\dots\\<br>\theta_n<br>\end{bmatrix}$$</p>
<p>通过函数$z$，可以使用输入的特征矩阵$X$来输出一组连续型的标签纸$y_pred$，以完成预测连续型变量的任务。但是如果标签是离散变量，则需要通过引入联系函数，将线性回归的方程$z$变成$g(z)$，并且令$g(z)$的值分布在$(0,1)$之间，对于逻辑回归来说，这个联系函数式Sigmoid函数：<br>$$g(z)=\frac{1}{1+\exp^{-z}}$$<br><img src="https://note.youdao.com/yws/api/personal/file/CF992254DF284E19AAF3D5065557A539?method=download&shareKey=55ac36a4ac1688679e29b3df6f2c94c4" alt></p>
<p>线性回归中$z=\theta^Tx$，将$z$代入，可以得到二元逻辑回归模型的一般形式：<br>$$g(z)=y(x)=\frac{1}{1+\exp^{-\theta^Tx}}$$</p>
<p>$y(x)$取值都在$[0,1]$之间，$y(x)$被视为样本$x$作为正例的可能性，则$1-y(x)$是其反例的可能性，两者的比值：<br>$$\frac{y}{1-y}$$</p>
<p>称为“几率”（odds），反映了$x$作为正例的相对可能性，对几率取对数则得到“对数几率”(log odds,亦称logit): $ln\frac{y}{1-y}$</p>
<p>在此基础上取对数，可以得到：<br>$$ln\frac{y(x)}{1-y(x)}=ln(\frac{\frac{1}{1+e^{-\theta^Tx}}}{1-\frac{1}{1+\exp^{-\theta^Tx}}})$$<br>$$=ln(\frac{\frac{1}{1+\exp^{-\theta^Tx}}}{\frac{\exp^{-\theta^Tx}}{1+\exp^{-\theta^Tx}}})$$<br>$$=ln(\exp^{\theta^Tx})$$<br>$$=\theta^Tx$$</p>
<p>我们发现，$y(x)$的形式几率取对数的本质其实就是线性回归$z$，<strong>注意，虽然我们熟悉的逻辑回归通常被用于处理二分类问题，但逻辑回归也可以做多分类</strong></p>
<h2 id="2-二元逻辑回归的损失函数"><a href="#2-二元逻辑回归的损失函数" class="headerlink" title="2 二元逻辑回归的损失函数"></a>2 二元逻辑回归的损失函数</h2><p>逻辑回归的损失函数式由极大似然估计推导出来的，具体结果可以写作:<br>$$J(\theta)=-\sum_{i=1}^m(y_i*log(y_\theta(x_i))+(1-y_i) * log(1-y_\theta(x_i)))$$</p>
<p>其中，$\theta$表示求解出来的一组参数，$m$是样本的个数，$y_i$是样本$i$上真实的标签，$y_\theta(x_i)$是样本$i$上，基于参数$\theta$计算出来的逻辑回归返回值，$x_i$是样本i各个特征的取值。</p>
<h3 id="2-1-损失函数极大似然推导"><a href="#2-1-损失函数极大似然推导" class="headerlink" title="2.1 损失函数极大似然推导"></a>2.1 损失函数极大似然推导</h3><p>二元逻辑回归的标签服从伯努利分布（0-1分布），因此我们可以将一个特征向量$x$,参数为$\theta$的模型中的一个样本$i$的预测情况表现为如下形式：</p>
<ul>
<li><p>样本$i$在由特征向量$x_i$和参数$\theta$组成的预测函数中，样本标签被预测为1的概率为：<br>$$P_1 = P(\hat y_i = 1|x_i,\theta)=y_\theta(x_i)$$</p>
</li>
<li><p>样本$i$在由特征向量$x_i$和参数$\theta$组成的预测函数中，样本标签被预测为0的概率为：<br>$$P_1 = P(\hat y_i = 0|x_i,\theta)=1-y_\theta(x_i)$$</p>
</li>
</ul>
<p>当$P_1$为1时，预测为1，当$P_0$为1时，代表预测为0</p>
<p>将两种取值的概率整合，可以得到如下等式：</p>
<p>$$P(\hat y_i|x_i,\theta)=P_i^{y_i}*P_0^{1-y_i}$$</p>
<p>$P(\hat y_i|x_i,\theta)$的本质是样本$i$由特征向量$x_i$和参数$\theta$组成的预测函数中，预测出所有可能的$\hat y_i$的概率，因此1是它的最大值，因此我们是在追求$P(\hat y_i|x_i,\theta)$的最大值。</p>
<p>$P(\hat y_i|x_i,\theta)$是对单个样本$i$而言的函数，对一个训练集的$m$个样本来说，所有样本在特征矩阵$X$和参数$\theta$组成的预测函数中，预测出所有可能的$\hat y$的概率$P$为：</p>
<p>$$P = \prod_{i=1}^m P(\hat y_i|x_i,\theta)$$<br>$$= \prod_{i=1}^m (P_i^{y_i})$$<br>$$= \prod_{i=1}^m (y_0(x_i)^{y_i}*(1-y_0(x_i))^{1-y_i})$$</p>
<p>对该概率$P$取对数，再有$log(A*B)=logA+logB$和$logA^B=BlogA$可得到：</p>
<p>$$logP= log\prod_{i=1}^m (y_0(x_i)^{y_i}*(1-y_0(x_i))^{1-y_i})$$</p>
<p>$$=\sum_{i=1}^m log(y_0(x_i)^{y_i}*(1-y_0(x_i))^{1-y_i})$$</p>
<p>$$=\sum_{i=1}^m(logy_0(x_i)^{y_i}+log(1-y_0(x_i))^{1-y_i})$$</p>
<p>$$=\sum_{i=1}^m(y_i * log(y_0(x_i))+(1-y_i) * log(1-y_0(x_i)))$$</p>
<p>这就是交叉熵函数，为了便于定义“损失”含义，把极大值问题转换为极小值问题，因此我们对$logP$取负，并且让参数$\theta$作为函数的自变量，就得到了我们的损失函数$J(\theta)$</p>
<p>$$J(\theta)=-\sum_{i=1}^m(y_i * log(y_\theta(x_i))+(1-y_i) * log(1-y_0(x_i)))$$</p>
<h3 id="2-2-正则化"><a href="#2-2-正则化" class="headerlink" title="2.2 正则化"></a>2.2 正则化</h3><p>正则化是用来防止模型过拟合的过程，常用的有$L_1$正则化和$L_2$正则化，如下所示：</p>
<p>$$ J(\theta)_{L_1} = C * J(\theta) +\sum_j^n |\theta_j|\ (j&gt;=1)$$</p>
<p>$$J(\theta)_{L_2}=C * J(\theta)+\sqrt{\sum_j^n(\theta_j)^2}\ (j&gt;=1)$$</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">penalty</td>
<td align="left">可以输入”l1”或”l2”来指定使用哪一种正则化方式，不填写默认”l2”。注意，若选择”l1”正则化，参数solver仅能够使用求解方式”liblinear”和”saga“，若使用“l2”正则化，参数solver中所有的求解方式都可以使用。</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">C正则化强度的倒数，必须是一个大于0的浮点数，不填写默认1.0，即默认正则项与损失函数的比值是1：1。C越小，损失函数会越小，模型对损失函数的惩罚越重，正则化的效力越强，参数会逐渐被压缩得越来越小。</td>
</tr>
</tbody></table>
<h3 id="2-3-梯度下降"><a href="#2-3-梯度下降" class="headerlink" title="2.3 梯度下降"></a>2.3 梯度下降</h3><p>现在有一个带两个特征并且没有截距的逻辑回归$y(x_1,x_2)$，两个特征所对应的参数分别为$[\theta_1,\theta_2]$。下面这个平面就是我们损失函数$J(\theta_1,\theta_2)$在$\theta_1,\theta_2,j$为坐标轴的三维立体坐标系上的图像，我们寻求损失函数的最小值，也就是求图像的最低点。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/EA89311DC35C43BCB583EE77B28C5533?method=download&shareKey=40697b4035e3fb639c03e8a3a6ee3593" alt></p>
<p>在逻辑回归中，我们的损失函数为：</p>
<p>$$J(\theta)=-\sum_{i=1}^m(y_i * log(y_\theta(x_i))+(1-y_i) * log(1-y_0(x_i)))$$</p>
<p>对这个函数的自变量$\theta$求偏导，可以得到梯度向量在第$j$组$\theta$的坐标点上的表示形式：</p>
<p>$$\frac{\partial}{\partial \theta_j}J(\theta)=d_j = \sum_{i=1}^m(y_\theta(x_i)-y_i)x_{ij}$$</p>
<p>在这个公式下，只要给定一组$\theta$的取值$\theta_j$再代入特征矩阵$x$，就可以求得这一组$\theta$取值下的预测结果$y_\theta(x_i)$，结合真实标签$y$，就可以获得这一组$\theta_j$取值下的梯度向量，其大小表示为$d_j$</p>
<p>我们的目的是在可能的$\theta$上进行遍历，一次次计算梯度向量，并在梯度向量的反方向上让损失函数$J$下降至最小值，在这个过程中，我们的$\theta$和梯度向量的大小$d$都会不断改变，遍历$\theta$的过程可以描述为：</p>
<p>$$\theta_{j+1}=\theta_j-\alpha * d_j$$</p>
<p>$$=\theta_j-\alpha * \sum_{i=1}^m(y_\theta(x_i)-y_i)x_{ij}$$</p>
<p>其中$\theta_{j+1}$是第$j+1$次迭代后的参数向量，$\theta_j$是第$j$此迭代的参数向量，$\alpha$被称为步长，控制着每一步$\theta$的变化</p>
<p>下面是一张二维平面的求导三角形图，抛物线就是我们的损失函数$J(\theta)$，$A(\theta_a, J(\theta_a))$就是小球最初在的位置，$B(\theta_b, J(\theta_b))$就是一次滚动后小球移动到的位置，A到B的方向就是梯度向量的反方向，指向损失函数在A点下降最快的方向，而梯度向量的大小是点A在图像上对$\theta$求导后的结果，也是点A切线方向的斜率，橙色角$tan$结果，记为$d$</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/C5409617143F42ECA36A291937F5E6CF?method=download&shareKey=86b3dbbcb321f5712bf5dccd8497561b" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（五）集成学习</title>
    <url>/2020/07/26/ensemble/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>多个模型集成称为的模型叫作集成评估器（ensemble estimator），组成集成评估器的每个模型都叫作基评估器(base estimator)。通常来说，有两类集成算法：装袋法（Bagging），提升法(Boosting)。要获得好的集成，个体学习器应“好而不同”，即个体学习器要有一定的“准确性”，并且要有“多样性”</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/ADF733049258402C8AD900FD965CB288?method=download&shareKey=18ded5ff7e25a56d46886670b21ef009" alt></p>
<ul>
<li>装袋法：多个相互独立的评估器，对其预测进行平均或多数表决原则来决定集成评估器的结果（随机森林）</li>
<li>提升法：基评估器是相关的，是按顺序一一构建的。其核心思想是结合弱评估器的力量一次次对难以评估的样本进行预测，从而构成一个强评估器（Adaboost，梯度提升树）<a id="more"></a>

</li>
</ul>
<h2 id="2-Bagging"><a href="#2-Bagging" class="headerlink" title="2 Bagging"></a>2 Bagging</h2><p>Bagging是并行式集成学习方法最著名的代表，通过自助采样法得到多个训练样本的采样集，然后基于每个采样集孙连出一个基学习器，再将这些基学习器进行结合，在对预测输出进行结合时，Bagging通常对分类任务使用简单投票法，对回归任务使用简单平均法。</p>
<h3 id="2-1-随机森林（Random-Forest-RF）"><a href="#2-1-随机森林（Random-Forest-RF）" class="headerlink" title="2.1 随机森林（Random Forest, RF）"></a>2.1 随机森林（Random Forest, RF）</h3><p>随机森林是非常具有代表性的Bagging集成算法，RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择，传统决策树在选择划分属性时是在当前节点的属性集合（假设有d个属性）中选择一个最优属性；而在RF中，对基决策树的每个节点，先从该节点的属性集合中随机选择一个包含$k$个属性的子集，然后再从这个子集中选择一个最优属性用于划分。</p>
<h3 id="2-2-重要参数"><a href="#2-2-重要参数" class="headerlink" title="2.2 重要参数"></a>2.2 重要参数</h3><h3 id="2-2-1-控制基评估器的参数"><a href="#2-2-1-控制基评估器的参数" class="headerlink" title="2.2.1 控制基评估器的参数"></a>2.2.1 控制基评估器的参数</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">criterion</td>
<td align="left">不纯度的衡量指标，有基尼系数和信息熵两种选择</td>
</tr>
<tr>
<td align="left">max_depth</td>
<td align="left">树的最大深度，超过最大深度的树枝都会被剪掉</td>
</tr>
<tr>
<td align="left">min_samples_leaf</td>
<td align="left">一个节点在分枝后的每个子节点都必须包含至少min_samples_leaf个训练样本，否则分枝就不会发生</td>
</tr>
<tr>
<td align="left">min_samples_split</td>
<td align="left">一个节点必须要包含至少min_samples_split个训练样本，这个节点才允许被分枝，否则分枝就不会发生</td>
</tr>
<tr>
<td align="left">max_features</td>
<td align="left">max_features限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃，默认值为总特征个数开平方取整</td>
</tr>
<tr>
<td align="left">min_impurity_decrease</td>
<td align="left">限制信息增益的大小，信息增益小于设定数值的分枝不会发生</td>
</tr>
</tbody></table>
<h3 id="2-2-2-n-estimators"><a href="#2-2-2-n-estimators" class="headerlink" title="2.2.2 n_estimators"></a>2.2.2 n_estimators</h3><p>这是森林中树木的数量，即基评估器的数量。这个参数对随机森林模型的精确性影响是单调的，n_estimators越大，模型的效果往往越好。但是相应的，任何模型都有决策边界，n_estimators达到一定的程度之后，随机森林的精确性往往不在上升或开始波动，并且，n_estimators越大，需要的计算量和内存也越大，训练的时间也会越来越长。对于这个参数，我们是渴望在训练难度和模型效果之间取得平衡。</p>
<p>n_estimators的默认值在现有版本的sklearn中是10，但是在即将更新的0.22版本中，这个默认值会被修正为100。这个修正显示出了使用者的调参倾向：要更大的n_estimators。</p>
<h3 id="2-2-3-random-state"><a href="#2-2-3-random-state" class="headerlink" title="2.2.3 random_state"></a>2.2.3 random_state</h3><p>在决策树中，从最重要的特征中随机选择出一个特征进行分枝，这个功能由参数random_state控制，在随机森林中，用法和分类树相似，通过这个参数控制生成森林的模型，让森林中的树木具有多样性</p>
<h3 id="2-2-4-bootstrap-amp-oob-score"><a href="#2-2-4-bootstrap-amp-oob-score" class="headerlink" title="2.2.4 bootstrap &amp; oob_score"></a>2.2.4 bootstrap &amp; oob_score</h3><p>Bagging通过自助采样技术来形成不同的训练数据，bootstrap就是用来控制采样技术的参数</p>
<p>bootstrap参数默认True，代表采用这种有放回的随机抽取技术（通常不会被设置为False）</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/4BDC11FD2EB54DFE874F6D1AB68277A0?method=download&shareKey=6ade8a6ff415a53d39ae944bccf89e54" alt></p>
<p>一般来说，自助集大概平均会包含63%的原始数据，每一个样本被抽取到某自助集的概率为：</p>
<p>$$1-(1-\frac{1}{n})^n$$</p>
<p>当n足够大时，这个概率收敛与$1-(1/e)$，越等于0.632，因此会约有37%的训练数据被浪费掉，没有参与建模，这些数据被称为袋外数据(out of bag data, oob)。</p>
<p>也就是说，在使用随机森林时，可以不划分测试集和训练集，用袋外数据来测试我们的模型</p>
<h2 id="3-boosting"><a href="#3-boosting" class="headerlink" title="3 boosting"></a>3 boosting</h2><p>Boosting是一族可将弱学习器提升为强学习器的算法。先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器。</p>
<h3 id="3-1-Adaboost"><a href="#3-1-Adaboost" class="headerlink" title="3.1 Adaboost"></a>3.1 Adaboost</h3><h4 id="3-1-1-Adaboost原理"><a href="#3-1-1-Adaboost原理" class="headerlink" title="3.1.1 Adaboost原理"></a>3.1.1 Adaboost原理</h4><p>AdaBoost算法是Adaptive Boost的简称，Boosting通过将一系列弱学习器组合起来，通过集成这些弱学习器的学习能力，得到一个强学习器。具体到AdaBoost算法，AdaBoost在之前学习器的基础上改变样本的权重，增加那些之前被分类错误的样本的比重，降低分类正确样本的比重，这样之后的学习器将重点关注那些被分类错误的样本。最后通过将这些学习器通过加权组合成一个强学习器，具体的，分类正确率高的学习器权重较高，分类正确率低的学习器权重较低。</p>
<p>假设：</p>
<p>输入：训练集$X={(x_1,y_1),(x_2,y_2),(x_3,y_3),\dots,(x_n,y_n)},\ x_i\in R^n,\ y_i\in 0,1$</p>
<p>输出：最终学习器$G(x)$</p>
<ol>
<li>初始化训练数据的权重分布值：（$D_m$表示第m个弱学习器的样本点的权值）<br>$$D_1=(w_{11},\dots,w_{1i},\dots,w_{1N}),\  w_{1i}=1/N,\  i=1,2,\dots,N$$</li>
<li>对于M个弱学习器，$m=1,2,3,\dots,M$<ul>
<li>使用具有权值分布$D_m$的训练数据集进行学习，得到基本分类器$G_m(x)$，其输出值为$-1,1$</li>
<li>计算弱分类器$G_m(x)$在训练数据集上的分类误差率$e_m$，其值越小的基分类器在最终分类器中的作用越大<br>$$e_m = P(G_m(x)\ne y_i)=\sum_{i=1}^N w_{mi}I(G_m(x_i)\ne y_i)$$<br>其中，$I(G_m(x_i)\ne y_i)$取值为0或1，取0表示分类正确，取1表示分类错误。</li>
<li>计算弱分类器$G_m(x)$的权重系数$\alpha_m$:<br>$$\alpha_m = \frac{1}{2}ln\frac{1-e_m}{e_m}$$<br>当$e_m$减小是时候$\alpha_m$的值增大，而我们希望得到的是分类误差率越小的弱分类器的权值越大，对最终的预测产生的影响也就越大</li>
<li>更新训练集的样本权值分布：<br>$$D_{m+1}=(w_{m+1,1},w_{m+1,2},\dots,w_{m+1,N})$$<br>$$w_{m+1,i}=\frac{w_{mi}}{Z_m}exp(-\alpha_m y_i G_m(x_i)),\ i=1,2,\dots,N$$<br>对于二分类，弱分类器$G_m(x)$的输出取值为$-1,1$，$y_i$的取值为$-1,1$，所以对于正确的分类$y_iG_m(x)&gt;0$，错误的分类小于0，由于样本权重值在$0-1$之间，当分类正确时的$w_{m+1,i}$取值较小，而分类错误时$w_{m+1,i}$取值较小，而分类错时取值较大，符合我们期望的权重值高的训练样本点在后面的弱学习器中会得到更多的重视。<br>其中，$Z_m$是规范化因子，主要作用是将$W_{mi}$规范到0-1之间，使得$\sum_{i=1}^Nw_{mi}=1$</li>
</ul>
</li>
</ol>
<p>$$Z_m = \sum_{i=1}^N w_{mi}exp(-\alpha_m y_i G_m(x_i))$$</p>
<ol start="3">
<li>通过加权平均法构建基本分类器的线性组合<br>$$f(x)=\sum_{m=1}^M \alpha_mG_m(x)$$<br>得到最终的分类器<br>$$G(x)=sign(f(x))=sign(\sum_{m=1}^M\alpha_mG_m(x))$$</li>
</ol>
<h4 id="3-1-2-Adaboost优缺点"><a href="#3-1-2-Adaboost优缺点" class="headerlink" title="3.1.2 Adaboost优缺点"></a>3.1.2 Adaboost优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>不容发生过拟合</li>
<li>由于AdaBoost并没有限制弱学习器的种类，所以可以使用不同的学习算法来构建弱分类器</li>
<li>具有很高的精度</li>
<li>相对于Bagging算法和Random Forest算法，Adaboost充分考虑每个分类器的权重</li>
<li>参数较少，实际应用中不需要调节太多的参数</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>AdaBoost迭代次数也就是弱分类器数目不太好设定，可以用交叉验证来确定</li>
<li>数据不平衡导致分类精度下降</li>
<li>训练比较耗时，每次重新选择当前分类器最好切分点</li>
<li>对异常样本敏感，异常样本在迭代中可能会获得比较高的权重，影响最终的枪学习器的预测准确性</li>
</ol>
<h3 id="3-2-GBDT（Gradient-Boosting-Decision-Tree，梯度提升树）"><a href="#3-2-GBDT（Gradient-Boosting-Decision-Tree，梯度提升树）" class="headerlink" title="3.2 GBDT（Gradient Boosting Decision Tree，梯度提升树）"></a>3.2 GBDT（Gradient Boosting Decision Tree，梯度提升树）</h3><h4 id="3-2-1-GBDT原理"><a href="#3-2-1-GBDT原理" class="headerlink" title="3.2.1 GBDT原理"></a>3.2.1 GBDT原理</h4><p>输入：训练数据集$T=(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)$，损失函数为$L(y,f(x))$<br>输出：回归树$F(x)$</p>
<ol>
<li>初始化：（估计使损失函数极小化的常数值，是只有一个根节点的树，一般平方损失函数为节点的均值，而绝对损失函数为节点样本的中位数）</li>
</ol>
<p>$$f_0(x)=arg\min_c\sum_{i=1}^NL(y_i,c)$$</p>
<ol start="2">
<li><p>对$m=1,2,\dots,M$（M表示迭代次数，即生成弱学习器的个数）</p>
<ul>
<li>对于样本$i=1,2,\dots,N$，计算损失函数的负梯度在当前模型的值，将它作为残差的估计<br>$$r_{mi}=-\frac{\partial L(y_i,f(x))}{\partial f(x_i)}f(x)=f_{m-1}(x)$$</li>
<li>对$(x_1,r_{m1}),\dots,(x_N,r_{mN})$拟合一个回归树，得到第$m$棵树的叶结点区域$R_{mj}，\ j=1,2,\dots,J$（$J$表示每棵树的叶结点个数）</li>
<li>对$j=1,2,\dots,J$，利用线性所搜，估计叶结点区域的值，使损失函数最小化，计算<br>$$c_{mj}=arg\min_c\sum_{x\in R_{mj}}L(y_i,f_{m-1}(x_i+c))$$</li>
<li>更新<br>$$f_m(x)=f_{m-1}(x)+\sum_{J}^{j=1}c_{mj}I(x\in R_{mj})$$</li>
</ul>
</li>
<li><p>得到最终的回归树<br>$$F(x)=\sum_{m=1}^M\sum_{j=1}^Jc_{mj}I(x\in R_{mj})$$</p>
</li>
</ol>
<h3 id="3-3-XGboost"><a href="#3-3-XGboost" class="headerlink" title="3.3 XGboost"></a>3.3 XGboost</h3><h4 id="3-3-1-目标函数"><a href="#3-3-1-目标函数" class="headerlink" title="3.3.1 目标函数"></a>3.3.1 目标函数</h4><p>不同于逻辑回归和SVM等算法中固定的损失函数写法，集成算法中的损失函数式可选的，要选用什么损失函数取决于我们希望解决什么问题，以及希望使用什么的模型。只要我们选出的函数式一个可微的，能够代表某种损失的函数，它就可以使XGB的损失函数</p>
<p>并且XGB引入了模型复杂度来衡量算法的运算效率，因此目标函数被写作：传统损失函数+模型复杂度<br>$$0bj = \sum_{i=1}^ml(y_i,\hat y_i)+\sum_{k=1}^k\Omega (f_k)$$</p>
<p>其中$i$代表数据集中的第$i$个样本，$m$表示导入第k课树的数据总量，$K$代表建立的所有树(n_estimators)</p>
<p><strong>注意，第二项中没有特征矩阵$x_i$的介入</strong></p>
<p>第一项传统损失函数式与已建好的所有树相关的</p>
<p>$$\hat y_i^{(t)}=\sum_k^t f_k(x_i)=\sum_k^{t-1}f_k(x_i)+f_t(x_i)$$</p>
<p>一个集成模型$(f)$在位置数据集$(D)$上的泛化误差$E(f;D)$,有方差(var)，偏差(bais)和噪声$(\epsilon)$共同决定。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/48279AFEA82B4F87A43B6C43E9140635?method=download&shareKey=ec4af651ab4bd7023b0bcaa0f4657e25" alt></p>
<p>我们使用参数”objective”来确定我们目标函数的第一部分，也是衡量损失的部分</p>
<table>
<thead>
<tr>
<th align="left">输入</th>
<th align="left">选用的损失函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reg:linear</td>
<td align="left">使用线性回归的损失函数，均方误差，回归时使用</td>
</tr>
<tr>
<td align="left">binary:logistic</td>
<td align="left">使用逻辑回归的损失函数，对数损失log_loss，二分类时使用</td>
</tr>
<tr>
<td align="left">binary:hinge</td>
<td align="left">使用支持向量机的损失函数，Hinge Loss，二分类时使用</td>
</tr>
<tr>
<td align="left">multi:softmax</td>
<td align="left">使用softmax损失函数，多分类时使用</td>
</tr>
</tbody></table>
<p>并且允许自定义损失函数（但通常我们还是使用类已经设置好的损失函数）</p>
<h4 id="3-3-2-求解XGB的目标函数"><a href="#3-3-2-求解XGB的目标函数" class="headerlink" title="3.3.2 求解XGB的目标函数"></a>3.3.2 求解XGB的目标函数</h4><p>由于XGB迭代的是树，不是数字组成的向量，因此无法使用梯度下降，而是将目标函数转化为更简单的，与树结构直接相关的写法，以此来建立树的结构与模型的效果（泛化能力与运行速度）之间的直接联系，因为这种联系，XGB的目标函数又被称为“结构分数”。</p>
<p>首先，进行第一步转换：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/2200B3AF1AD249FD85F2101CC7F50213?method=download&shareKey=5ebe9bb0fea9178231e97a37e0f99383" alt></p>
<p>其中$g_i,h_i$分别是在损失函数$l(y_i^t,\hat y_i^{(t-1)})$上对$\hat y_i^{(t-1)}$所求的一阶倒数和二阶导数。</p>
<p>因此，我们的目标函数可以被转化为：</p>
<p>$$Obj = \sum_{i=1}^m[f_t(x_i)g_i+\frac{1}{2}(f_t(x_i))^2h_i]+\Omega (f_t)$$</p>
<p>这个式子中，$g_i,h_i$只与传统损失函数相关，核心的部分是我们需要决定的树$f_t$</p>
<h4 id="3-3-3-参数化决策树-f-k-x"><a href="#3-3-3-参数化决策树-f-k-x" class="headerlink" title="3.3.3 参数化决策树$f_k(x)$"></a>3.3.3 参数化决策树$f_k(x)$</h4><p>对于回归树，通常来说每个叶子节点上的预测值是这个叶子节点上所有样本的标签的均值，但XGB作为普通回归树的改进算法，在$\hat y$上却有所不同。</p>
<p>对于XGB来说，每个叶子节点上都会有一个预测分数，也称叶子权重，用$f_k(x)$或$w$来表示</p>
<p>当有多课树的时候，集成模型的回归结果就是所有树的预测分数之和，假设这个集成模型中共有K棵决策树，则整个模型在这个样本$i$上给出的预测结果为:<br>$$\hat y_i^{(k)}=\sum_k^Kf_k(x_i)$$</p>
<p>我们使用$q(x_i)$表示样本$x_i$所在的叶子节点，并且使用$w_{q(x_i)}$表示这个样本落到第$t$棵树上的第$q(x_i)$个叶子节点中所获得的分数，于是有：</p>
<p>$$f_t(x_i)=w_q(x_i)$$</p>
<p>设一棵树上总共包含了$T$个叶子节点，其中每个叶子节点的索引为$j$，则这个叶子节点上的样本权重是$w_j$，依据这个，我们定义模型的复杂度$\Omega(f)$为<br>$$\Omega(f)=\gamma T+正则项(Regularization)$$</p>
<h4 id="3-3-4-寻找最佳树结构：求解-w-与-T"><a href="#3-3-4-寻找最佳树结构：求解-w-与-T" class="headerlink" title="3.3.4 寻找最佳树结构：求解$w$与$T$"></a>3.3.4 寻找最佳树结构：求解$w$与$T$</h4><p>我们定义了树和树的复杂度表达式：</p>
<p>$$f_t(x_i)=w_q(x_i), \ \Omega(f_t)=\gamma T+\frac{1}{2}\lambda\sum_{j=1}^Tw_j^2$$</p>
<p>假设现在第$t$棵树的结构已经被确定为q,可以将树的结构代入我们的损失函数，来继续转化我们的目标函数。转化目标函数的目的是：建立树的结构（叶子节点的数量）与目标函数的大小之间的直接联系，以求出在第$t$次迭代中需要求解的最优树$f_t$。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/64A336827C294238BBE661A25CE488DF?method=download&shareKey=477b767da38b33f7f049ac795ad5f71a" alt></p>
<p>对于橙色框的转化<br><img src="https://note.youdao.com/yws/api/personal/file/14DEB79D037D47E69496EE06E38D9930?method=download&shareKey=2ba7a8c972206128b62f304ef25f46aa" alt></p>
<p>可以有：<br>$$\sum_{i=1}^m w_{q(x_i)} * g_i = w_{q(x_1)} * g_1 + w_{q(x_2)} * g_2+ w_{q(x_3)} * g_3$$<br>$$=w_1(g_1+g_2)+ w_2*g_3$$<br>$$=\sum_{j=1}^T(w_j\sum_{i\in I_j}g_i)$$</p>
<p>我们定义：<br>$$G_j = \sum_{i\in I_j}g_i, \ H_j = \sum_{i\in I_j}h_i$$</p>
<p>于是可以有：</p>
<p>$$Obj^{(t)}=\sum_{j=1}^T[w_jG_j+\frac{1}{2}w_j^2(H_j+\lambda)]+\gamma T$$</p>
<p>$$F^{*}(w_j)=w_jG_j+\frac{1}{2}w_j^2(H_j+\lambda)$$</p>
<p>其中每个$j$取值下都是一个以$w_j$为自变量的二次函数$F^{<em>}$，我们的目标追求是让$Obj$最小，只要单独每一个叶子$j$取值下的二次函数都最小。于是在$F^{</em>}$对$w_j$求导，让一阶导数等于0，可得：</p>
<p>$$\frac{\partial F^{*}(w_j)}{\partial w_j}=G_j+w_j(H_j+\lambda)$$<br>$$0=G_j+w_j(H_j+\lambda)$$<br>$$w_j = -\frac{G_j}{H_j+\lambda}$$</p>
<p>代入目标函数，则有：<br>$$Obj^{(t)}=\sum_{j=1}^T[-\frac{G_j}{H_j+\lambda} * G_j + \frac{1}{2}(-\frac{G_j}{H_j+\lambda})]+\gamma T$$<br>$$=\sum_{j=1}^T[-\frac{G_j^2}{H_j+\lambda}+\frac{1}{2} * \frac{G_j^2}{H_j+\lambda}]+\gamma T$$<br>$$=-\frac{1}{2}\sum_{j=1}^T\frac{G_j^2}{H_j+\lambda}+\gamma T$$</p>
<p>这样我们就建立了树的结构（叶子）和模型效果的直接联系</p>
<p>下面来看一个例子：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/9C5D143BEFCA42FC94E784306DFAA089?method=download&shareKey=5423ee0322a0c25fbdc19bfef02e51cb" alt></p>
<p>$$Obj = -(\frac{g_1^2}{h_1+\lambda}+\frac{g_4^2}{h_4+\lambda}+\frac{(g_2+g_3+g_5)^2}{h_2+h_3+h_5+\lambda})+3\gamma$$</p>
<h4 id="3-3-5-寻找最佳分枝：结构分数之差"><a href="#3-3-5-寻找最佳分枝：结构分数之差" class="headerlink" title="3.3.5 寻找最佳分枝：结构分数之差"></a>3.3.5 寻找最佳分枝：结构分数之差</h4><p>XGB使用贪婪算法，认为如果每片叶子都是最优的，则整体生成的树结构就是最优，可以避免枚举所有可能的树结构</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/40FD6184DB4342098CFA5C45D9053E81?method=download&shareKey=6fcc1916a4df5e8182cd835a0a0a20c0" alt></p>
<h4 id="3-3-6-让树停止生长：重要参数gamma"><a href="#3-3-6-让树停止生长：重要参数gamma" class="headerlink" title="3.3.6 让树停止生长：重要参数gamma"></a>3.3.6 让树停止生长：重要参数gamma</h4><p>$\gamma$是对梯度提升树影响最大的参数之一，让树停止生长</p>
<p>对于目标函数减小量的要求是：</p>
<p>$$\frac{1}{2}[\frac{G^2_L}{H_L+\lambda}+\frac{G^2_R}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}]&gt;\lambda$$</p>
<h3 id="3-4-Lightgbm"><a href="#3-4-Lightgbm" class="headerlink" title="3.4 Lightgbm"></a>3.4 Lightgbm</h3><p>传统的Boost算法需要对每一个特征扫描所有的样本点来选择最好的切分点，非常耗时。为了解决这种在大样本高纬度数据的环境下耗时问题，Lightgbm使用了两种解决办法</p>
<ol>
<li>GOSS (Gradient-based One-Side Sampling, 基于梯度的单边采样)，不是使用所有的样本点来计算梯度，而是对样本进行采样计算梯度</li>
<li>EFB（Exclusive Feature Bundling， 互斥特征捆绑）， 不是使用所有的特征来进行扫描获得最佳的切分点，而是将某些特征进行捆绑在一起来降低特征的维度，以减少寻找最佳切分点的耗时。 </li>
</ol>
<h4 id="3-4-1-GOSS算法"><a href="#3-4-1-GOSS算法" class="headerlink" title="3.4.1 GOSS算法"></a>3.4.1 GOSS算法</h4><p>每个样本的梯度对采样也提供了非常有用的信息，如果一个样本点的梯度小，那么该样本点的训练误差就小并且已经经过了很好的训练</p>
<p>输入：训练数据，迭代步数$d$，大梯度数据的采样率$a$,小梯度的数据采样率$b$，损失函数和弱学习器的类型；</p>
<p>输出：训练好的强学习器；</p>
<ol>
<li>根据样本点的梯度绝对值进行降序排序；</li>
<li>对排序后的结果选取前$a * 100%$的样本生成一个大梯度样本点的子集；</li>
<li>对剩下的样本$（1-a） * 100%$，随机选取$b * （1-a）* 100%$生成小梯度样本点的集合；</li>
<li>将大梯度样本和采样的小梯度样本合并；</li>
<li>将小梯度样本乘上一个权重系数$\frac{1-a}{b}$；</li>
<li>使用上述的采样方法训练一个新的弱学习器；</li>
<li>不断重复1-6步骤知道达到规定的迭代次数或者收敛</li>
</ol>
<p>通过GOSS算法，可以在不改变数据分布的前提下不损失学习器精度的同时大大减少模型的学习速率</p>
<h4 id="3-4-2-EFB算法"><a href="#3-4-2-EFB算法" class="headerlink" title="3.4.2 EFB算法"></a>3.4.2 EFB算法</h4><p>Lightgbm实现中不仅进行了数据采样，也进行了特征抽样。但是该特征抽样与一般不同，将互斥特征绑定在一起从而减少特征维度。</p>
<p>主要思想是，实际中高纬度数据往往都是稀疏数据，在稀疏特征空间中许多特征都是互斥的，可以基于直方图（histograms）的方法将互斥的特征捆绑形成一个特征，从而减少特征维度。</p>
<p>并且允许小部分的冲突，使得模型的性能被影响$O([(1-\gamma)n]^{-2/3})$,这里的$\gamma$是每个绑定的最大冲突率。</p>
<p>输入：特征F，最大冲突K，图G；<br>输出： 特征捆绑集合bundles;</p>
<ol>
<li>构造一个边带有权重的图，其权值对应于特征之间的总冲突；</li>
<li>通过特征在图中的度来降序排序特征</li>
<li>检查有序列表中的每个特征，并将其分配给具有小冲突的现有bunding或创建新bunding</li>
</ol>
<h4 id="3-4-3-合并互斥特征"><a href="#3-4-3-合并互斥特征" class="headerlink" title="3.4.3 合并互斥特征"></a>3.4.3 合并互斥特征</h4><p>Lightgbm关于互斥特征的合并用到了直方图（Histogram）算法。直方图算法的基本思想是先把连续的特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>
<p>由于基于直方图的算法存储的是离散的bins而不是连续的特征值，我们可以通过让互斥特征驻留在不同的bins中来构造feature bundle。这可以通过增加特征原始值的偏移量来实现。比如，假设我们有两个特征，特征A的取值范围是[0,10)，而特征B的取值范围是[0,20)，我们可以给特征B增加偏移量10，使得特征B的取值范围为[10, 30)，最后合并特征A和B，形成新的特征，取值范围为[0,30)来取代特征A和特征B。</p>
<p>当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；差一点的切分点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在Gradient Boosting的框架下没有太大的影响。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/BB4E003C937C441D80F12A44CEE7B01D?method=download&shareKey=6214970cf9c295e487ce3ed91422ef38" alt></p>
<h3 id="3-5-Boosting算法优缺点对比"><a href="#3-5-Boosting算法优缺点对比" class="headerlink" title="3.5 Boosting算法优缺点对比"></a>3.5 Boosting算法优缺点对比</h3><h4 id="3-5-1-XGBoost-vs-GBDT"><a href="#3-5-1-XGBoost-vs-GBDT" class="headerlink" title="3.5.1 XGBoost vs GBDT"></a>3.5.1 XGBoost vs GBDT</h4><p>1）GBDT以传统CART作为基分类器，而XGBoost支持线性分类器，相当于引入L1和L2正则化项的逻辑回归（分类问题）和线性回归（回归问题）；</p>
<p>2）GBDT在优化时只用到一阶导数，XGBoost对代价函数做了二阶Talor展开，引入了一阶导数和二阶导数。XGBoost支持自定义的损失函数，只要是能满足二阶连续可导的函数均可以作为损失函数；</p>
<p>3）XGBoost在损失函数中引入正则化项，用于控制模型的复杂度。正则化项包含全部叶子节点的个数，每个叶子节点输出的score的L2模的平方和。从Bias-variance tradeoff角度考虑，正则项降低了模型的方差，防止模型过拟合，这也是xgboost优于传统GBDT的一个特性。</p>
<p>4）当样本存在缺失值是，xgBoosting能自动学习分裂方向，即XGBoost对样本缺失值不敏感；</p>
<p>5）XGBoost借鉴RF的做法，支持列抽样，这样不仅能防止过拟合，还能降低计算，这也是xgboost异于传统gbdt的一个特性。</p>
<p>6）XGBoost在每次迭代之后，会将叶子节点的权重乘上一个学习率（相当于XGBoost中的eta，论文中的Shrinkage），主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点；</p>
<p>7）XGBoost工具支持并行，但并行不是tree粒度的并行，XGBoost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值），XGBoost的并行是在特征粒度上的。XGBoost在训练之前，预先对数据进行了排序，然后保存为(block)结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个块结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行；</p>
<p>8）可并行的近似直方图算法，树结点在进行分裂时，需要计算每个节点的增益，若数据量较大，对所有节点的特征进行排序，遍历的得到最优分割点，这种贪心法异常耗时，这时引进近似直方图算法，用于生成高效的分割点，即用分裂后的某种值减去分裂前的某种值，获得增益，为了限制树的增长，引入阈值，当增益大于阈值时，进行分裂；</p>
<h4 id="3-5-2-XGboost-vs-LightGBM"><a href="#3-5-2-XGboost-vs-LightGBM" class="headerlink" title="3.5.2 XGboost vs LightGBM"></a>3.5.2 XGboost vs LightGBM</h4><p>1）XGBoost采用预排序，在迭代之前，对结点的特征做预排序，遍历选择最优分割点，数据量大时，贪心法耗时，LightGBM方法采用histogram算法，占用的内存低，数据分割的复杂度更低，但是不能找到最精确的数据分割点；</p>
<p>2）XGBoost采用level-wise生成决策树策略，同时分裂同一层的叶子，从而进行多线程优化，不容易过拟合，但很多叶子节点的分裂增益较低，没必要进行更进一步的分裂，这就带来了不必要的开销；LightGBM采用leaf-wise生长策略，每次从当前叶子中选择增益最大的叶子进行分裂，如此循环，但会生长出更深的决策树，产生过拟合，因此 LightGBM 在leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合）。另一个比较巧妙的优化是 histogram 做差加速。一个容易观察到的现象：一个叶子的直方图可以由它的父亲节点的直方图与它兄弟的直方图做差得到。</p>
<h2 id="4-结合策略"><a href="#4-结合策略" class="headerlink" title="4 结合策略"></a>4 结合策略</h2><p>不同的结合策略也会影响集成模型性能，主要分为平均法、投票法和学习法，我们这里重点介绍学习法Stacking</p>
<h3 id="4-1-平均法"><a href="#4-1-平均法" class="headerlink" title="4.1 平均法"></a>4.1 平均法</h3><ul>
<li>简单平均法</li>
<li>加权平均法</li>
</ul>
<h3 id="4-2-投票法"><a href="#4-2-投票法" class="headerlink" title="4.2 投票法"></a>4.2 投票法</h3><ul>
<li>绝对多数投票法</li>
<li>相对多数投票法</li>
<li>加权投票法</li>
</ul>
<h3 id="4-3-学习法"><a href="#4-3-学习法" class="headerlink" title="4.3 学习法"></a>4.3 学习法</h3><p>当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合.Stacking是学习法的经典代表，这里我们吧个体学习器称为初级学习器，用于结合的学习器称为刺激学习器或元学习器。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/119ABC7D390F428F8A036B925FD7C6E8?method=download&shareKey=85e6961c6b845acd5fab61326ede0493" alt></p>
<p>次级学习器的输入属性表示和次级学习算法对Stacking集成的泛化性能有很大影响。研究表明，将初级学习器的输出类概率作为次级学习器的输入属性，用多响应线性回归（Multi-response Linear Regression，MLR）作为次级学算法效果较好。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习日志：2020智慧海洋建设top5方案学习</title>
    <url>/2020/05/30/My-New-Post/</url>
    <content><![CDATA[<h2 id="2020-5-30-赛题解读"><a href="#2020-5-30-赛题解读" class="headerlink" title="2020.5.30 赛题解读"></a>2020.5.30 赛题解读</h2><h3 id="赛题背景：渔船作业分类"><a href="#赛题背景：渔船作业分类" class="headerlink" title="赛题背景：渔船作业分类"></a>赛题背景：渔船作业分类</h3><p>本赛题基于位置数据对海上目标进行智能识别和作业行为分析，要求选手通过分析渔船北斗设备位置数据，得出该船的生产作业行为，具体判断出是拖网作业、围网作业还是流刺网作业。初赛将提供11000条(其中7000条训练数据、2000条testA、2000条testB)渔船轨迹北斗数据。</p>
<a id="more"></a>

<p>复赛考虑以往渔船在海上作业时主要依赖AIS数据，北斗相比AIS数据，数据上报频率和数据质量均低于AIS数据，因此复赛拟加入AIS轨迹数据辅助北斗数据更好的做渔船类型识别，其中AIS数据与北斗数据的匹配需选手自行实现，具体细节复赛开赛时更新。同时，希望选手通过数据可视化与分析，挖掘更多海洋通信导航设备的应用价值。</p>
<h3 id="竞赛数据"><a href="#竞赛数据" class="headerlink" title="竞赛数据:"></a>竞赛数据:</h3><p>提供11000条渔船北斗数据，数据包含脱敏后的渔船ID、经纬度坐标、上报时间、速度、航向信息，由于真实场景下海上环境复杂，经常出现信号丢失，设备故障等原因导致的上报坐标错误、上报数据丢失、甚至有些设备疯狂上报等。</p>
<p>数据示例：</p>
<table>
<thead>
<tr>
<th align="left">渔船ID</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">速度</th>
<th align="center">方向</th>
<th align="center">time</th>
<th align="right">type</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1102</td>
<td align="center">6283649.656204367</td>
<td align="center">5284013.963699763</td>
<td align="center">3</td>
<td align="center">12.1</td>
<td align="center">0921 09:00</td>
<td align="right">围网</td>
</tr>
</tbody></table>
<p>渔船ID：渔船的唯一识别，结果文件以此ID为标示</p>
<p>x: 渔船在平面坐标系的x轴坐标</p>
<p>y: 渔船在平面坐标系的y轴坐标</p>
<p>速度：渔船当前时刻航速，单位节</p>
<p>方向：渔船当前时刻航首向，单位度</p>
<p>time：数据上报时刻，单位月日 时：分</p>
<p>type：渔船label，作业类型</p>
<p>原始数据经过脱敏处理，渔船信息被隐去，坐标等信息精度和位置被转换偏移。<br>选手可通过学习围网、刺网、拖网等专业知识辅助大赛数据处理。<br>AIS数据</p>
<table>
<thead>
<tr>
<th align="left">ais_id</th>
<th align="center">lon</th>
<th align="center">lat</th>
<th align="center">速度</th>
<th align="center">航向</th>
<th align="right">time</th>
</tr>
</thead>
<tbody><tr>
<td align="left">110</td>
<td align="center">119.6705</td>
<td align="center">26.5938</td>
<td align="center">3</td>
<td align="center">12.1</td>
<td align="right">0921 09:00</td>
</tr>
</tbody></table>
<p>ais_id：AIS设备的唯一识别ID</p>
<h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>选手提交结果与实际渔船作业类型结果进行对比，以3种类别的各自F1值取平均做为评价指标，结果越大越好，具体计算公式如下：</p>
<p>$$Score ={F1_{围网}+F1_{刺网}+F1_{拖网}  \over 3}$$</p>
<p>$$F1 ={2\ast P\ast R\over P+R}$$</p>
<p>其中P为某类别的准确率，R为某类别的召回率，评测程序f1函数为sklearn.metrics.f1_score，average=’macro’。</p>
<h2 id="模型大致思路"><a href="#模型大致思路" class="headerlink" title="模型大致思路"></a>模型大致思路</h2><ul>
<li><p>将所有数据数据切入：速度等于0和非0，白天和黑夜，四个数据集对每艘船的速度，方向，xy进行统计。</p>
</li>
<li><p>采用TFIDF对速度和XY进行抽取特征并降维</p>
</li>
<li><p>采用自然语言思路对速度，xy进行嵌入</p>
</li>
<li><p>训练模型前采用Lightgbm进行初步的特征筛选</p>
</li>
<li><p>最后用Lightgbm进行模型训练</p>
</li>
</ul>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><strong>1. 按照同一个渔船id速度为0和非0两部分进行分析</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/5045B84827DC4E5B87F4E56EE349769F?method=download&shareKey=7afd0c781b27434a8a4595a52bbd0861" alt></p>
<p>思路：</p>
<p>1、针对同一艘渔船，将其数据分为 速度为0和非0两个部分。分别统计该船在速度为0 和 非0情况下做可视化分析，观察经纬度xy、方向direction这些原始特征的变化情况（均值、方差、极值、峰度、偏度等统计特征）</p>
<p>2、根据1构建的特征，原始特征被构造出一系列统计特征，一种含义的特征会被分成速度为0和非0情况。根据这个特点，对这些特征进行一个比值处理。</p>
<p><strong>2. 渔船在白天和黑夜会按照同一个渔船id白天和黑夜两部分进行分析</strong></p>
<p>早6点整至晚8点整设置为白天(图标识Day)</p>
<p>晚8点整至早6点整设置为黑夜(图标识Night)</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/5045B84827DC4E5B87F4E56EE349769F?method=download&shareKey=7afd0c781b27434a8a4595a52bbd0861" alt></p>
<p>思路：<br>1、    数据按照时间划分成白天和黑夜两部分，分别统计该船在不同时间做可视化分析，观察经纬度xy、方向direction这些原始特征的变化情况（均值、方差、极值、峰度、偏度等统计特征）</p>
<p>2、    根据1构造的两组时间特征，提取关键的速度speed、经纬度xy进行白天与黑夜特征的对比。</p>
<p><strong>3. 借鉴自然语言处理（NLP）角度去处理船的轨迹特征</strong></p>
<p>速度speed、经纬度xy按照作业时间排序，可以反映出每艘船的行为规律。而每种作业方式都有其内在的一些规律, 借鉴自然语言处理(NLP)的相关算法进行特征提取。利用nlp的算法对速度、经纬这些序列的学习，尝试挖掘出每艘船的行为特点。</p>
<p>思路一：TF-IDF + NMF(如图，从左到有分别是ngram=1, ngram=2,ngram=3，经过t-SNE降维的可视化结果)</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/BAC79B4C1B3440D6BFF6A1D51AC8A0FF?method=download&shareKey=16b799d9748d761fab551bec75914030" alt></p>
<p>1、    使用不同的ngram去处理每个渔船的速度、经纬度数据，提取出每艘船的TF-IDF特征（ngram=1, 2, 3）。</p>
<p>2、    并利用非负矩阵分解(NMF)算法，对处理后的速度、经纬度进行降维生成一个主题分布向量。（此题目分成了8类）。</p>
<p>3、    对每个渔船的主题分布向量进行T-SNE降维，进行可视化。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>该代码主要包括三个文件</p>
<ul>
<li>feature_selector.py 特征选择文件</li>
<li>nmf_list.py 处理轨迹文件</li>
<li>model.py 模型文件</li>
</ul>
<h3 id="1-feature-selector-py代码分析："><a href="#1-feature-selector-py代码分析：" class="headerlink" title="1. feature_selector.py代码分析："></a><strong>1. feature_selector.py代码分析：</strong></h3><pre><code># numpy and pandas for data manipulation
import pandas as pd
import numpy as np

# model used for feature importances
import lightgbm as lgb

# utility for early stopping with a validation set
from sklearn.model_selection import train_test_split

# visualizations
import matplotlib.pyplot as plt
import seaborn as sns

# memory management
import gc

# utilities
from itertools import chain
class FeatureSelector():
&quot;&quot;&quot;    
这个类用于为机器学习或数据预处理执行特征选择
实现五种不同的方法来识别要删除的特性
1、查找丢失百分比大于指定阈值的列
2、查找具有唯一值的列
3、找出相关系数大于指定相关系数的相关变量
4、从梯度增强机(gbm)中查找特性重要性为0.0的特性
5、从gbm中查找不影响指定的累积特性重要性的低重要性特性

参数
--------
data:dataframe
    一个数据集，行中有观察值，列中有特性
labels : array or series, default = None
    数组标签用于训练机器学习模型，以发现特征重要性。它们可以是二进制标签
    (如果任务是“分类”)或连续目标(如果任务是“回归”)。
    如果没有提供标签，那么基于特征重要性的方法是不可用的。

属性
--------
ops : dict
    运行的操作字典和要删除的特性
missing_stats : dataframe
    所有特征的缺失值的比例
record_missing : dataframe
    缺失值在阈值以上的特征的缺失值的比例
unique_stats: dataframe
    所有特性的唯一值的个数
record_single_unique: dataframe
    记录具有唯一值的特性
corr_matrix : dataframe
    数据中所有特征之间的所有相关性
record_collinear : dataframe
    记录相关系数高于阈值的相关变量对
feature_importances: dataframe
    从梯度增强机的所有特征的重要性
record_zero_importance: dataframe
    根据gbm记录数据中的零重要性特征
record_low_importance: dataframe
    根据gbm记录不需要达到累积重要性阈值的最低重要性特征

Notes
--------
    -所有5个操作都可以用identify_all方法运行。
    -如果使用特性重要度，则对创建新列的分类变量使用one-hot编码
&quot;&quot;&quot;
    def __init__(self, data, labels=None):            
        # 数据集和标签
        self.data = data
        self.labels = labels
        if labels is None:
            print(&apos;No labels provided. Feature importance based methods are not available.&apos;)    
        # 记录关于要删除的特性的信息    
        self.record_missing = None
        self.record_single_unique = None
        self.record_collinear = None
        self.record_zero_importance = None
        self.record_low_importance = None

        self.missing_stats = None
        self.unique_stats = None
        self.corr_matrix = None
        self.feature_importances = None
        # 用于保存删除操作的字典
        self.ops = {}

        self.one_hot_correlated = False

    def identify_missing(self, missing_threshold):

        # 找到丢失值大于&apos; missing_threshold &apos;的部分特征
        self.missing_threshold = missing_threshold
        # 计算每一列特征的缺失率
        missing_series = self.data.isnull().sum() / self.data.shape[0]
        self.missing_stats = pd.DataFrame(missing_series).rename(columns = {&apos;index&apos;: &apos;feature&apos;, 0: &apos;missing_fraction&apos;})
        # 将特征的缺失率排序
        self.missing_stats = self.missing_stats.sort_values(&apos;missing_fraction&apos;, ascending = False)
        #找到缺失百分比大于阈值的列
        record_missing = pd.DataFrame(missing_series[missing_series &gt; missing_threshold]).reset_index().rename(columns = 
                                                                                                                   {&apos;index&apos;: &apos;feature&apos;, 
                                                                                                                    0: &apos;missing_fraction&apos;})
        to_drop = list(record_missing[&apos;feature&apos;])
        self.record_missing = record_missing
        self.ops[&apos;missing&apos;] = to_drop

        print(&apos;%d features with greater than %0.2f missing values.\n&apos; % (len(self.ops[&apos;missing&apos;]), self.missing_threshold))

    def identify_single_unique(self):
    # 查找只有一个唯一值的特征

        # 计算每个列中的惟一计数
        unique_counts = self.data.nunique()
        self.unique_stats = pd.DataFrame(unique_counts).rename(columns = {&apos;index&apos;: &apos;feature&apos;, 0: &apos;nunique&apos;})
        self.unique_stats = self.unique_stats.sort_values(&apos;nunique&apos;, ascending = True)

        # 查找只有惟一计数的列
        record_single_unique = pd.DataFrame(unique_counts[unique_counts == 1]).reset_index().rename(columns = {&apos;index&apos;: &apos;feature&apos;, 
                                                                                                               0: &apos;nunique&apos;})
        to_drop = list(record_single_unique[&apos;feature&apos;])
        self.record_single_unique = record_single_unique
        self.ops[&apos;single_unique&apos;] = to_drop
        print(&apos;%d features with a single unique value.\n&apos; % len(self.ops[&apos;single_unique&apos;]))

    def identify_collinear(self, correlation_threshold, one_hot=False):
        &quot;&quot;&quot;
        找寻相关系数大于“correlation_threshold”的特征并删除

        参数
        --------
        correlation_threshold : float between 0 and 1
        one_hot : boolean, default = False
        &quot;&quot;&quot;
        self.correlation_threshold = correlation_threshold
        self.one_hot_correlated = one_hot
        # 计算每一列之间的相关性
        if one_hot:

            # one_hot编码
            features = pd.get_dummies(self.data)
            self.one_hot_features = [column for column in features.columns if column not in self.base_features]

            # 向原始数据添加一个热编码数据
            self.data_all = pd.concat([features[self.one_hot_features], self.data], axis = 1)

            corr_matrix = pd.get_dummies(features).corr()

        else:
            corr_matrix = self.data.corr()

        self.corr_matrix = corr_matrix

        # 提取关联矩阵的上三角
        upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k = 1).astype(np.bool))

        # 选择相关性高于阈值的特性
         # 需要使用绝对值
        to_drop = [column for column in upper.columns if any(upper[column].abs() &gt; correlation_threshold)]

        # 保存线性相关特征
        record_collinear = pd.DataFrame(columns = [&apos;drop_feature&apos;, &apos;corr_feature&apos;, &apos;corr_value&apos;])

        # 遍历列以删除相关特性对
        for column in to_drop:

            # 找出相关特征
            corr_features = list(upper.index[upper[column].abs() &gt; correlation_threshold])

            # 找出相关系数
            corr_values = list(upper[column][upper[column].abs() &gt; correlation_threshold])
            drop_features = [column for _ in range(len(corr_features))]

            # 记录信息(现在需要一个临时df)
            temp_df = pd.DataFrame.from_dict({&apos;drop_feature&apos;: drop_features,
                                                 &apos;corr_feature&apos;: corr_features,
                                                 &apos;corr_value&apos;: corr_values})

            #添加到dataframe
            record_collinear = record_collinear.append(temp_df, ignore_index = True)

        self.record_collinear = record_collinear
        self.ops[&apos;collinear&apos;] = to_drop

        print(&apos;%d features with a correlation magnitude greater than %0.2f.\n&apos; % (len(self.ops[&apos;collinear&apos;]), self.correlation_threshold))

    def identify_zero_importance(self, task, eval_metric=None, 
                                 n_iterations=10, early_stopping = True):
        &quot;&quot;&quot;
        根据梯度增强机识别零重要性的特征。
        gbm可以使用验证集进行早期停止训练，以防止过拟合。
        在“n_iteration”上对特征重要性求平均值以减少方差。

        参数 
        --------
        eval_metric : string
            评价指标用于梯度提升机的早期停止，如果&apos; early_stopped &apos;为真，则必须提供
        task : string
            机器学习任务，是“classification”还是“regression”
        n_iterations : int, default = 10
            gbm的训练迭代次数
        early_stopping : boolean, default = True
            是否在训练时使用提前停止与验证集

        Notes
        --------
            - 在训练前热编码特征
            - gbm没有针对任何特定任务进行优化，可能需要进行一些超参数调优
            - 特性重要性，包括零重要性特性，可以在运行过程中改变
        &quot;&quot;&quot;
        if early_stopping and eval_metric is None:
            raise ValueError(&quot;&quot;&quot;eval metric must be provided with early stopping. Examples include &quot;auc&quot; for classification or
                             &quot;l2&quot; for regression.&quot;&quot;&quot;)
        if self.labels is None:
             raise ValueError(&quot;No training labels provided.&quot;)
        # 热编码特征
        features = pd.get_dummies(self.data)
        self.one_hot_features = [column for column in features.columns if column not in self.base_features]

        # 将热编码数据添加到原始数据中
        self.data_all = pd.concat([features[self.one_hot_features], self.data], axis = 1)

        # 提取特征名字
        feature_names = list(features.columns)

        # 转换成np array
        features = np.array(features)
        labels = np.array(self.labels).reshape((-1, ))

        # 创建特征重要性数组
        feature_importance_values = np.zeros(len(feature_names))

        print(&apos;Training Gradient Boosting Model\n&apos;)

        # 在每折中迭代
        for _ in range(n_iterations):
            if task == &apos;classification&apos;:
                model = lgb.LGBMClassifier(n_estimators=1000, learning_rate = 0.05, verbose = -1)

            elif task == &apos;regression&apos;:
                model = lgb.LGBMRegressor(n_estimators=1000, learning_rate = 0.05, verbose = -1)
            else:
                raise ValueError(&apos;Task must be either &quot;classification&quot; or &quot;regression&quot;&apos;)

            # 如果使用早期停止训练需要一个验证集
            if early_stopping:
                train_features, valid_features, train_labels, valid_labels = train_test_split(features, labels, test_size = 0.15, stratify=labels)
                # 使用早停机制训练模型
                model.fit(train_features, train_labels, eval_metric = eval_metric,
                              eval_set = [(valid_features, valid_labels)],
                              early_stopping_rounds = 100, verbose = -1)
                # 清空内存
                gc.enable()
                del train_features, train_labels, valid_features, valid_labels
                gc.collect()
            else:
                model.fit(features, labels)

            # 记录特征重要性
            feature_importance_values += model.feature_importances_ / n_iterations

        feature_importances = pd.DataFrame({&apos;feature&apos;: feature_names, &apos;importance&apos;: feature_importance_values})

        # 根据特征重要性排序
        feature_importances = feature_importances.sort_values(&apos;importance&apos;, ascending = False).reset_index(drop = True)

        # 归一化特征重要性
        feature_importances[&apos;normalized_importance&apos;] = feature_importances[&apos;importance&apos;] / feature_importances[&apos;importance&apos;].sum()
        feature_importances[&apos;cumulative_importance&apos;] = np.cumsum(feature_importances[&apos;normalized_importance&apos;])

        # 提取特征重要性为0的特征
        record_zero_importance = feature_importances[feature_importances[&apos;importance&apos;] == 0.0]

        to_drop = list(record_zero_importance[&apos;feature&apos;])

        self.feature_importances = feature_importances
        self.record_zero_importance = record_zero_importance
        self.ops[&apos;zero_importance&apos;] = to_drop

        print(&apos;\n%d features with zero importance after one-hot encoding.\n&apos; % len(self.ops[&apos;zero_importance&apos;]))

    def identify_low_importance(self, cumulative_importance):
        &quot;&quot;&quot;
        找到特征重要性低于“cumulative_importance”的特征

        参数
        --------
        cumulative_importance : float between 0 and 1
            重要性分数
        &quot;&quot;&quot;
        self.cumulative_importance = cumulative_importance

        # 特征重要性需要在运行之前计算
        if self.feature_importances is None:
            raise NotImplementedError(&quot;&quot;&quot;Feature importances have not yet been determined. 
                                     Call the `identify_zero_importance` method first.&quot;&quot;&quot;)

        # 将特征重要性排序
        self.feature_importances = self.feature_importances.sort_values(&apos;cumulative_importance&apos;)

        # 识别出特征重要性低于设定阈值的特征
        record_low_importance = self.feature_importances[self.feature_importances[&apos;cumulative_importance&apos;] &gt; cumulative_importance]

        to_drop = list(record_low_importance[&apos;feature&apos;])

        self.record_low_importance = record_low_importance
        self.ops[&apos;low_importance&apos;] = to_drop

        print(&apos;%d features required for cumulative importance of %0.2f after one hot encoding.&apos; % (len(self.feature_importances) -
                                                                            len(self.record_low_importance), self.cumulative_importance))
        print(&apos;%d features do not contribute to cumulative importance of %0.2f.\n&apos; % (len(self.ops[&apos;low_importance&apos;]),
                                                                                               self.cumulative_importance))

    def identify_all(self, selection_params):
        &quot;&quot;&quot;
        使用所有五种方法来删除不需要的特征

        参数
        --------
        selection_params : dict
            在五种特征选择方法中使用的参数。
            参数必须包含键[&apos;missing_threshold&apos;， &apos;correlation_threshold&apos;， &apos;eval_metric&apos;， &apos;task&apos;， &apos; collecative_importance &apos;]

        # 检查所必要的参数
        for param in [&apos;missing_threshold&apos;, &apos;correlation_threshold&apos;, &apos;eval_metric&apos;, &apos;task&apos;, &apos;cumulative_importance&apos;]:
            if param not in selection_params.keys():
                raise ValueError(&apos;%s is a required parameter for this method.&apos; % param)

        # 实现五种方法
        self.identify_missing(selection_params[&apos;missing_threshold&apos;])
        self.identify_single_unique()
        self.identify_collinear(selection_params[&apos;correlation_threshold&apos;])
        self.identify_zero_importance(task = selection_params[&apos;task&apos;], eval_metric = selection_params[&apos;eval_metric&apos;])
        self.identify_low_importance(selection_params[&apos;cumulative_importance&apos;])

        # 查找要删除的特性的数量
        self.all_identified = set(list(chain(*list(self.ops.values()))))
        self.n_identified = len(self.all_identified)

        print(&apos;%d total features out of %d identified for removal after one-hot encoding.\n&apos; % (self.n_identified, 
                                                                                                  self.data_all.shape[1]))

     def check_removal(self, keep_one_hot=True):
         &quot;&quot;&quot;
         在删除前检查已识别的特征。返回一个列表的独特的功能识别。
         &quot;&quot;&quot;
        self.all_identified = set(list(chain(*list(self.ops.values()))))
        print(&apos;Total of %d features identified for removal&apos; % len(self.all_identified))

        if not keep_one_hot:
            if self.one_hot_features is None:
                print(&apos;Data has not been one-hot encoded&apos;)
            else:
                one_hot_to_remove = [x for x in self.one_hot_features if x not in self.all_identified]
                print(&apos;%d additional one-hot features can be removed&apos; % len(one_hot_to_remove))

        return list(self.all_identified)

    def remove(self, methods, keep_one_hot = True):
        &quot;&quot;&quot;
        根据指定的方法从数据中删除特征。

        参数
        --------
            methods : &apos;all&apos; or list of methods
                可以是[&apos;missing&apos;， &apos;single_unique&apos;， &apos;collinear&apos;， &apos;zero_importance&apos;， &apos;low_importance&apos;]
            keep_one_hot : boolean, default = True
                是否热编码

        返回
        --------
            data : dataframe
                删除了特征的数据

        Notes 
        --------
            -如果使用特性重要度，则一个热编码列将被添加到数据中(然后可能被删除)
            -在转换数据之前，检查将被删除的功能!
        features_to_drop = []

        if methods == &apos;all&apos;:

            # 热编码数据
            data = self.data_all

            print(&apos;{} methods have been run\n&apos;.format(list(self.ops.keys())))

            # 找到需要删除的特征
            features_to_drop = set(list(chain(*list(self.ops.values()))))

        else:
            # Need to use one-hot encoded data as well
            if &apos;zero_importance&apos; in methods or &apos;low_importance&apos; in methods or self.one_hot_correlated:
                data = self.data_all

            else:
                data = self.data

            # 遍历指定方法
            for method in methods:
                # 确定方法已经在运行
                if method not in self.ops.keys():
                    raise NotImplementedError(&apos;%s method has not been run&apos; % method)

                # 添加要删除的方法
                else:
                    features_to_drop.append(self.ops[method])

            # 找到要删除的特征
            features_to_drop = set(list(chain(*features_to_drop)))

        features_to_drop = list(features_to_drop)

        if not keep_one_hot:

            if self.one_hot_features is None:
                print(&apos;Data has not been one-hot encoded&apos;)
            else:

                features_to_drop = list(set(features_to_drop) | set(self.one_hot_features))

        # 在原数据中删除特征
        data = data.drop(columns = features_to_drop)
        self.removed_features = features_to_drop

        if not keep_one_hot:
            print(&apos;Removed %d features including one-hot features.&apos; % len(features_to_drop))
         else:
            print(&apos;Removed %d features.&apos; % len(features_to_drop))

        return data

    # 各种绘图函数
    def plot_missing(self):
        &quot;&quot;&quot;Histogram of missing fraction in each feature&quot;&quot;&quot;
        if self.record_missing is None:
            raise NotImplementedError(&quot;Missing values have not been calculated. Run `identify_missing`&quot;)

        self.reset_plot()

        # Histogram of missing values
        plt.style.use(&apos;seaborn-white&apos;)
        plt.figure(figsize = (7, 5))
        plt.hist(self.missing_stats[&apos;missing_fraction&apos;], bins = np.linspace(0, 1, 11), edgecolor = &apos;k&apos;, color = &apos;red&apos;, linewidth = 1.5)
        plt.xticks(np.linspace(0, 1, 11));
        plt.xlabel(&apos;Missing Fraction&apos;, size = 14); plt.ylabel(&apos;Count of Features&apos;, size = 14); 
        plt.title(&quot;Fraction of Missing Values Histogram&quot;, size = 16);


    def plot_unique(self):
        &quot;&quot;&quot;Histogram of number of unique values in each feature&quot;&quot;&quot;
        if self.record_single_unique is None:
            raise NotImplementedError(&apos;Unique values have not been calculated. Run `identify_single_unique`&apos;)

        self.reset_plot()

        # Histogram of number of unique values
        self.unique_stats.plot.hist(edgecolor = &apos;k&apos;, figsize = (7, 5))
        plt.ylabel(&apos;Frequency&apos;, size = 14); plt.xlabel(&apos;Unique Values&apos;, size = 14); 
        plt.title(&apos;Number of Unique Values Histogram&apos;, size = 16);


    def plot_collinear(self, plot_all = False):
        &quot;&quot;&quot;
        Heatmap of the correlation values. If plot_all = True plots all the correlations otherwise
        plots only those features that have a correlation above the threshold

        Notes
        --------
            - Not all of the plotted correlations are above the threshold because this plots
            all the variables that have been idenfitied as having even one correlation above the threshold
            - The features on the x-axis are those that will be removed. The features on the y-axis
            are the correlated features with those on the x-axis

        Code adapted from https://seaborn.pydata.org/examples/many_pairwise_correlations.html
        &quot;&quot;&quot;

        if self.record_collinear is None:
            raise NotImplementedError(&apos;Collinear features have not been idenfitied. Run `identify_collinear`.&apos;)

        if plot_all:
            corr_matrix_plot = self.corr_matrix
            title = &apos;All Correlations&apos;

        else:
            # Identify the correlations that were above the threshold
            # columns (x-axis) are features to drop and rows (y_axis) are correlated pairs
            corr_matrix_plot = self.corr_matrix.loc[list(set(self.record_collinear[&apos;corr_feature&apos;])), 
                                                    list(set(self.record_collinear[&apos;drop_feature&apos;]))]

            title = &quot;Correlations Above Threshold&quot;


        f, ax = plt.subplots(figsize=(10, 8))

        # Diverging colormap
        cmap = sns.diverging_palette(220, 10, as_cmap=True)

        # Draw the heatmap with a color bar
        sns.heatmap(corr_matrix_plot, cmap=cmap, center=0,
                    linewidths=.25, cbar_kws={&quot;shrink&quot;: 0.6})

        # Set the ylabels 
        ax.set_yticks([x + 0.5 for x in list(range(corr_matrix_plot.shape[0]))])
        ax.set_yticklabels(list(corr_matrix_plot.index), size = int(160 / corr_matrix_plot.shape[0]));

        # Set the xlabels 
        ax.set_xticks([x + 0.5 for x in list(range(corr_matrix_plot.shape[1]))])
        ax.set_xticklabels(list(corr_matrix_plot.columns), size = int(160 / corr_matrix_plot.shape[1]));
        plt.title(title, size = 14)

    def plot_feature_importances(self, plot_n = 15, threshold = None):
        &quot;&quot;&quot;
        Plots `plot_n` most important features and the cumulative importance of features.
        If `threshold` is provided, prints the number of features needed to reach `threshold` cumulative importance.

        Parameters
        --------

        plot_n : int, default = 15
            Number of most important features to plot. Defaults to 15 or the maximum number of features whichever is smaller

        threshold : float, between 0 and 1 default = None
            Threshold for printing information about cumulative importances

        &quot;&quot;&quot;

        if self.record_zero_importance is None:
            raise NotImplementedError(&apos;Feature importances have not been determined. Run `idenfity_zero_importance`&apos;)

        # Need to adjust number of features if greater than the features in the data
        if plot_n &gt; self.feature_importances.shape[0]:
            plot_n = self.feature_importances.shape[0] - 1

        self.reset_plot()

        # Make a horizontal bar chart of feature importances
        plt.figure(figsize = (10, 6))
        ax = plt.subplot()

        # Need to reverse the index to plot most important on top
        # There might be a more efficient method to accomplish this
        ax.barh(list(reversed(list(self.feature_importances.index[:plot_n]))), 
                self.feature_importances[&apos;normalized_importance&apos;][:plot_n], 
                align = &apos;center&apos;, edgecolor = &apos;k&apos;)

        # Set the yticks and labels
        ax.set_yticks(list(reversed(list(self.feature_importances.index[:plot_n]))))
        ax.set_yticklabels(self.feature_importances[&apos;feature&apos;][:plot_n], size = 12)

        # Plot labeling
        plt.xlabel(&apos;Normalized Importance&apos;, size = 16); plt.title(&apos;Feature Importances&apos;, size = 18)
        plt.show()

        # Cumulative importance plot
        plt.figure(figsize = (6, 4))
        plt.plot(list(range(1, len(self.feature_importances) + 1)), self.feature_importances[&apos;cumulative_importance&apos;], &apos;r-&apos;)
        plt.xlabel(&apos;Number of Features&apos;, size = 14); plt.ylabel(&apos;Cumulative Importance&apos;, size = 14); 
        plt.title(&apos;Cumulative Feature Importance&apos;, size = 16);

        if threshold:

            # Index of minimum number of features needed for cumulative importance threshold
            # np.where returns the index so need to add 1 to have correct number
            importance_index = np.min(np.where(self.feature_importances[&apos;cumulative_importance&apos;] &gt; threshold))
            plt.vlines(x = importance_index + 1, ymin = 0, ymax = 1, linestyles=&apos;--&apos;, colors = &apos;blue&apos;)
            plt.show();

            print(&apos;%d features required for %0.2f of cumulative importance&apos; % (importance_index + 1, threshold))

    def reset_plot(self):
        plt.rcParams = plt.rcParamsDefault</code></pre><h3 id="2-nmf-list-py-代码分析："><a href="#2-nmf-list-py-代码分析：" class="headerlink" title="2. nmf_list.py 代码分析："></a><strong>2. nmf_list.py 代码分析：</strong></h3><pre><code>import pickle
import numpy as np
import pandas as pd
from collections import Counter
from sklearn.decomposition import NMF
from sklearn.preprocessing import LabelEncoder
from sklearn.feature_extraction.text import TfidfVectorizer
import tqdm
from gensim.models import FastText, Word2Vec
import multiprocessing

class nmf_list(object):
    def __init__(self,data,by_name,to_list,nmf_n,top_n):
        self.data = data
        self.by_name = by_name
        self.to_list = to_list
        self.nmf_n = nmf_n
        self.top_n = top_n

    def run(self,tf_n):
        df_all = self.data.groupby(self.by_name)[self.to_list].apply(lambda x :&apos;|&apos;.join(x)).reset_index()
        self.data =df_all.copy()

        print(&apos;bulid word_fre&apos;)
    # 词频的构建
    def word_fre(x):
        word_dict = []
        x = x.split(&apos;|&apos;)
        docs = []
        for doc in x:
            doc = doc.split()
            docs.append(doc)
            word_dict.extend(doc)
        word_dict = Counter(word_dict)
        new_word_dict = {}
        for key,value in word_dict.items():
            new_word_dict[key] = [value,0]
        del word_dict  
        del x
        for doc in docs:
            doc = Counter(doc)
            for word in doc.keys():
                new_word_dict[word][1] += 1
        return new_word_dict 
    self.data[&apos;word_fre&apos;] = self.data[self.to_list].apply(word_fre)

    print(&apos;bulid top_&apos; + str(self.top_n))
    # 设定100个高频词
    def top_100(word_dict):
        return sorted(word_dict.items(),key = lambda x:(x[1][1],x[1][0]),reverse = True)[:self.top_n]
    self.data[&apos;top_&apos;+str(self.top_n)] = self.data[&apos;word_fre&apos;].apply(top_100)
    def top_100_word(word_list):
        words = []
        for i in word_list:
            i = list(i)
            words.append(i[0])
        return words 
    self.data[&apos;top_&apos;+str(self.top_n)+&apos;_word&apos;] = self.data[&apos;top_&apos; + str(self.top_n)].apply(top_100_word)
    # print(&apos;top_&apos;+str(self.top_n)+&apos;_word的shape&apos;)
    print(self.data.shape)

    word_list = []
    for i in self.data[&apos;top_&apos;+str(self.top_n)+&apos;_word&apos;].values:
        word_list.extend(i)
    word_list = Counter(word_list)
    word_list = sorted(word_list.items(),key = lambda x:x[1],reverse = True)
    user_fre = []
    for i in word_list:
        i = list(i)
        user_fre.append(i[1]/self.data[self.by_name].nunique())
    stop_words = []
    for i,j in zip(word_list,user_fre):
        if j&gt;0.5:
            i = list(i)
            stop_words.append(i[0])

    print(&apos;start title_feature&apos;)
    # 讲融合后的taglist当作一句话进行文本处理
    self.data[&apos;title_feature&apos;] = self.data[self.to_list].apply(lambda x: x.split(&apos;|&apos;))
    self.data[&apos;title_feature&apos;] = self.data[&apos;title_feature&apos;].apply(lambda line: [w for w in line if w not in stop_words])
    self.data[&apos;title_feature&apos;] = self.data[&apos;title_feature&apos;].apply(lambda x: &apos; &apos;.join(x))

    print(&apos;start NMF&apos;)
    # 使用tfidf对元素进行处理
    tfidf_vectorizer = TfidfVectorizer(ngram_range=(tf_n,tf_n))
    tfidf = tfidf_vectorizer.fit_transform(self.data[&apos;title_feature&apos;].values)
    #使用nmf算法，提取文本的主题分布
    text_nmf = NMF(n_components=self.nmf_n).fit_transform(tfidf)


    # 整理并输出文件
    name = [str(tf_n) + self.to_list + &apos;_&apos; +str(x) for x in range(1,self.nmf_n+1)]
    tag_list = pd.DataFrame(text_nmf)
    print(tag_list.shape)
    tag_list.columns = name
    tag_list[self.by_name] = self.data[self.by_name]
    column_name = [self.by_name] + name
    tag_list = tag_list[column_name]
    return tag_list</code></pre><h3 id="3-model-py-代码分析："><a href="#3-model-py-代码分析：" class="headerlink" title="3. model.py  代码分析："></a><strong>3. model.py  代码分析：</strong></h3><pre><code>import gc
import pandas as pd
import numpy as np
import os
import time
import lightgbm as lgb
from copy import deepcopy
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import f1_score
from sklearn import metrics
from sklearn.metrics import precision_recall_fscore_support
import warnings
from glob import glob
from scipy.sparse import csr_matrix

start_t = time.time()
print(&apos;ww_900_start&apos;)
pd.set_option(&apos;display.max_columns&apos;, 100)
warnings.filterwarnings(&apos;ignore&apos;)

# 添加需要提取的特征
def group_feature(df, key, target, aggs,flag):   
    agg_dict = {}
    for ag in aggs:
        agg_dict[&apos;{}_{}_{}&apos;.format(target,ag,flag)] = ag
    print(agg_dict)
    t = df.groupby(key)[target].agg(agg_dict).reset_index()
    return t

# 计算两个经纬度之间的haversine距离
def haversine_dist(lat1,lng1,lat2,lng2):
    lat1, lng1, lat2, lng2 = map(np.radians, (lat1, lng1, lat2, lng2))
    radius = 6371  # Earth&apos;s radius taken from google
    lat = lat2 - lat1
    lng = lng2 - lng1
    d = np.sin(lat/2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(lng/2) ** 2
    h = 2 * radius * np.arcsin(np.sqrt(d))
    return h

# 提取特征
def extract_feature(df, train, flag):

    if (flag == &apos;on_night&apos;) or (flag == &apos;on_day&apos;): 
        t = group_feature(df, &apos;ship&apos;,&apos;speed&apos;,[&apos;max&apos;,&apos;mean&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
        train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;)

    if flag == &quot;0&quot;:
        t = group_feature(df, &apos;ship&apos;,&apos;direction&apos;,[&apos;max&apos;,&apos;median&apos;,&apos;mean&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
        train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;) 

    elif flag == &quot;1&quot;:
        t = group_feature(df, &apos;ship&apos;,&apos;speed&apos;,[&apos;max&apos;,&apos;mean&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
        train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;)
        t = group_feature(df, &apos;ship&apos;,&apos;direction&apos;,[&apos;max&apos;,&apos;median&apos;,&apos;mean&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
        train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;) 
        hour_nunique = df.groupby(&apos;ship&apos;)[&apos;speed&apos;].nunique().to_dict()
        train[&apos;speed_nunique_{}&apos;.format(flag)] = train[&apos;ship&apos;].map(hour_nunique)   
        hour_nunique = df.groupby(&apos;ship&apos;)[&apos;direction&apos;].nunique().to_dict()
        train[&apos;direction_nunique_{}&apos;.format(flag)] = train[&apos;ship&apos;].map(hour_nunique)  

    t = group_feature(df, &apos;ship&apos;,&apos;x&apos;,[&apos;max&apos;,&apos;min&apos;,&apos;mean&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
    train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;)
    t = group_feature(df, &apos;ship&apos;,&apos;y&apos;,[&apos;max&apos;,&apos;min&apos;,&apos;mean&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
    train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;)
    t = group_feature(df, &apos;ship&apos;,&apos;base_dis_diff&apos;,[&apos;max&apos;,&apos;min&apos;,&apos;mean&apos;,&apos;std&apos;,&apos;skew&apos;],flag)
    train = pd.merge(train, t, on=&apos;ship&apos;, how=&apos;left&apos;)

    train[&apos;x_max_x_min_{}&apos;.format(flag)] = train[&apos;x_max_{}&apos;.format(flag)] - train[&apos;x_min_{}&apos;.format(flag)]
    train[&apos;y_max_y_min_{}&apos;.format(flag)] = train[&apos;y_max_{}&apos;.format(flag)] - train[&apos;y_min_{}&apos;.format(flag)]
    train[&apos;y_max_x_min_{}&apos;.format(flag)] = train[&apos;y_max_{}&apos;.format(flag)] - train[&apos;x_min_{}&apos;.format(flag)]
    train[&apos;x_max_y_min_{}&apos;.format(flag)] = train[&apos;x_max_{}&apos;.format(flag)] - train[&apos;y_min_{}&apos;.format(flag)]
    train[&apos;slope_{}&apos;.format(flag)] = train[&apos;y_max_y_min_{}&apos;.format(flag)] / np.where(train[&apos;x_max_x_min_{}&apos;.format(flag)]==0, 0.001, train[&apos;x_max_x_min_{}&apos;.format(flag)])
    train[&apos;area_{}&apos;.format(flag)] = train[&apos;x_max_x_min_{}&apos;.format(flag)] * train[&apos;y_max_y_min_{}&apos;.format(flag)]

    mode_hour = df.groupby(&apos;ship&apos;)[&apos;hour&apos;].agg(lambda x:x.value_counts().index[0]).to_dict()
    train[&apos;mode_hour_{}&apos;.format(flag)] = train[&apos;ship&apos;].map(mode_hour)
    train[&apos;slope_median_{}&apos;.format(flag)] = train[&apos;y_median_{}&apos;.format(flag)] / np.where(train[&apos;x_median_{}&apos;.format(flag)]==0, 0.001, train[&apos;x_median_{}&apos;.format(flag)])

    return train

# 提取数据
def get_data(files, is_sort=True, sort_column=&quot;time&quot;):
    datas = [pd.read_csv(f) for f in files]
    if is_sort:
        dfs = [df.sort_values(by=sort_column, ascending=True, na_position=&apos;last&apos;) for df in datas]
    df = pd.concat(datas, axis=0, ignore_index=True)
    return df

# 处理提取文件数据
def extract_dt(df):
    df[&apos;time&apos;] = pd.to_datetime(df[&apos;time&apos;], format=&apos;%m%d %H:%M:%S&apos;)
    df[&apos;date&apos;] = df[&apos;time&apos;].dt.date
    df[&apos;hour&apos;] = df[&apos;time&apos;].dt.hour

    df[&apos;x_dis_diff&apos;] = (df[&apos;x&apos;] - 6165599).abs()
    df[&apos;y_dis_diff&apos;] = (df[&apos;y&apos;] - 5202660).abs()
    df[&apos;base_dis_diff&apos;] = ((df[&apos;x_dis_diff&apos;]**2)+(df[&apos;y_dis_diff&apos;]**2))**0.5    
    del df[&apos;x_dis_diff&apos;],df[&apos;y_dis_diff&apos;]    

    df[&quot;x&quot;] = df[&quot;x&quot;] / 1e6
    df[&quot;y&quot;] = df[&quot;y&quot;] / 1e6    
    df[&apos;day_nig&apos;] = 0
    df.loc[(df[&apos;hour&apos;] &gt; 5) &amp; (df[&apos;hour&apos;] &lt; 20),&apos;day_nig&apos;] = 1
    return df

train_files = glob(&quot;tcdata/hy_round2_train_20200225/*.csv&quot;)
test_files = glob(&quot;tcdata/hy_round2_testB_20200312/*.csv&quot;)
train_files = sorted(train_files)
test_files = sorted(test_files)

train = get_data(train_files)
train.columns = [&apos;ship&apos;,&apos;x&apos;,&apos;y&apos;,&apos;speed&apos;,&apos;direction&apos;,&apos;time&apos;,&apos;type&apos;]
test = get_data(test_files)
test.columns = [&apos;ship&apos;,&apos;x&apos;,&apos;y&apos;,&apos;speed&apos;,&apos;direction&apos;,&apos;time&apos;]

train = extract_dt(train)
test = extract_dt(test)
train_label = train.drop_duplicates([&apos;ship&apos;],keep = &apos;first&apos;)
test_label = test.drop_duplicates([&apos;ship&apos;],keep = &apos;first&apos;)
train_label[&apos;type&apos;] = train_label[&apos;type&apos;].map({&apos;围网&apos;:0,&apos;刺网&apos;:1,&apos;拖网&apos;:2})

num = train_label.shape[0]
data_label = train_label.append(test_label)
data =train.append(test)
# 将数据分成speed为0和非0、白天和晚上
data_1 = data[data[&apos;speed&apos;]==0]
data_2 = data[data[&apos;speed&apos;]!=0]
data_label = extract_feature(data_1, data_label,&quot;0&quot;)
data_label = extract_feature(data_2, data_label,&quot;1&quot;)

data_1 = data[data[&apos;day_nig&apos;] == 0]
data_2 = data[data[&apos;day_nig&apos;] == 1]
data_label = extract_feature(data_1, data_label,&quot;on_night&quot;)
data_label = extract_feature(data_2, data_label,&quot;on_day&quot;)

# 读取NMF降维后的特征
if os.path.isfile(&apos;nmf_testb.csv&apos;):
    nmf_fea = pd.read_csv(&apos;nmf_testb.csv&apos;)
    data_label = data_label.merge(nmf_fea,on=&apos;ship&apos;,how = &apos;left&apos;)
    del nmf_fea
else:
    for j in range(1,4):
        print(&apos;********* {} *******&apos;.format(j))
        for i in [&apos;speed&apos;,&apos;x&apos;,&apos;y&apos;]:
            data[i + &apos;_str&apos;] = data[i].astype(str)
            from nmf_list import nmf_list
            nmf = nmf_list(data,&apos;ship&apos;,i + &apos;_str&apos;,8,2)
            nmf_a = nmf.run(j)
            data_label = data_label.merge(nmf_a,on = &apos;ship&apos;,how = &apos;left&apos;)


first = &quot;0&quot;
second = &quot;1&quot;
data_label[&apos;direction_median_ratio&apos;] = data_label[&apos;direction_median_{}&apos;.format(second)] / data_label[&apos;direction_median_{}&apos;.format(first)]
data_label[&apos;slope_ratio&apos;] = data_label[&apos;slope_{}&apos;.format(second)] / data_label[&apos;slope_{}&apos;.format(first)] 
data_label[&apos;slope_mean_ratio&apos;] = data_label[&apos;slope_median_{}&apos;.format(second)] / data_label[&apos;slope_median_{}&apos;.format(first)]

first = &quot;on_night&quot;
second = &quot;on_day&quot;
data_label[&apos;speed_median_ratio&apos;] = data_label[&apos;speed_median_{}&apos;.format(second)] / data_label[&apos;speed_median_{}&apos;.format(first)] 
data_label[&apos;speed_std_ratio&apos;] = data_label[&apos;speed_std_{}&apos;.format(second)] / data_label[&apos;speed_std_{}&apos;.format(first)] 

# 计算特征
flag = &apos;all&apos;
for cc in [&apos;direction&apos;,&apos;speed&apos;]:
    t = group_feature(data_label,cc, &apos;ship&apos;,[&apos;count&apos;],flag +cc+ &apos;x&apos;)
    data_label = pd.merge(data_label, t, on=cc, how=&apos;left&apos;)  

for i in [&quot;0&quot;,&quot;1&quot;]:
    if i == &quot;1&quot;:
        for j in [
#                 &apos;slope_speed_cat_nunique_{}&apos;.format(i),
#                   &apos;slope_mean_speed_cat_nunique_{}&apos;.format(i),
                  &apos;speed_nunique_{}&apos;.format(i),
                  &apos;direction_nunique_{}&apos;.format(i)
                 ]:

            t = group_feature(data_label,j, &apos;ship&apos;,[&apos;count&apos;],j+&quot;_count&quot;)
            data_label = pd.merge(data_label, t, on=j, how=&apos;left&apos;) 
    for j in [
           &apos;slope_median_{}&apos;.format(i),
#               &apos;x_max_x_min_{}&apos;.format(i),
#               &apos;y_max_y_min_{}&apos;.format(i)
             ]:
#         t = group_feature(data_label,j, &apos;ship&apos;,[&apos;count&apos;],j+&quot;_count&quot;)
#         data_label = pd.merge(data_label, t, on=j, how=&apos;left&apos;) 
        t = group_feature(data_label,j, &apos;speed&apos;,[&apos;min&apos;,&apos;max&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],j+&quot;_tongji&quot;)
        data_label = pd.merge(data_label, t, on=j, how=&apos;left&apos;)
        # t = group_feature(data_label,j, &apos;direction&apos;,[&apos;min&apos;,&apos;max&apos;,&apos;median&apos;,&apos;std&apos;,&apos;skew&apos;],j+&quot;_tongji&quot;)
        # data_label = pd.merge(data_label, t, on=j, how=&apos;left&apos;)

def cut_bins(raw_data, col_name=None, q=49):
    features, bins = pd.qcut(raw_data[col_name], q=q, retbins=True, duplicates=&quot;drop&quot;)
    labels = list(range(len(bins) - 1))
    features, bins = pd.qcut(raw_data[col_name], labels=labels, q=q, retbins=True, duplicates=&quot;drop&quot;)
    return features, bins, labels


MAX_CATE = 199
data[&quot;x_cate&quot;], x_bins, x_labels = cut_bins(data, col_name=&quot;x&quot;, q=MAX_CATE)
data[&quot;y_cate&quot;], y_bins, y_labels = cut_bins(data, col_name=&quot;y&quot;, q=MAX_CATE)
# data[&quot;x_sub_y_cate&quot;], x_sub_y_bins, x_sub_y_labels = cut_bins(data, col_name=&quot;x_sub_y&quot;, q=MAX_CATE)
data[&quot;distance_cate&quot;], dist_bins, dist_labels = cut_bins(data, col_name=&quot;base_dis_diff&quot;, q=MAX_CATE)

data[&quot;speed_cate&quot;], speed_bins, speed_labels = cut_bins(data, col_name=&quot;speed&quot;, q=MAX_CATE)

MAX_CATE = 120
data[&quot;direct_cate&quot;], speed_bins, speed_labels = cut_bins(data, col_name=&quot;direction&quot;, q=MAX_CATE)

if os.path.isfile(&apos;emb_testb.csv&apos;):
    w2v_fea = pd.read_csv(&apos;emb_testb.csv&apos;)
    data_label = data_label.merge(w2v_fea, on=&apos;ship&apos;, how=&apos;left&apos;)
    del w2v_fea
else:
    from gensim.models import Word2Vec
    import gc
    def emb(df, f1, f2):
        emb_size = 23
        print(&apos;====================================== {} {} ======================================&apos;.format(f1, f2))
        tmp = df.groupby(f1, as_index=False)[f2].agg({&apos;{}_{}_list&apos;.format(f1, f2): list})
        sentences = tmp[&apos;{}_{}_list&apos;.format(f1, f2)].values.tolist()
        del tmp[&apos;{}_{}_list&apos;.format(f1, f2)]
        for i in range(len(sentences)):
            sentences[i] = [str(x) for x in sentences[i]]
        model = Word2Vec(sentences, size=emb_size, window=5, min_count=3, sg=0, hs=1, seed=2222)
        emb_matrix = []
        for seq in sentences:
            vec = []
            for w in seq:
                if w in model:
                    vec.append(model[w])
            if len(vec) &gt; 0:
                emb_matrix.append(np.mean(vec, axis=0))
            else:
                emb_matrix.append([0] * emb_size)
        emb_matrix = np.array(emb_matrix)
        for i in range(emb_size):
            tmp[&apos;{}_{}_emb_{}&apos;.format(f1, f2, i)] = emb_matrix[:, i]
        del model, emb_matrix, sentences
        return tmp


    emb_cols = [
        [&apos;ship&apos;, &apos;x_cate&apos;],
        [&apos;ship&apos;, &apos;y_cate&apos;],
        [&apos;ship&apos;, &apos;speed_cate&apos;],
        [&apos;ship&apos;, &apos;distance_cate&apos;],
        # [&apos;ship&apos;, &apos;direct_cate&apos;],
    ]
    for f1, f2 in emb_cols:
        data_label = data_label.merge(emb(data, f1, f2), on=f1, how=&apos;left&apos;)

    gc.collect()

    # emb_list = [&apos;ship&apos;]
    # for i in data_label.columns:
    #     if &apos;_emb_&apos; in i:
    #         emb_list.append(i)

    # data_label[emb_list].to_csv(&apos;emb_testb.csv&apos;,index=False)


print(&apos;feature done&apos;)

train_label = data_label[:num]
test_label = data_label[num:]
features = [x for x in train_label.columns if x not in [&apos;ship&apos;,&apos;type&apos;,&apos;time&apos;,&apos;x&apos;,&apos;y&apos;,&apos;diff_time&apos;,&apos;date&apos;,&apos;day_nig&apos;,&apos;direction&apos;,&apos;speed&apos;,&apos;hour&apos;,
                                                       &apos;speed_many&apos;,&apos;dire_diff&apos;,&apos;direction_str&apos;,&apos;speed_str&apos;,&apos;dis&apos;,&apos;x_speed&apos;,&apos;y_speed&apos;] ]
target = &apos;type&apos;

# 特征选择
from feature_selector import FeatureSelector
fs = FeatureSelector(data = train_label[features], labels = train_label[target])
fs.identify_zero_importance(task = &apos;classification&apos;, eval_metric = &apos;multiclass&apos;,
                            n_iterations = 10, early_stopping = True)
fs.identify_low_importance(cumulative_importance = 0.97)
low_importance_features = fs.ops[&apos;low_importance&apos;]
print(&apos;====low_importance_features=====&apos;)
print(low_importance_features)
for i in low_importance_features:
features.remove(i)

print(&apos;feature number&apos;,len(features))
gc.collect()

# 评价指标
def macro_f1(y_hat, data):
    y_true = data.get_label()
    y_hat = y_hat.reshape(-1, y_true.shape[0])
    y_hat = np.argmax(y_hat, axis=0)
    f1_multi = precision_recall_fscore_support(y_true, y_hat, labels=[0, 1, 2])[2]
    f1_macro =  f1_score(y_true, y_hat, average =&quot;macro&quot;)
    assert np.mean(f1_multi) ==  f1_macro
    return &apos;f1&apos;, f1_macro, True


def f1_single(y_hat, data, index=0):
    y_true = data.get_label()
    y_hat = y_hat.reshape(-1, y_true.shape[0])
    y_hat = np.argmax(y_hat, axis=0)
    f1_multi = precision_recall_fscore_support(y_true, y_hat, labels=[0, 1, 2])[2]
    f1_s = round(f1_multi[index], 4)
    return &apos;f1_{}&apos;.format(index), f1_s, True

# 构造模型
train_X = train_label[features]
test_X = test_label[features]
print(train_X.shape, test_X.shape)
train_y = train_label[target]


params = {
        &apos;task&apos;:&apos;train&apos;, 
        &apos;num_leaves&apos;: 63,
        &apos;objective&apos;: &apos;multiclass&apos;,
        &apos;num_class&apos;: 3,
        &apos;metric&apos;: &apos;None&apos;, # [f1_0, f1_1, f1_2],
        &apos;min_data_in_leaf&apos;: 10,
        &apos;learning_rate&apos;: 0.01,
        &apos;feature_fraction&apos;: 0.7,
        &apos;bagging_fraction&apos;: 0.95,
        &apos;early_stopping_rounds&apos;: 2000,
#         &apos;lambda_l1&apos;: 0.1,
#         &apos;lambda_l2&apos;: 0.1,
        &quot;first_metric_only&quot;: True,
        &apos;bagging_freq&apos;: 3, 
        &apos;max_bin&apos;: 255,
        &apos;random_state&apos;: 42,
        &apos;verbose&apos; : -1
    }


models = []
test_preds = []
val_preds = []
oof_seed = np.zeros((len(train_label), 3))
seed = [2222,2018778]
for j in seed:
    print(&quot;+++++++++++++++++ seed {} ++++++++++++&quot;.format(str(j)))
    skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=j)
    oof = np.zeros((len(train_label), 3))
    for i, (trn_idx, val_idx) in enumerate(skf.split(train_X, train_y)):
        print(&quot;-&quot; * 81)
        print(&quot;[!] fold {}&quot;.format(i))
        lgb_params = deepcopy(params)
        # print(lgb_params)
        trn_X = csr_matrix(train_X)[trn_idx]
        trn_y = train_y.iloc[trn_idx]
        val_X = csr_matrix(train_X)[val_idx]
        val_y = train_y.iloc[val_idx]
        dtrain = lgb.Dataset(trn_X, trn_y) 
        dval = lgb.Dataset(val_X, val_y) 
        model = lgb.train(lgb_params, 
               dtrain, 
               num_boost_round=400000,
               valid_sets=[dval], 
               feval=lambda preds, train_data: [
                   macro_f1(preds, train_data),
                   f1_single(preds, train_data, index=0),
                   f1_single(preds, train_data, index=1),
                   f1_single(preds, train_data, index=2)],
               verbose_eval=-1)
        models.append(model)
        # print(model.best_iteration)
        val_pred = model.predict(val_X, iteration=model.best_iteration)
        oof[val_idx] = val_pred
        val_y = train_y.iloc[val_idx]
        val_pred = np.argmax(val_pred, axis=1)
        print(str(i), &apos;val f1&apos;, metrics.f1_score(val_y, val_pred, average=&apos;macro&apos;))
        test_preds.append(model.predict(test_X, iteration=model.best_iteration))
        print(&quot;[!] fold {} finish\n&quot;.format(i))
        del dtrain, dval
        gc.collect()
    val_pred = np.argmax(oof, axis=1)
    print(str(j), &apos;every_flod val f1&apos;, metrics.f1_score(train_y, val_pred, average=&apos;macro&apos;))
    oof_seed += oof/len(seed)

oof1 = np.argmax(oof_seed, axis=1)
print(&apos;oof f1&apos;, metrics.f1_score(oof1,train_y, average=&apos;macro&apos;))
val_score = np.round(metrics.f1_score(oof1, train_y, average=&apos;macro&apos;),6)

def ensemble_predictions(predictions, weights=None, type_=&quot;linear&quot;):
    if not weights:
        print(&quot;[!] AVE_WGT&quot;)
        weights = [1./ len(predictions) for _ in range(len(predictions))]
    assert len(predictions) == len(weights)
    if np.sum(weights) != 1.0:
        weights = [w / np.sum(weights) for w in weights]
    print(&quot;[!] weights = {}&quot;.format(weights))
    assert np.isclose(np.sum(weights), 1.0)
    if type_ == &quot;linear&quot;:
        res = np.average(predictions, weights=weights, axis=0)
    elif type_ == &quot;harmonic&quot;:
        res = np.average([1 / p for p in predictions], weights=weights, axis=0)
        return 1 / res
    elif type_ == &quot;geometric&quot;:
        numerator = np.average(
            [np.log(p) for p in predictions], weights=weights, axis=0
        )
        res = np.exp(numerator / sum(weights))
        return res
    elif type_ == &quot;rank&quot;:
        from scipy.stats import rankdata
        res = np.average([rankdata(p) for p in predictions], weights=weights, axis=0)
        return res / (len(res) + 1)
    return res

    def merge(prob, number=-1, index=0):
        from copy import deepcopy
        new_prob = deepcopy(prob)
        top = np.argsort(prob[:, index])[::-1][: number]
        print(top[: 4])
        for i in range(len(new_prob)):
            pad_value = np.array([0, 0, 0])
            pad_value[index] = 1
            if i in top:
                new_prob[i, ] = pad_value
            else:
                new_prob[i, index] = 0.
        return new_prob


test_pred_prob = ensemble_predictions(test_preds)
test_pred = test_pred_prob.argmax(axis=1)

test_pro = test_label[[&apos;ship&apos;]]
test_pro[&apos;pro_1&apos;] = test_pred_prob[:,0]
test_pro[&apos;pro_2&apos;] = test_pred_prob[:,1]
test_pro[&apos;pro_3&apos;] = test_pred_prob[:,2]
pred_pro = merge(test_pro[[&apos;pro_1&apos;, &apos;pro_2&apos;, &apos;pro_3&apos;]].values, 900,0)
test_pred = pred_pro.argmax(axis=1)


test_data = test_label[[&apos;ship&apos;]]
test_data[&quot;label&quot;] = test_pred
test_data[&quot;label&quot;] = test_data[&quot;label&quot;].map({0:&apos;围网&apos;,1:&apos;刺网&apos;,2:&apos;拖网&apos;})
# test_data[&apos;label&apos;][:100] = &apos;刺网&apos;
test_data[[&quot;ship&quot;, &quot;label&quot;]].to_csv(&quot;result.csv&quot;, index=False, header=None)
print(test_data[&quot;label&quot;].value_counts())
print(&apos;runtime:&apos;, time.time() - start_t)</code></pre>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>学习日志：2020华为云大数据挑战赛（正式赛）</title>
    <url>/2020/05/29/hello-world/</url>
    <content><![CDATA[<h2 id="2020-5-29-正式赛题解读"><a href="#2020-5-29-正式赛题解读" class="headerlink" title="2020.5.29 正式赛题解读"></a>2020.5.29 正式赛题解读</h2><h3 id="赛题背景：船运到达时间预测"><a href="#赛题背景：船运到达时间预测" class="headerlink" title="赛题背景：船运到达时间预测"></a>赛题背景：船运到达时间预测</h3><p>通过船运的历史数据构建模型，对目的港到达时间进行预测，预测时间简称为ETA（estimated time of arrival），目的港到达时间预测为ARRIVAL_ETA。</p>
<a id="more"></a>
<p>本次大赛提供<strong>历史运单GPS数据、历史运单事件数据、港口坐标数据</strong>，预测货物运单的到达时间，对应“历史运单事件”数据中EVENT_CODE字段值为ARRIVAL AT PORT时EVENT_CONVOLUTION_DATE的时间值。</p>
<h3 id="比赛数据"><a href="#比赛数据" class="headerlink" title="比赛数据"></a>比赛数据</h3><p><strong>1. GPS数据（建议重点参考）</strong></p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="center">类型</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loadingOrder</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的主运单，货物的运单编号，类似快递单号</td>
</tr>
<tr>
<td align="left">carrierName</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的承运商名称，类似快递公司名称</td>
</tr>
<tr>
<td align="left">timestamp</td>
<td align="center">DATE</td>
<td align="right">时间，格式为：yyyy-MM-dd’T’HH:mm:ss.SSSZ，如2019-09-05T16:33:17.000Z</td>
</tr>
<tr>
<td align="left">longitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的经度坐标，如114.234567</td>
</tr>
<tr>
<td align="left">latitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的纬度坐标，如21.234567</td>
</tr>
<tr>
<td align="left">vesselMMSI</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的船舶海上移动业务识别码MMSI， 唯一标识，对应到每一艘船</td>
</tr>
<tr>
<td align="left">speed</td>
<td align="center">NUMBER</td>
<td align="right">单位km/h，货物在运输过程中，当前船舶的瞬时速度，部分数据未提供的可自行计算。</td>
</tr>
<tr>
<td align="left">direction</td>
<td align="center">NUMBER</td>
<td align="right">当前船舶的行驶方向，正北是0度，31480代表西北方向314.80度，900代表正北偏东9度。</td>
</tr>
<tr>
<td align="left">vesselNextport</td>
<td align="center">VARCHAR2</td>
<td align="right">船舶将要到达的下一港口，港口名称可能不规范，如CNQIN、CN QIN、CN QINGDAO都代表下一站为中国青岛港口。</td>
</tr>
<tr>
<td align="left">vesselNextportETA</td>
<td align="center">DATE</td>
<td align="right">船运公司给出的到“下一个港口”预计到达时间，格式为：yyyy-MM-dd’T’HH:mm:ss.SSSZ，如2019-09-12T16:33:17.000Z</td>
</tr>
<tr>
<td align="left">vesselStatus</td>
<td align="center">VARCHAR2</td>
<td align="right">当前船舶航行状态，主要包括：moored、under way using engine、not under command、at anchor、under way sailing、constrained by her draught</td>
</tr>
<tr>
<td align="left">TRANSPORT_TRACE</td>
<td align="center">VARCHAR2</td>
<td align="right">船的路由，由“-”连接组成，例如CNSHK-MYPKG-MYTPP。由承运商预先录入，实际小概率存在不按此路由行驶（如遇塞港时），但最终会到达目的港口。</td>
</tr>
</tbody></table>
<p><strong>数据说明：</strong></p>
<p>每个运单表示一次运输的运输单号，不会重复使用，一次运输过程中的多条GPS数据拥有相同的运输单号。船号为运单货物所在的船编号，会重复出现在不同次运输的GPS数据中。需要注意的是GPS数据中可能会有异常的GPS，可能且不限于如下问题：</p>
<p>（1） GPS坐标在陆地，或者有些港口是内陆的港口。</p>
<p>（2） GPS漂移：两点距离过大，超过船的行驶能力。</p>
<p>（3） GPS在部分地区的比较稀疏（比如南半球、敏感海域）。</p>
<p>（4） 最后的GPS点可能和港口的距离较远（比如塞港时，或者临近目的港时已无GPS数据）。</p>
<p>（5） speed字段之后数据可能会有少量缺失（如GPS设备短暂异常）。</p>
<p><strong>注意 :</strong> 字段vesselNextport、vesselNextportETA、TRANSPORT_TRACE为手工输入，误填可能性较大。</p>
<p><strong>2. 历史运单时间数据（手工录入，辅助参考）</strong></p>
<p>历史运单事件数据描述每个运单在船运的过程中，与港口相关的关键信息，如离开起运港、到达目的港等。</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="center">类型</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loadingOrder</td>
<td align="center">VARCHAR2</td>
<td align="right">运单号，与历史运单GPS数据中的loadingOrder字段一致</td>
</tr>
<tr>
<td align="left">EVENT_CODE</td>
<td align="center">VARCHAR2</td>
<td align="right">事件编码，主要事件包括：TRANSIT PORT ATD实际离开中转港、SHIPMENT ONBOARD DATE实际离开起运港、TRANSIT PORT ATA实际到达中转港、ARRIVAL AT PORT实际到达目的港、注：部分船可能没有中转港</td>
</tr>
<tr>
<td align="left">EVENT_LOCATION_ID</td>
<td align="center">VARCHAR2</td>
<td align="right">港口名称，对应“港口坐标据”表中的字段TRANS_NODE_NAME</td>
</tr>
<tr>
<td align="left">EVENT_CONVOLUTION_DATE</td>
<td align="center">DATE</td>
<td align="right">事件发生的时间，格式为：yyyy/MM/dd HH:mm:ss（dd与HH之间为两个空格）。例如Event_code为“SHIPMENT ONBOARD DATE”时，此字段表示船从起运港出发的时间。EVENT_CODE为“ARRIVAL AT PORT”时，此字段表示船到达目的港的时间。</td>
</tr>
</tbody></table>
<p><strong>3. 港口坐标数据</strong><br>港口坐标数据描述每个运单在船运的过程中涉及的港口位置信息。</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="center">类型</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TRANS_NODE_NAME</td>
<td align="center">VARCHAR2</td>
<td align="right">港口名称，如：WAREHOUSE_TURKEYMOSCOW_RUSSIAN FEDERATION，CHIWAN(44)，SHEKOU，深圳蛇口港等</td>
</tr>
<tr>
<td align="left">LONGITUDE</td>
<td align="center">VARCHAR2</td>
<td align="right">港口的经度坐标</td>
</tr>
<tr>
<td align="left">LATITUDE</td>
<td align="center">VARCHAR2</td>
<td align="right">港口的纬度坐标</td>
</tr>
<tr>
<td align="left">COUNTRY</td>
<td align="center">VARCHAR2</td>
<td align="right">国家</td>
</tr>
<tr>
<td align="left">STATE</td>
<td align="center">VARCHAR2</td>
<td align="right">省、州</td>
</tr>
<tr>
<td align="left">CITY</td>
<td align="center">VARCHAR2</td>
<td align="right">城市</td>
</tr>
<tr>
<td align="left">REGION</td>
<td align="center">VARCHAR2</td>
<td align="right">县、区</td>
</tr>
<tr>
<td align="left">ADDRESS</td>
<td align="center">VARCHAR2</td>
<td align="right">详细地址。</td>
</tr>
<tr>
<td align="left">PORT_CODE</td>
<td align="center">VARCHAR2</td>
<td align="right">港口编码，即港口的字母简码，如CNSHK代表中国蛇口港</td>
</tr>
</tbody></table>
<p><strong>数据说明：</strong><br>（1） 重点为NAME和经纬度数据</p>
<p>（2） 一个港口可能会有多个NAME表示，且不按五位编码表示</p>
<p>（3） 经纬度如果出现负数则为错误信息，可以删除或自行补充</p>
<p><strong>4. 测试运单数据</strong></p>
<p>测试运单数据为运单运输过程中的不同位置点所构成，供选手测试对应的ETA时间。测试运单数据如下表描述。</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="center">类型</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loadingOrder</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的主运单，货物的运单编号，类似快递单号</td>
</tr>
<tr>
<td align="left">timestamp</td>
<td align="center">DATE</td>
<td align="right">时间，格式为：yyyy-MM-dd’T’HH:mm:ss.SSSZ，如2019-09-05T16:33:17.000Z</td>
</tr>
<tr>
<td align="left">longitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的经度坐标，如114.234567</td>
</tr>
<tr>
<td align="left">latitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的纬度坐标，如21.234567</td>
</tr>
<tr>
<td align="left">speed</td>
<td align="center">NUMBER</td>
<td align="right">单位km/h，货物在运输过程中，当前船舶的瞬时速度，部分数据未提供的可自行计算。</td>
</tr>
<tr>
<td align="left">direction</td>
<td align="center">NUMBER</td>
<td align="right">当前船舶的行驶方向，正北是0度，31480代表西北方向314.80度，900代表正北偏东9度。</td>
</tr>
<tr>
<td align="left">carrierName</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的承运商名称，类似快递公司名称</td>
</tr>
<tr>
<td align="left">vesselMMSI</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的船舶海上移动业务识别码MMSI， 唯一标识，对应到每一艘船</td>
</tr>
<tr>
<td align="left">onboardDate</td>
<td align="center">DATE</td>
<td align="right">离开起运港时间，格式为：yyyy/MM/dd HH:mm:ss（dd与HH之间为两个空格），如2019/09/05 16:33:17</td>
</tr>
<tr>
<td align="left">TRANSPORT_TRACE</td>
<td align="center">VARCHAR2</td>
<td align="right">船的路由，由“-”连接组成，例如CNSHK-MYPKG-MYTPP。由承运商预先录入，实际小概率存在不按此路由行驶（如遇塞港时），但最终会到达目的港口。</td>
</tr>
</tbody></table>
<p><strong>数据说明：</strong><br>（1） 根据航程提供起始一段形成GPS数据，用于预测到达目的港时间（按不同航线，提供10%~50%左右的GPS数据）</p>
<p><strong>5. 提交数据</strong></p>
<p>所有参与竞赛的选手登录到大赛平台，提交结果数据，具体提交格式要求：</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="center">类型</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loadingOrder</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的主运单，货物的运单编号，类似快递单号</td>
</tr>
<tr>
<td align="left">timestamp</td>
<td align="center">DATE</td>
<td align="right">时间，格式为：yyyy-MM-dd’T’HH:mm:ss.SSSZ，如2019-09-05T16:33:17.000Z</td>
</tr>
<tr>
<td align="left">longitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的经度坐标，如114.234567</td>
</tr>
<tr>
<td align="left">latitude</td>
<td align="center">NUMBER</td>
<td align="right">货物在运输过程中，当前船舶所处的纬度坐标，如21.234567</td>
</tr>
<tr>
<td align="left">carrierName</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的承运商名称，类似快递公司名称</td>
</tr>
<tr>
<td align="left">vesselMMSI</td>
<td align="center">VARCHAR2</td>
<td align="right">脱敏后的船舶海上移动业务识别码MMSI， 唯一标识，对应到每一艘船</td>
</tr>
<tr>
<td align="left">onboardDate</td>
<td align="center">DATE</td>
<td align="right">离开起运港时间，格式为：yyyy/MM/dd HH:mm:ss（dd与HH之间为两个空格），如2019/09/05 16:33:17</td>
</tr>
<tr>
<td align="left">ETA</td>
<td align="center">DATE</td>
<td align="right">到达目的港口的ETA，格式为：yyyy/MM/dd HH:mm:ss（dd与HH之间为两个空格），如2019/09/18 22:28:46</td>
</tr>
<tr>
<td align="left">creatDate</td>
<td align="center">DATE</td>
<td align="right">当前表创建时间，格式为：yyyy/MM/dd HH:mm:ss（dd与HH之间为两个空格），如2020/05/05 16:33:17</td>
</tr>
</tbody></table>
<p><strong>数据说明：</strong><br>（1） 前7列基于测试数据，ETA列为预测时间</p>
<p>（2） creatDate为文件生成时间，判分不关注。</p>
<h2 id="2020-6-2-baseline分析"><a href="#2020-6-2-baseline分析" class="headerlink" title="2020.6.2 baseline分析"></a>2020.6.2 baseline分析</h2><p>分析正式赛提供的baseline </p>
<p><strong>MSE : 176495.2554</strong></p>
<h3 id="1-导入所需要的包"><a href="#1-导入所需要的包" class="headerlink" title="1. 导入所需要的包"></a>1. 导入所需要的包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"># from tqdm import tqdm</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from sklearn.metrics import mean_squared_error,explained_variance_score</span><br><span class="line">from sklearn.model_selection import KFold</span><br><span class="line">import lightgbm as lgb</span><br><span class="line"></span><br><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&#39;ignore&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="2-加载数据"><a href="#2-加载数据" class="headerlink" title="2. 加载数据"></a>2. 加载数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># baseline只用到gps定位数据，即train_gps_path</span><br><span class="line">train_gps_path &#x3D; &#39;dataset&#x2F;train0523.csv&#39;</span><br><span class="line">test_data_path &#x3D; &#39;test&#x2F;A_testData0531.csv&#39;</span><br><span class="line">order_data_path &#x3D; &#39;dataset&#x2F;loadingOrderEvent.csv&#39;</span><br><span class="line">port_data_path &#x3D; &#39;dataset&#x2F;port.csv&#39;</span><br><span class="line"></span><br><span class="line"># 取前1000000行</span><br><span class="line">debug &#x3D; True</span><br><span class="line">NDATA &#x3D; 1000000</span><br><span class="line"></span><br><span class="line">if debug:</span><br><span class="line">    train_data &#x3D; pd.read_csv(train_gps_path,nrows&#x3D;NDATA,header&#x3D;None)</span><br><span class="line">else:</span><br><span class="line">    train_data &#x3D; pd.read_csv(train_gps_path,header&#x3D;None)</span><br><span class="line"></span><br><span class="line">train_data.columns &#x3D; [&#39;loadingOrder&#39;,&#39;carrierName&#39;,&#39;timestamp&#39;,&#39;longitude&#39;,</span><br><span class="line">                  &#39;latitude&#39;,&#39;vesselMMSI&#39;,&#39;speed&#39;,&#39;direction&#39;,&#39;vesselNextport&#39;,</span><br><span class="line">                  &#39;vesselNextportETA&#39;,&#39;vesselStatus&#39;,&#39;vesselDatasource&#39;,&#39;TRANSPORT_TRACE&#39;]</span><br><span class="line">test_data &#x3D; pd.read_csv(test_data_path)</span><br><span class="line"></span><br><span class="line">def get_data(data, mode&#x3D;&#39;train&#39;):</span><br><span class="line"></span><br><span class="line">	assert mode&#x3D;&#x3D;&#39;train&#39; or mode&#x3D;&#x3D;&#39;test&#39;</span><br><span class="line">	</span><br><span class="line">	if mode&#x3D;&#x3D;&#39;train&#39;:</span><br><span class="line">	    data[&#39;vesselNextportETA&#39;] &#x3D; pd.to_datetime(data[&#39;vesselNextportETA&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">	elif mode&#x3D;&#x3D;&#39;test&#39;:</span><br><span class="line">	    data[&#39;temp_timestamp&#39;] &#x3D; data[&#39;timestamp&#39;]</span><br><span class="line">	    data[&#39;onboardDate&#39;] &#x3D; pd.to_datetime(data[&#39;onboardDate&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">	data[&#39;timestamp&#39;] &#x3D; pd.to_datetime(data[&#39;timestamp&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">	data[&#39;longitude&#39;] &#x3D; data[&#39;longitude&#39;].astype(float)</span><br><span class="line">	data[&#39;loadingOrder&#39;] &#x3D; data[&#39;loadingOrder&#39;].astype(str)</span><br><span class="line">	data[&#39;latitude&#39;] &#x3D; data[&#39;latitude&#39;].astype(float)</span><br><span class="line">	data[&#39;speed&#39;] &#x3D; data[&#39;speed&#39;].astype(float)</span><br><span class="line">	data[&#39;direction&#39;] &#x3D; data[&#39;direction&#39;].astype(float)</span><br><span class="line">	</span><br><span class="line">	return data</span><br><span class="line"></span><br><span class="line">train_data &#x3D; get_data(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line">test_data &#x3D; get_data(test_data, mode&#x3D;&#39;test&#39;)</span><br></pre></td></tr></table></figure>

<p>由于训练集过于庞大，因此baseline只选取了前100万条数据，因此，我们应该可以通过清洗数据来选取合适的训练数据来降低MSE。</p>
<h3 id="3-获取特征，目前baseline的特征只选择经纬度、速度-方向。我们需要进一步可视化数据集，构造更加合理的特征。"><a href="#3-获取特征，目前baseline的特征只选择经纬度、速度-方向。我们需要进一步可视化数据集，构造更加合理的特征。" class="headerlink" title="3. 获取特征，目前baseline的特征只选择经纬度、速度\方向。我们需要进一步可视化数据集，构造更加合理的特征。"></a>3. 获取特征，目前baseline的特征只选择经纬度、速度\方向。我们需要进一步可视化数据集，构造更加合理的特征。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 代码参考：https:&#x2F;&#x2F;github.com&#x2F;juzstu&#x2F;TianChi_HaiYang</span><br><span class="line">def get_feature(df, mode&#x3D;&#39;train&#39;):</span><br><span class="line">    </span><br><span class="line">    assert mode&#x3D;&#x3D;&#39;train&#39; or mode&#x3D;&#x3D;&#39;test&#39;</span><br><span class="line">    </span><br><span class="line">    df.sort_values([&#39;loadingOrder&#39;, &#39;timestamp&#39;], inplace&#x3D;True)</span><br><span class="line">    # 特征只选择经纬度、速度\方向</span><br><span class="line">    df[&#39;lat_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;latitude&#39;].diff(1)</span><br><span class="line">    df[&#39;lon_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;longitude&#39;].diff(1)</span><br><span class="line">    df[&#39;speed_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;speed&#39;].diff(1)</span><br><span class="line">    df[&#39;diff_minutes&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].diff(1).dt.total_seconds() &#x2F;&#x2F; 60</span><br><span class="line">    df[&#39;anchor&#39;] &#x3D; df.apply(lambda x: 1 if x[&#39;lat_diff&#39;] &lt;&#x3D; 0.03 and x[&#39;lon_diff&#39;] &lt;&#x3D; 0.03</span><br><span class="line">                            and x[&#39;speed_diff&#39;] &lt;&#x3D; 0.3 and x[&#39;diff_minutes&#39;] &lt;&#x3D; 10 else 0, axis&#x3D;1)</span><br><span class="line">    </span><br><span class="line">    if mode&#x3D;&#x3D;&#39;train&#39;:</span><br><span class="line">        group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(mmax&#x3D;&#39;max&#39;, count&#x3D;&#39;count&#39;, mmin&#x3D;&#39;min&#39;).reset_index()</span><br><span class="line">        # 读取数据的最大值-最小值，即确认时间间隔为label</span><br><span class="line">        group_df[&#39;label&#39;] &#x3D; (group_df[&#39;mmax&#39;] - group_df[&#39;mmin&#39;]).dt.total_seconds()</span><br><span class="line">    elif mode&#x3D;&#x3D;&#39;test&#39;:</span><br><span class="line">        group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(count&#x3D;&#39;count&#39;).reset_index()</span><br><span class="line">        </span><br><span class="line">    anchor_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;anchor&#39;].agg(&#39;sum&#39;).reset_index()</span><br><span class="line">    anchor_df.columns &#x3D; [&#39;loadingOrder&#39;, &#39;anchor_cnt&#39;]</span><br><span class="line">    group_df &#x3D; group_df.merge(anchor_df, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line">    group_df[&#39;anchor_ratio&#39;] &#x3D; group_df[&#39;anchor_cnt&#39;] &#x2F; group_df[&#39;count&#39;]</span><br><span class="line"></span><br><span class="line">    agg_function &#x3D; [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;median&#39;]</span><br><span class="line">    agg_col &#x3D; [&#39;latitude&#39;, &#39;longitude&#39;, &#39;speed&#39;, &#39;direction&#39;]</span><br><span class="line"></span><br><span class="line">    group &#x3D; df.groupby(&#39;loadingOrder&#39;)[agg_col].agg(agg_function).reset_index()</span><br><span class="line">    group.columns &#x3D; [&#39;loadingOrder&#39;] + [&#39;&#123;&#125;_&#123;&#125;&#39;.format(i, j) for i in agg_col for j in agg_function]</span><br><span class="line">    group_df &#x3D; group_df.merge(group, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line"></span><br><span class="line">    return group_df</span><br><span class="line">    </span><br><span class="line">train &#x3D; get_feature(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line">test &#x3D; get_feature(test_data, mode&#x3D;&#39;test&#39;)</span><br><span class="line">features &#x3D; [c for c in train.columns if c not in [&#39;loadingOrder&#39;, &#39;label&#39;, &#39;mmin&#39;, &#39;mmax&#39;, &#39;count&#39;]]</span><br></pre></td></tr></table></figure>

<p>这部分代码可能由于pandas版本问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(mmax&#x3D;&#39;max&#39;, count&#x3D;&#39;count&#39;, mmin&#x3D;&#39;min&#39;).reset_index()</span><br></pre></td></tr></table></figure>

<p>需要修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(&#39;mmax&#39;:&#39;max&#39;, &#39;count&#39;:&#39;count&#39;, &#39;mmin&#39;:&#39;min&#39;).reset_index()</span><br></pre></td></tr></table></figure>

<h3 id="4-使用十折交叉验证构造模型"><a href="#4-使用十折交叉验证构造模型" class="headerlink" title="4. 使用十折交叉验证构造模型"></a>4. 使用十折交叉验证构造模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def mse_score_eval(preds, valid):</span><br><span class="line">    labels &#x3D; valid.get_label()</span><br><span class="line">    scores &#x3D; mean_squared_error(y_true&#x3D;labels, y_pred&#x3D;preds)</span><br><span class="line">    return &#39;mse_score&#39;, scores, True</span><br><span class="line"></span><br><span class="line">def build_model(train, test, pred, label, seed&#x3D;1080, is_shuffle&#x3D;True):</span><br><span class="line">    train_pred &#x3D; np.zeros((train.shape[0], ))</span><br><span class="line">    test_pred &#x3D; np.zeros((test.shape[0], ))</span><br><span class="line">    n_splits &#x3D; 10</span><br><span class="line">    # Kfold</span><br><span class="line">    fold &#x3D; KFold(n_splits&#x3D;n_splits, shuffle&#x3D;is_shuffle, random_state&#x3D;seed)</span><br><span class="line">    kf_way &#x3D; fold.split(train[pred])</span><br><span class="line">    # params</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;learning_rate&#39;: 0.01,</span><br><span class="line">        &#39;boosting_type&#39;: &#39;gbdt&#39;,</span><br><span class="line">        &#39;objective&#39;: &#39;regression&#39;,</span><br><span class="line">        &#39;num_leaves&#39;: 36,</span><br><span class="line">        &#39;feature_fraction&#39;: 0.6,</span><br><span class="line">        &#39;bagging_fraction&#39;: 0.7,</span><br><span class="line">        &#39;bagging_freq&#39;: 6,</span><br><span class="line">        &#39;seed&#39;: 8,</span><br><span class="line">        &#39;bagging_seed&#39;: 1,</span><br><span class="line">        &#39;feature_fraction_seed&#39;: 7,</span><br><span class="line">        &#39;min_data_in_leaf&#39;: 20,</span><br><span class="line">        &#39;nthread&#39;: 8,</span><br><span class="line">        &#39;verbose&#39;: 1,</span><br><span class="line">    &#125;</span><br><span class="line">    # train</span><br><span class="line">    for n_fold, (train_idx, valid_idx) in enumerate(kf_way, start&#x3D;1):</span><br><span class="line">        train_x, train_y &#x3D; train[pred].iloc[train_idx], train[label].iloc[train_idx]</span><br><span class="line">        valid_x, valid_y &#x3D; train[pred].iloc[valid_idx], train[label].iloc[valid_idx]</span><br><span class="line">        # 数据加载</span><br><span class="line">        n_train &#x3D; lgb.Dataset(train_x, label&#x3D;train_y)</span><br><span class="line">        n_valid &#x3D; lgb.Dataset(valid_x, label&#x3D;valid_y)</span><br><span class="line"></span><br><span class="line">        clf &#x3D; lgb.train(</span><br><span class="line">            params&#x3D;params,</span><br><span class="line">            train_set&#x3D;n_train,</span><br><span class="line">            num_boost_round&#x3D;3000,</span><br><span class="line">            valid_sets&#x3D;[n_valid],</span><br><span class="line">            early_stopping_rounds&#x3D;100,</span><br><span class="line">            verbose_eval&#x3D;100,</span><br><span class="line">            feval&#x3D;mse_score_eval</span><br><span class="line">        )</span><br><span class="line">        train_pred[valid_idx] &#x3D; clf.predict(valid_x, num_iteration&#x3D;clf.best_iteration)</span><br><span class="line">        test_pred +&#x3D; clf.predict(test[pred], num_iteration&#x3D;clf.best_iteration)&#x2F;fold.n_splits</span><br><span class="line">    </span><br><span class="line">    test[&#39;label&#39;] &#x3D; test_pred</span><br><span class="line">    </span><br><span class="line">    return test[[&#39;loadingOrder&#39;, &#39;label&#39;]]</span><br><span class="line"></span><br><span class="line">result &#x3D; build_model(train, test, features, &#39;label&#39;, is_shuffle&#x3D;True)</span><br></pre></td></tr></table></figure>
<h3 id="5-生成最终的测试文件"><a href="#5-生成最终的测试文件" class="headerlink" title="5. 生成最终的测试文件"></a>5. 生成最终的测试文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_data &#x3D; test_data.merge(result, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line">test_data[&#39;ETA&#39;] &#x3D; (test_data[&#39;onboardDate&#39;] + test_data[&#39;label&#39;].apply(lambda x:pd.Timedelta(seconds&#x3D;x))).apply(lambda x:x.strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;))</span><br><span class="line">test_data.drop([&#39;direction&#39;,&#39;TRANSPORT_TRACE&#39;],axis&#x3D;1,inplace&#x3D;True)</span><br><span class="line">test_data[&#39;onboardDate&#39;] &#x3D; test_data[&#39;onboardDate&#39;].apply(lambda x:x.strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;))</span><br><span class="line">test_data[&#39;creatDate&#39;] &#x3D; pd.datetime.now().strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;)</span><br><span class="line">test_data[&#39;timestamp&#39;] &#x3D; test_data[&#39;temp_timestamp&#39;]</span><br><span class="line"># 整理columns顺序</span><br><span class="line">result &#x3D; test_data[[&#39;loadingOrder&#39;, &#39;timestamp&#39;, &#39;longitude&#39;, &#39;latitude&#39;, &#39;carrierName&#39;, &#39;vesselMMSI&#39;, &#39;onboardDate&#39;, &#39;ETA&#39;, &#39;creatDate&#39;]]</span><br><span class="line"></span><br><span class="line">result.to_csv(&#39;result.csv&#39;, index&#x3D;False)</span><br></pre></td></tr></table></figure>


<h2 id="2020-6-4-构建自己的方案"><a href="#2020-6-4-构建自己的方案" class="headerlink" title="2020.6.4 构建自己的方案"></a>2020.6.4 构建自己的方案</h2><h3 id="1-首先对测试数据进行分析，观察测试数据海域"><a href="#1-首先对测试数据进行分析，观察测试数据海域" class="headerlink" title="1 首先对测试数据进行分析，观察测试数据海域"></a>1 首先对测试数据进行分析，观察测试数据海域</h3><p>观察测试数据的经纬度坐标</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/3DDC4958791846399E78159CE41D9B88?method=download&shareKey=5f64e5f51a764a54adc51abe88526fb7" alt></p>
<p>可以看出测试航线的行驶方向几乎覆盖了全球，也可以看到有少量的GPS数据发生了漂移</p>
<p>首先我们先对数据进行清洗</p>
<ul>
<li><p>删除字段中存在null的数据</p>
</li>
<li><p>提取训练数据中与测试数据航线路由一致的数据<br>测试数据航线路由：<br>[‘CNYTN-MXZLO’ ‘CNSHK-MYTPP’ ‘CNSHK-SGSIN’ ‘CNSHK-CLVAP’ ‘CNYTN-ARENA’<br>‘CNYTN-MATNG’ ‘CNSHK-GRPIR’ ‘CNSHK-PKQCT’ ‘COBUN-HKHKG’ ‘CNYTN-PAONX’<br>‘CNSHK-SIKOP’ ‘CNYTN-CAVAN’ ‘CNSHK-ESALG’ ‘CNYTN-MTMLA’ ‘CNSHK-ZADUR’<br>‘CNSHK-LBBEY’ ‘CNSHA-SGSIN’ ‘CNYTN-RTM’ ‘CNHKG-MXZLO’ ‘HKHKG-FRFOS’<br>‘CNYTN-NZAKL’ ‘CNSHA-PAMIT’]</p>
</li>
</ul>
<ul>
<li><p>处理所有的数据，保存筛选出来的训练数据</p>
<p>（周星星第三名提供一种思路：用无监督学习聚类与测试样本相似轨迹的训练数据）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"># from tqdm import tqdm</span><br><span class="line">import numpy as np</span><br><span class="line"># 释放内存</span><br><span class="line">import gc</span><br><span class="line">from sklearn.metrics import mean_squared_error,explained_variance_score</span><br><span class="line">from sklearn.model_selection import KFold</span><br><span class="line">import lightgbm as lgb</span><br><span class="line">from pandas.core.frame import DataFrame</span><br><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&#39;ignore&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># baseline只用到gps定位数据，即train_gps_path</span><br><span class="line">train_gps_path &#x3D; &#39;data&#x2F;train0523.csv&#39;</span><br><span class="line">test_data_path &#x3D; &#39;data&#x2F;A_testData0531.csv&#39;</span><br><span class="line">order_data_path &#x3D; &#39;data&#x2F;loadingOrderEvent.csv&#39;</span><br><span class="line">port_data_path &#x3D; &#39;data&#x2F;port.csv&#39;</span><br><span class="line"></span><br><span class="line">def get_data(data, mode&#x3D;&#39;train&#39;):</span><br><span class="line">    </span><br><span class="line">    assert mode&#x3D;&#x3D;&#39;train&#39; or mode&#x3D;&#x3D;&#39;test&#39;</span><br><span class="line">    </span><br><span class="line">    if mode&#x3D;&#x3D;&#39;train&#39;:</span><br><span class="line">        data[&#39;vesselNextportETA&#39;] &#x3D; pd.to_datetime(data[&#39;vesselNextportETA&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">    elif mode&#x3D;&#x3D;&#39;test&#39;:</span><br><span class="line">        data[&#39;temp_timestamp&#39;] &#x3D; data[&#39;timestamp&#39;]</span><br><span class="line">        data[&#39;onboardDate&#39;] &#x3D; pd.to_datetime(data[&#39;onboardDate&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">    data[&#39;timestamp&#39;] &#x3D; pd.to_datetime(data[&#39;timestamp&#39;], infer_datetime_format&#x3D;True)</span><br><span class="line">    data[&#39;longitude&#39;] &#x3D; data[&#39;longitude&#39;].astype(float)</span><br><span class="line">    data[&#39;loadingOrder&#39;] &#x3D; data[&#39;loadingOrder&#39;].astype(str)</span><br><span class="line">    data[&#39;latitude&#39;] &#x3D; data[&#39;latitude&#39;].astype(float)</span><br><span class="line">    data[&#39;speed&#39;] &#x3D; data[&#39;speed&#39;].astype(float)</span><br><span class="line">    data[&#39;direction&#39;] &#x3D; data[&#39;direction&#39;].astype(float)</span><br><span class="line"></span><br><span class="line">    return dat</span><br><span class="line">def process(train_data):</span><br><span class="line">    train_data &#x3D; get_data(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line">    train_data &#x3D; train_data.dropna(axis&#x3D;0, how&#x3D;&#39;any&#39;)</span><br><span class="line">    train_data &#x3D; train_data.loc[train_data[&#39;TRANSPORT_TRACE&#39;].isin([&#39;CNYTN-MXZLO&#39;,&#39;CNSHK-MYTPP&#39;,&#39;CNSHK-SGSIN&#39;,&#39;CNSHK-CLVAP&#39;,&#39;CNYTN-ARENA&#39;,</span><br><span class="line">                                                                     &#39;CNYTN-MATNG&#39;,&#39;CNSHK-GRPIR&#39;,&#39;CNSHK-PKQCT&#39;,&#39;COBUN-HKHKG&#39;,&#39;CNYTN-PAONX&#39;,</span><br><span class="line">                                                                     &#39;CNSHK-SIKOP&#39;,&#39;CNYTN-CAVAN&#39;,&#39;CNSHK-ESALG&#39;,&#39;CNYTN-MTMLA&#39;,&#39;CNSHK-ZADUR&#39;,</span><br><span class="line">                                                                     &#39;CNSHK-LBBEY&#39;,&#39;CNSHA-SGSIN&#39;,&#39;CNYTN-RTM&#39;,&#39;CNHKG-MXZLO&#39;,&#39;HKHKG-FRFOS&#39;,</span><br><span class="line">                                                                     &#39;CNYTN-NZAKL&#39;,&#39;CNSHA-PAMIT&#39;])]</span><br><span class="line">    return train_data</span><br><span class="line"></span><br><span class="line">def get_train_data()</span><br><span class="line">    mylist&#x3D;[]</span><br><span class="line">    temp&#x3D;[]</span><br><span class="line">    i&#x3D;0 </span><br><span class="line">    for chunk in pd.read_csv(train_gps_path,chunksize&#x3D;1000000):</span><br><span class="line">        mylist&#x3D;chunk</span><br><span class="line">        mylist.columns &#x3D; [&#39;loadingOrder&#39;,&#39;carrierName&#39;,&#39;timestamp&#39;,&#39;longitude&#39;,</span><br><span class="line">                          &#39;latitude&#39;,&#39;vesselMMSI&#39;,&#39;speed&#39;,&#39;direction&#39;,&#39;vesselNextport&#39;,</span><br><span class="line">                          &#39;vesselNextportETA&#39;,&#39;vesselStatus&#39;,&#39;vesselDatasource&#39;,&#39;TRANSPORT_TRACE&#39;]</span><br><span class="line">        mylist&#x3D;process(mylist)</span><br><span class="line">        temp.append(mylist)</span><br><span class="line"></span><br><span class="line">    temp_df &#x3D; pd.concat(temp,axis&#x3D;0,ignore_index&#x3D;True)</span><br><span class="line">    temp_df.to_csv(&#39;data&#x2F;used&#x2F;train.csv&#39;)</span><br></pre></td></tr></table></figure>
<p>然后我们用筛选出的数据来分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">train_path &#x3D; &#39;data&#x2F;used&#x2F;train.csv&#39;</span><br><span class="line">train_data &#x3D; pd.read_csv(train_path,index_col&#x3D;0)</span><br><span class="line">train_data &#x3D; get_data(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line"></span><br><span class="line">test_data &#x3D; pd.read_csv(test_data_path)</span><br><span class="line">test_data &#x3D; get_data(test_data, mode&#x3D;&#39;test&#39;)</span><br><span class="line"></span><br><span class="line"># 代码参考：https:&#x2F;&#x2F;github.com&#x2F;juzstu&#x2F;TianChi_HaiYang</span><br><span class="line">def get_feature(df, mode&#x3D;&#39;train&#39;):</span><br><span class="line">    </span><br><span class="line">    assert mode&#x3D;&#x3D;&#39;train&#39; or mode&#x3D;&#x3D;&#39;test&#39;</span><br><span class="line">    </span><br><span class="line">    df.sort_values([&#39;loadingOrder&#39;, &#39;timestamp&#39;], inplace&#x3D;True)</span><br><span class="line">    # 特征只选择经纬度、速度\方向</span><br><span class="line">    df[&#39;lat_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;latitude&#39;].diff(1)</span><br><span class="line">    df[&#39;lon_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;longitude&#39;].diff(1)</span><br><span class="line">    df[&#39;speed_diff&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;speed&#39;].diff(1)</span><br><span class="line">    df[&#39;diff_minutes&#39;] &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].diff(1).dt.total_seconds() &#x2F;&#x2F; 60</span><br><span class="line">    df[&#39;anchor&#39;] &#x3D; df.apply(lambda x: 1 if x[&#39;lat_diff&#39;] &lt;&#x3D; 0.03 and x[&#39;lon_diff&#39;] &lt;&#x3D; 0.03</span><br><span class="line">                            and x[&#39;speed_diff&#39;] &lt;&#x3D; 0.3 and x[&#39;diff_minutes&#39;] &lt;&#x3D; 10 else 0, axis&#x3D;1)</span><br><span class="line">    </span><br><span class="line">    if mode&#x3D;&#x3D;&#39;train&#39;:</span><br><span class="line">        group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(&#123;&#39;mmax&#39;:&#39;max&#39;, &#39;count&#39;:&#39;count&#39;, &#39;mmin&#39;:&#39;min&#39;&#125;).reset_index()</span><br><span class="line">        # 读取数据的最大值-最小值，即确认时间间隔为label</span><br><span class="line">        group_df[&#39;label&#39;] &#x3D; (group_df[&#39;mmax&#39;] - group_df[&#39;mmin&#39;]).dt.total_seconds()</span><br><span class="line">    elif mode&#x3D;&#x3D;&#39;test&#39;:</span><br><span class="line">        group_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;timestamp&#39;].agg(&#123;&#39;count&#39;:&#39;count&#39;&#125;).reset_index()</span><br><span class="line">        </span><br><span class="line">    anchor_df &#x3D; df.groupby(&#39;loadingOrder&#39;)[&#39;anchor&#39;].agg(&#39;sum&#39;).reset_index()</span><br><span class="line">    anchor_df.columns &#x3D; [&#39;loadingOrder&#39;, &#39;anchor_cnt&#39;]</span><br><span class="line">    group_df &#x3D; group_df.merge(anchor_df, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line">    group_df[&#39;anchor_ratio&#39;] &#x3D; group_df[&#39;anchor_cnt&#39;] &#x2F; group_df[&#39;count&#39;]</span><br><span class="line"></span><br><span class="line">    agg_function &#x3D; [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;median&#39;] 。 </span><br><span class="line">    agg_col &#x3D; [&#39;latitude&#39;, &#39;longitude&#39;, &#39;speed&#39;, &#39;direction&#39;]</span><br><span class="line"></span><br><span class="line">    group &#x3D; df.groupby(&#39;loadingOrder&#39;)[agg_col].agg(agg_function).reset_index()</span><br><span class="line">    group.columns &#x3D; [&#39;loadingOrder&#39;] + [&#39;&#123;&#125;_&#123;&#125;&#39;.format(i, j) for i in agg_col for j in agg_function]</span><br><span class="line">    group_df &#x3D; group_df.merge(group, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line"></span><br><span class="line">    return group_df</span><br><span class="line">    </span><br><span class="line">train &#x3D; get_feature(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line">test &#x3D; get_feature(test_data, mode&#x3D;&#39;test&#39;)</span><br><span class="line">features &#x3D; [c for c in train.columns if c not in [&#39;loadingOrder&#39;, &#39;label&#39;, &#39;mmin&#39;, &#39;mmax&#39;, &#39;count&#39;]]</span><br><span class="line"></span><br><span class="line">def mse_score_eval(preds, valid):</span><br><span class="line">    labels &#x3D; valid.get_label()</span><br><span class="line">    scores &#x3D; mean_squared_error(y_true&#x3D;labels, y_pred&#x3D;preds)</span><br><span class="line">    return &#39;mse_score&#39;, scores, True</span><br><span class="line"></span><br><span class="line">def build_model(train, test, pred, label, seed&#x3D;1080, is_shuffle&#x3D;True):</span><br><span class="line">    train_pred &#x3D; np.zeros((train.shape[0], ))</span><br><span class="line">    test_pred &#x3D; np.zeros((test.shape[0], ))</span><br><span class="line">    n_splits &#x3D; 10</span><br><span class="line">    # Kfold</span><br><span class="line">    fold &#x3D; KFold(n_splits&#x3D;n_splits, shuffle&#x3D;is_shuffle, random_state&#x3D;seed)</span><br><span class="line">    kf_way &#x3D; fold.split(train[pred])</span><br><span class="line">    # params</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;learning_rate&#39;: 0.01,</span><br><span class="line">        &#39;boosting_type&#39;: &#39;gbdt&#39;,</span><br><span class="line">        &#39;objective&#39;: &#39;regression&#39;,</span><br><span class="line">        &#39;num_leaves&#39;: 36,</span><br><span class="line">        &#39;feature_fraction&#39;: 0.6,</span><br><span class="line">        &#39;bagging_fraction&#39;: 0.7,</span><br><span class="line">        &#39;bagging_freq&#39;: 6,</span><br><span class="line">        &#39;seed&#39;: 8,</span><br><span class="line">        &#39;bagging_seed&#39;: 1,</span><br><span class="line">        &#39;feature_fraction_seed&#39;: 7,</span><br><span class="line">        &#39;min_data_in_leaf&#39;: 20,</span><br><span class="line">        &#39;nthread&#39;: 8,</span><br><span class="line">        &#39;verbose&#39;: 1,</span><br><span class="line">    &#125;</span><br><span class="line">    # train</span><br><span class="line">    for n_fold, (train_idx, valid_idx) in enumerate(kf_way, start&#x3D;1):</span><br><span class="line">        train_x, train_y &#x3D; train[pred].iloc[train_idx], train[label].iloc[train_idx]</span><br><span class="line">        valid_x, valid_y &#x3D; train[pred].iloc[valid_idx], train[label].iloc[valid_idx]</span><br><span class="line">        # 数据加载</span><br><span class="line">        n_train &#x3D; lgb.Dataset(train_x, label&#x3D;train_y)</span><br><span class="line">        n_valid &#x3D; lgb.Dataset(valid_x, label&#x3D;valid_y)</span><br><span class="line"></span><br><span class="line">        clf &#x3D; lgb.train(</span><br><span class="line">            params&#x3D;params,</span><br><span class="line">            train_set&#x3D;n_train,</span><br><span class="line">            num_boost_round&#x3D;3000,</span><br><span class="line">            valid_sets&#x3D;[n_valid],</span><br><span class="line">            early_stopping_rounds&#x3D;100,</span><br><span class="line">            verbose_eval&#x3D;100,</span><br><span class="line">            feval&#x3D;mse_score_eval</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        train_pred[valid_idx] &#x3D; clf.predict(valid_x, num_iteration&#x3D;clf.best_iteration)</span><br><span class="line">        test_pred +&#x3D; clf.predict(test[pred], num_iteration&#x3D;clf.best_iteration)&#x2F;fold.n_splits</span><br><span class="line">    </span><br><span class="line">    test[&#39;label&#39;] &#x3D; test_pred</span><br><span class="line">    </span><br><span class="line">    return test[[&#39;loadingOrder&#39;, &#39;label&#39;]]</span><br><span class="line"></span><br><span class="line">result &#x3D; build_model(train, test, features, &#39;label&#39;, is_shuffle&#x3D;True)</span><br><span class="line"></span><br><span class="line">test_data &#x3D; test_data.merge(result, on&#x3D;&#39;loadingOrder&#39;, how&#x3D;&#39;left&#39;)</span><br><span class="line">test_data[&#39;ETA&#39;] &#x3D; (test_data[&#39;onboardDate&#39;] + test_data[&#39;label&#39;].apply(lambda x:pd.Timedelta(seconds&#x3D;x))).apply(lambda x:x.strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;))</span><br><span class="line">test_data.drop([&#39;direction&#39;,&#39;TRANSPORT_TRACE&#39;],axis&#x3D;1,inplace&#x3D;True)</span><br><span class="line">test_data[&#39;onboardDate&#39;] &#x3D; test_data[&#39;onboardDate&#39;].apply(lambda x:x.strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;))</span><br><span class="line">test_data[&#39;creatDate&#39;] &#x3D; pd.datetime.now().strftime(&#39;%Y&#x2F;%m&#x2F;%d  %H:%M:%S&#39;)</span><br><span class="line">test_data[&#39;timestamp&#39;] &#x3D; test_data[&#39;temp_timestamp&#39;]</span><br><span class="line"># 整理columns顺序</span><br><span class="line">result &#x3D; test_data[[&#39;loadingOrder&#39;, &#39;timestamp&#39;, &#39;longitude&#39;, &#39;latitude&#39;, &#39;carrierName&#39;, &#39;vesselMMSI&#39;, &#39;onboardDate&#39;, &#39;ETA&#39;, &#39;creatDate&#39;]]</span><br><span class="line"></span><br><span class="line">result.to_csv(&#39;result.csv&#39;, index&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>经过初步数据筛选后，得出评分MSE：46448.0950</p>
</li>
</ul>
<p>相较于Baseline有较大提升</p>
<h3 id="2-特征工程"><a href="#2-特征工程" class="headerlink" title="2. 特征工程"></a>2. 特征工程</h3><p>在清洗完数据后，我们应该结合数据挑选出相应特征来表征数据，特征的选取十分重要，直接影响到了最后模型的预测结果</p>
<h3 id="2-1-baseline里所使用的特征"><a href="#2-1-baseline里所使用的特征" class="headerlink" title="2.1 baseline里所使用的特征"></a>2.1 baseline里所使用的特征</h3><ol>
<li>anchor_cnt : 所有航次的锚点数，停船数</li>
<li>anchor_ratio : 停船率</li>
<li>latitude_min </li>
<li>latitude_max</li>
<li>latitude_mean</li>
<li>latitude_median</li>
<li>longitude_min</li>
<li>longitude_max</li>
<li>longitude_mean</li>
<li>longitude_median</li>
<li>speed_min</li>
<li>speed_max</li>
<li>speed_mean</li>
<li>speed_median</li>
<li>direction_min</li>
<li>direction_max</li>
<li>direction_mean</li>
<li>direction_median</li>
</ol>
<p>basline利用了基本特征的各种统计量</p>
<h3 id="2-2-合理构建新特征"><a href="#2-2-合理构建新特征" class="headerlink" title="2.2 合理构建新特征"></a>2.2 合理构建新特征</h3><p><strong>根据2020智慧海洋top5方案，添加相应特征：</strong></p>
<ol>
<li><p>在统计量中添加峰度和偏度</p>
</li>
<li><p>两个经纬之间的haversine距离和其相关统计量</p>
</li>
</ol>
<p><strong>根据周星星第二名</strong></p>
<ol>
<li>添加加速度及相关统计量</li>
</ol>
<p><strong>根据2020智慧海洋top1方案</strong></p>
<h3 id="1-基于轨迹序列和相对位置的符合向量编码"><a href="#1-基于轨迹序列和相对位置的符合向量编码" class="headerlink" title="1. 基于轨迹序列和相对位置的符合向量编码"></a>1. 基于轨迹序列和相对位置的符合向量编码</h3><p><img src="https://note.youdao.com/yws/api/personal/file/830EA0D9A5A744ACA6E5C939C18354AC?method=download&shareKey=1651238ae54291e492f2e568d8e3e179" alt="%E7%BC%96%E7%A0%81.jpg"></p>
<p>因为经纬度常规的统计特征对船舶轨迹的表征能力其实是有限的，其设计了一种轨道序列的编码方式，进一步刻画了轨迹的动态信息和船舶经过的每个点之间的联系。</p>
<p><strong>输入层</strong><br>渔船的轨迹序列</p>
<p><strong>数据处理层</strong><br><strong>1. Geohash7编码：</strong>Geohash其实是将地图拆分成了一个个矩形网络，当经纬度落入到某个网格内时，则使用网格的编码代替经纬度，相当于是一种聚类方式。这里我们不直接使用经纬度（细粒度）的好处就是可以提高特征的泛化能力。<br><img src="https://note.youdao.com/yws/api/personal/file/D10C2F58138443F9A336388638489DBE?method=download&shareKey=6b7bda804562a28ea5b906df4f9fa092" alt="geohash.jpg"></p>
<p>除此之外，还采用了全集和下采样两种提取方式来提取Geohash7编码后的轨迹序列，下采样的好处是缓解船舶位置信息频繁上报而产生的噪音。</p>
<p><strong>2. 梯度编码：</strong>轨迹序列的梯度是指后一个位置相对于前一个位置的变化，目的是为了获取相对位置信息</p>
<p>$$f_i^{(1)}=\frac{f(x_{i+1})-f(x_{x_i-1})}{2h}+O(h^2)$$</p>
<p><strong>特征编码层</strong></p>
<p><strong>1. Word2Vec：将船舶的轨迹序列当成文本，每个地点则是一个“词语”，使用Word2Vec进行向量表征</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def w2v_feat(df, group_id, feat, length):</span><br><span class="line">    print(&#39;start word2vec ...&#39;)</span><br><span class="line">    data_frame &#x3D; df.groupby(group_id)[feat].agg(list).reset_index()</span><br><span class="line">    model &#x3D; Word2Vec(data_frame[feat].values, size&#x3D;length, window&#x3D;5, min_count&#x3D;1, sg&#x3D;1, hs&#x3D;1,</span><br><span class="line">                     workers&#x3D;1, iter&#x3D;10, seed&#x3D;1, hashfxn&#x3D;hashfxn)</span><br><span class="line">    data_frame[feat] &#x3D; data_frame[feat].apply(lambda x: pd.DataFrame([model[c] for c in x]))</span><br><span class="line">    for m in range(length):</span><br><span class="line">        data_frame[&#39;w2v_&#123;&#125;_mean&#39;.format(m)] &#x3D; data_frame[feat].apply(lambda x: x[m].mean())</span><br><span class="line">    del data_frame[feat]</span><br><span class="line">    return data_frame</span><br></pre></td></tr></table></figure>
<p><strong>2. Node2Vec：</strong>把渔船经过的地点当成图中的“点”，而不同地点之间的关系则是“边”，使用Node2Vec进行向量表征。</p>
<p><strong>3. TFIDF&amp;CountVec：</strong>借鉴了文本的常用处理方法，提取了渔船轨迹序列中Geohash的频次信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def tfidf(input_values, output_num, output_prefix, seed&#x3D;1024):</span><br><span class="line">    tfidf_enc &#x3D; TfidfVectorizer()</span><br><span class="line">    tfidf_vec &#x3D; tfidf_enc.fit_transform(input_values)</span><br><span class="line">    svd_enc &#x3D; TruncatedSVD(n_components&#x3D;output_num, n_iter&#x3D;20, random_state&#x3D;seed)</span><br><span class="line">    svd_tmp &#x3D; svd_enc.fit_transform(tfidf_vec)</span><br><span class="line">    svd_tmp &#x3D; pd.DataFrame(svd_tmp)</span><br><span class="line">    svd_tmp.columns &#x3D; [&#39;&#123;&#125;_tfidf_&#123;&#125;&#39;.format(output_prefix, i) for i in range(output_num)]</span><br><span class="line">    return svd_tmp</span><br></pre></td></tr></table></figure>

<p><strong>输出层：</strong></p>
<p>轨迹序列Embedding向量</p>
<p>（top1和top5方案均采用了编码、降维方法，可以借鉴）</p>
<h3 id="2-Turning状态特征"><a href="#2-Turning状态特征" class="headerlink" title="2. Turning状态特征"></a>2. Turning状态特征</h3><p>将数值的方向特征进行离散化处理后，统计船舶航行过程中不同方向的频次及比例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def turning(data):</span><br><span class="line">    data[&#39;方向&#39;] &#x3D; data[&#39;方向&#39;].apply(lambda x:(int(round(x&#x2F;30)))*30)</span><br><span class="line">    degree_df &#x3D; data.pivot_table(index&#x3D;&#39;渔船ID&#39;,columns&#x3D;&#39;方向&#39;,values&#x3D;&#39;lat&#39;, dropna&#x3D;False, aggfunc&#x3D;&#39;count&#39;).fillna(0)</span><br><span class="line">    degree_df.columns &#x3D; [str(f)+&#39;_方向_count&#39; for f in degree_df.columns]</span><br><span class="line">    degree_df.reset_index(inplace&#x3D;True)</span><br><span class="line">    return degree_df</span><br></pre></td></tr></table></figure>

<h3 id="3-速度的分位数特征"><a href="#3-速度的分位数特征" class="headerlink" title="3. 速度的分位数特征"></a>3. 速度的分位数特征</h3><p>船舶数据中速度存在大量为0的记录，可能会对均值方差等统计量产生较大的影响，是否单独取速度大于0的样本对速度构造统计特征，有待进一步的实验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def spped(data):</span><br><span class="line">    group_df &#x3D; data[data[&#39;速度&#39;]&gt;0].groupby([&#39;渔船ID&#39;])[&#39;速度&#39;].agg(&#123;</span><br><span class="line">        &#39;速度_mean_new&#39;: &#39;mean&#39;,</span><br><span class="line">        &#39;速度_q10_new&#39;: lambda x: np.quantile(x, 0.10),</span><br><span class="line">        &#39;速度_q20_new&#39;: lambda x: np.quantile(x, 0.20),</span><br><span class="line">        &#39;速度_q30_new&#39;: lambda x: np.quantile(x, 0.30),</span><br><span class="line">        &#39;速度_q40_new&#39;: lambda x: np.quantile(x, 0.40),</span><br><span class="line">        &#39;速度_q50_new&#39;: lambda x: np.quantile(x, 0.50),</span><br><span class="line">        &#39;速度_q60_new&#39;: lambda x: np.quantile(x, 0.60),</span><br><span class="line">        &#39;速度_q70_new&#39;: lambda x: np.quantile(x, 0.70),</span><br><span class="line">        &#39;速度_q80_new&#39;: lambda x: np.quantile(x, 0.80),</span><br><span class="line">        &#39;速度_q90_new&#39;: lambda x: np.quantile(x, 0.90),</span><br><span class="line">    &#125;).reset_index()</span><br><span class="line">    return group_df</span><br></pre></td></tr></table></figure>
<p><strong>根据参考文献</strong></p>
<ol>
<li>航速变化率和航向变化率</li>
</ol>
<p><strong>其它想法</strong></p>
<ol>
<li>航线编码： 因为不同航线的轨迹变化较大，对航线进行离散化处理并热编码，添加航线特征</li>
</ol>
<h3 id="2-3-特征筛选"><a href="#2-3-特征筛选" class="headerlink" title="2.3 特征筛选"></a>2.3 特征筛选</h3><p>根据上述构建并添加相应特征，并在众多特征中，利用特征重要性和相关性来筛选出对预测结果影响较大的特征，构建模型。</p>
<h3 id="1-基于学习模型的特征排序（Model-base-ranking）"><a href="#1-基于学习模型的特征排序（Model-base-ranking）" class="headerlink" title="1 基于学习模型的特征排序（Model base ranking）"></a>1 基于学习模型的特征排序（Model base ranking）</h3><p>这种方法的思路是直接使用你要用的机器学习算法，针对每个单独的特征和响应变量建立预测模型。其实Pearson相关系数等价于线性回归里的标准化回归系数。假如某个特征和响应变量之间的关系是非线性的，可以用基于树的方法（决策树、随机森林）、或者扩展的线性模型等。基于树的方法比较易于使用，因为他们对非线性关系的建模比较好，并且不需要太多的调试。但要注意过拟合问题，因此树的深度最好不要太大，再就是运用交叉验证。</p>
<p>因此我们尝试使用lgbm来生成特征的重要性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">X_train, X_test, y_train, y_test &#x3D; train_test_split(train[features], train[&#39;label&#39;], test_size&#x3D;0.2, random_state&#x3D;42)</span><br><span class="line">print(&quot;X_train shape is: &quot; + str(X_train.shape))</span><br><span class="line">print(&quot;X_test shape is: &quot; + str(X_test.shape))</span><br><span class="line"></span><br><span class="line">gbm &#x3D; lgb.LGBMRegressor(objective&#x3D;&#39;regression&#39;,</span><br><span class="line">                            max_depth&#x3D;6, </span><br><span class="line">                            learning_rate&#x3D;0.1, </span><br><span class="line">                            n_estimators&#x3D;150, </span><br><span class="line">                            min_child_weight&#x3D;4)</span><br><span class="line">lgb_model &#x3D; gbm.fit(X_train, y_train)</span><br><span class="line">y_predict &#x3D; gbm.predict(X_test)</span><br><span class="line">mse &#x3D; mean_squared_error(y_test, y_predict)</span><br><span class="line">print(&quot;MSE: %.4f&quot; % mse)</span><br><span class="line"></span><br><span class="line">lgb_predictors &#x3D; [i for i in train[features].columns]</span><br><span class="line">lgb_feat_imp &#x3D; pd.Series(lgb_model.feature_importances_, lgb_predictors).sort_values(ascending&#x3D;False)</span><br><span class="line">lgb_feat_imp.to_csv(&#39;data&#x2F;features&#x2F;lgb_feat_imp.csv&#39;)</span><br></pre></td></tr></table></figure>
<p>生成特征重要性表后，我们尝试使用前30个特征</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">features &#x3D; pd.read_csv(&#39;data&#x2F;features&#x2F;lgb_feat_imp.csv&#39;, header&#x3D;None)</span><br><span class="line">features &#x3D; features.iloc[0:30,0]</span><br><span class="line">features &#x3D; features.values.tolist()</span><br><span class="line"></span><br><span class="line">train_path &#x3D; &#39;data&#x2F;used&#x2F;train.csv&#39;</span><br><span class="line">test_data_path &#x3D; &#39;data&#x2F;A_testData0531.csv&#39;</span><br><span class="line"></span><br><span class="line">train_data &#x3D; pd.read_csv(train_path, index_col&#x3D;0)</span><br><span class="line">train_data &#x3D; get_data(train_data, mode&#x3D;&#39;train&#39;)</span><br><span class="line"></span><br><span class="line">test_data &#x3D; pd.read_csv(test_data_path)</span><br><span class="line">test_data &#x3D; get_data(test_data, mode&#x3D;&#39;test&#39;)</span><br></pre></td></tr></table></figure>

<p>至此，对于赛题的完整分析流程已经结束，对于之前选取的训练集对训练集的拟合效果大致维持在这个水平上</p>
<p>想要进一步较大的提升精度，有以下优化改进</p>
<h3 id="1-进一步观察数据集，清洗出对测试集拟合效果更好的训练数据"><a href="#1-进一步观察数据集，清洗出对测试集拟合效果更好的训练数据" class="headerlink" title="1. 进一步观察数据集，清洗出对测试集拟合效果更好的训练数据"></a>1. 进一步观察数据集，清洗出对测试集拟合效果更好的训练数据</h3><p>根据之前删除任意字段存在空值的数据，并筛选出对应航线后，只剩下718个不同航次的训练数据，这显然有点太少了，因此需要将筛选数据条件放宽限一点</p>
<h3 id="2-优化训练集标签Label值的计算方式"><a href="#2-优化训练集标签Label值的计算方式" class="headerlink" title="2. 优化训练集标签Label值的计算方式"></a>2. 优化训练集标签Label值的计算方式</h3><p>baseline在标定label时，直接使用的是船舶AIS信息中时间戳的最大值-最小值，这种计算方式可能不太合理，有可能船舶缺失到港数据，又或者船舶到港时间停留太久，都会造成label的不准确，因此我们需要进一步优化计算label的方法</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（七）无监督学习</title>
    <url>/2020/08/05/Unsupervised/</url>
    <content><![CDATA[<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>在“无监督学习”中，训练样本的标记信息时未知的，目标是通过对无标记训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础</p>
<h3 id="1-聚类算法"><a href="#1-聚类算法" class="headerlink" title="1 聚类算法"></a>1 聚类算法</h3><h4 id="1-1-K-means"><a href="#1-1-K-means" class="headerlink" title="1.1 K-means"></a>1.1 K-means</h4><table>
<thead>
<tr>
<th align="left">关键概念：簇与质心</th>
</tr>
</thead>
<tbody><tr>
<td align="left">KMeans算法将一组N个样本的特征矩阵X划分为K个无交集的簇，直观上来看是簇是一组一组聚集在一起的数据，在一个簇中的数据就认为是同一类。簇就是聚类的结果表现。簇中所有数据的均值\mu_j通常被称为这个簇的“质心”（centroids）。在一个二维平面中，一簇数据点的质心的横坐标就是这一簇数据点的横坐标的均值，质心的纵坐标就是这一簇数据点的纵坐标的均值。同理可推广至高维空间。</td>
</tr>
<tr>
<td align="left"><a id="more"></a></td>
</tr>
</tbody></table>
<p>K-means具体步骤如下：</p>
<ol>
<li>随机抽取K个样本作为最初的质心</li>
<li>开始循坏：<ul>
<li>将每个样本点分配到离他们最近的质心，生成K个簇</li>
<li>对于每个簇，计算所有被分到该簇的样本点的平均值作为新的质心</li>
</ul>
</li>
<li>当质心的位置不再发生变化，迭代停止，聚类完成</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/32020546C1AE4109A10AF82CB9898E86?method=download&shareKey=cd5356c9150e5202cc049f0c226a91c2" alt></p>
<p>令$x$表示簇找那个的一个样本点，$mu$表示簇中的质心，$n$表示每个样本点钟的特征数目，$i$表示成点$x$的每个特征，则该样本点到质心的距离可以由一下距离来度量</p>
<p>$$欧几里得距离：d(x,\mu)=\sqrt{\sum_{i=1}^n(x_i-\mu_i)^2}$$</p>
<p>$$欧几里得距离：d(x,\mu)=\sum_{i=1}^n(|x_i-\mu_i|)$$</p>
<p>$$余弦距离：cos\theta = \frac{\sum_1^n(x_i * \mu)}{\sqrt{\sum_1^n(x_i)^2} * \sqrt{\sum_1^n(\mu)^2}}$$</p>
<p>如果我们采用欧几里得距离，则一个簇中所有样本点到质心的距离平方和为</p>
<p>$$Cluster Sum of Square (CSS) = \sum_{j=0}^n\sum_{i=1}^n(x_i-u_i)^2$$<br>$$Total Cluster Sum of Square = \sum_{l=1}^k CSS_l$$</p>
<p>其中,$m$为一个簇中样本的个数，$j$是每个样本的编号。将整个数据集中的所有簇的簇内平方和相加，就得到了整体平方和（Total Cluster Sum of Square），KMeans追求的是能让整体平方和最小的质心</p>
<h4 id="1-2-DBSCAN"><a href="#1-2-DBSCAN" class="headerlink" title="1.2 DBSCAN"></a>1.2 DBSCAN</h4><p>DBSCAN基于“领域”参数（$\epsilon,MinPts$）来刻画样本分布的紧密程度</p>
<p>|关键概念|<br>|:–|:–|<br>|$\epsilon-$领域|样本集中$x_j$的距离不大于$\epsilon$的样本|<br>|核心对象|若$x_j$的$\epsilon-$领域至少包含MinPts个样本|<br>|密度直达|若$x_j$位于$\epsilon-$领域中，且$x_j$是核心对象，则称$x_j,x_i$密度直达|<br>|密度可达|对$x_i,x_j$存在样本序列$p_1,p_2,\dots,p_n$，其中$p_1=x_i,p_n=x_j$且$p_{i+1}$由$p_i$密度直达|<br>|密度相连|$x_i,x_j$存在$x_k$使得$x_i,x_j$由$x_k$密度可达|</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/3CFC7255AEF5494EA28847EF8F53B986?method=download&shareKey=d0ab0fa0be730535ee659da645a0ca7d" alt></p>
<p>DBSCAN具体步骤如下：</p>
<p>1.找寻核心点形成临时聚类簇</p>
<p>扫描全部样本点，如果某个样本点R半径范围内点数目大于等于MinPoints，则将其纳入核心点列表，并将其密度直达的点形成对应的临时聚类簇</p>
<p>2.合并临时聚类簇得到聚类簇</p>
<p>对于每一个临时聚类簇，检测其中的点是否为核心点，如果是，将该点对应的临时聚类簇和当前临时聚类簇合并，得到新的临时聚类簇</p>
<p>重复此操作，直到当前临时聚类簇的每一个点要么不在核心点列表，要么密度直达的点都已经在该临时聚类簇，该临时聚类簇升级成为聚类簇</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/77CEBDB3B8164208AF15C9BF40488424?method=download&shareKey=012cf4c589db2cea9df552ad9aa29fe7" alt></p>
<h4 id="1-3-层次聚类AGNES"><a href="#1-3-层次聚类AGNES" class="headerlink" title="1.3 层次聚类AGNES"></a>1.3 层次聚类AGNES</h4><p>AGNES是一种采用自底向上聚合策略的层次聚类算法，先将数据集中的每个样本看做一个初始聚类簇，然后在算法运行的每一步中找出距离最近的两个聚类簇进行合并，该过程不断重复，直到达到预设的簇类簇个数</p>
<p>关键是如何计算簇类簇之间的距离，实际上，每个簇是一个样本集合，因此，只需采用关于集合的某种距离即可，给定聚类簇$c_i,c_j$通过下面式子来计算距离：</p>
<p>$$最小距离：d_{min}(c_i,c_j)=\min_{x\in c_i,z\in c_j}dist(x,z)$$<br>$$最大距离：d_{max}(c_i,c_j)=\max_{x\in c_i,z\in c_j}dist(x,z)$$<br>$$平均距离：d_{avg}(c_i,c_j)=\frac{1}{|c_i||c_j|}\sum_{x\in c_i}\sum_{z\in c_j}dist(x,z)$$</p>
<h3 id="2-降维算法"><a href="#2-降维算法" class="headerlink" title="2 降维算法"></a>2 降维算法</h3><h4 id="2-1-PCA所需数学原理"><a href="#2-1-PCA所需数学原理" class="headerlink" title="2.1 PCA所需数学原理"></a>2.1 PCA所需数学原理</h4><p>主成份分析，简称为PCA，是一种非监督学习算法，经常被用来进行</p>
<ul>
<li><p>数据降维</p>
</li>
<li><p>有损数据压缩</p>
</li>
<li><p>特征抽取</p>
</li>
<li><p>数据可视化</p>
</li>
</ul>
<p>通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。</p>
<p>由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：</p>
<ul>
<li>基于特征值分解协方差矩阵实现PCA算法</li>
<li>基于SVD分解协方差矩阵实现PCA算法。</li>
</ul>
<h5 id="2-1-1-特征值、特征向量、特征值分解"><a href="#2-1-1-特征值、特征向量、特征值分解" class="headerlink" title="2.1.1 特征值、特征向量、特征值分解"></a>2.1.1 特征值、特征向量、特征值分解</h5><p>1.特征值、特征向量</p>
<p>如果一个向量v是矩阵A的特征向量，将一定可以表示成下面的形式：<br>$$Av=\lambda v$$<br>其中，$\lambda$是特征向量$v$对应的特征值，一个矩阵的一组特征向量是一组正交向量</p>
<p>2.特征值分解</p>
<p>对于矩阵A，有一组特征向量v，将这组向量进行正交单位化，就能得到一组正交单位向量。特征值分解，就是将矩阵A分解为如下式：<br>$$A=Q\Sigma Q^{-1}$$<br>其中，Q是矩阵A的特征向量组成的矩阵，$\Sigma$则是一个对角阵，对角线上的元素就是特征值。我们来分析一下特征值分解的式子，分解得到的$\Sigma$矩阵是一个对角阵，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变换方向（从主要的变化到次要的变化排列）</p>
<p>当矩阵是高维的情况下，那么这个矩阵就是高维空间下的一个线性变换，这个线性变换可能没法通过图片来表示，但是可以想象，这个变换也同样有很多的变化方向，我们通过特征值分解得到的钱N个特征向量，就对应了这个矩阵最重要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵变换，也就是之前说的：<strong>提取这个矩阵最重要的特征</strong>。</p>
<p><strong>总结</strong>：特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多么重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间，我们可以利用这些线性的子空间干很多事情。不过，<strong>特征值分解也有很多局限，比如说变换的矩阵必须是方阵。</strong></p>
<h5 id="2-1-2-SVD分解"><a href="#2-1-2-SVD分解" class="headerlink" title="2.1.2 SVD分解"></a>2.1.2 SVD分解</h5><p>1.特征值分解矩阵的缺点</p>
<p>我们前面讲了很多特征值、特征向量和特征值分解，而且基于我们以前学习的线性代数知识、利用特征值分解提取特征矩阵是一个容易理解并且便于实现的方法。但是为什么还存在奇异值分解呢？特征值分解最大的问题是只能针对方阵，即$n*n$的矩阵，而在实际的应用中，我们分解的大部分都不是方阵。</p>
<p><strong>举个例子：</strong><br>关系型数据库中的某一张表的数据存储结构类似于一个二维矩阵，假设这个表有m行，有n个字段，那么这个表数据矩阵规模就是$m*n$。很明显，在绝大部分情况下，m和n是不相等的。如果这个时候要对这个矩阵进行特征提取，特征值分解的方法明显就不行了。此时，就可以用SVD对非方阵进行分解。</p>
<p>2.奇异值分解</p>
<p>奇异值分解是一个能使用与任意矩阵的一种分解方式，对于任意矩阵A总是存在一个奇异值分解：</p>
<p>$$A=U\Sigma V^T$$</p>
<p>假设A是一个$m * n$的矩阵，那么得到的U是一个$m * m$的方阵，U里面的正交向量被称为左奇异向量。$\Sigma$是一个$m*n$的矩阵，<br>$\Sigma$除了对角线其他元素都为0，对角线上的元素称为奇异值。</p>
<p><strong>思考：</strong>虽说上面奇异值分解等式成立，但是如何求得左奇异值向量、右奇异值向量和奇异值呢？<br><strong>答案：</strong>由上面的奇异值分解等式，我们是不知道如何拆分矩阵A的。我们可以把奇异值和特征值联系起来。<br>首先，我们用矩阵A的转置乘以A，得到一个方阵，用这样的方阵进行特征分解，得到的特征值和特征向量满足下面的等式：<br>$$(A^TA)v_i=\lambda_iv_i$$<br>这里的$v_i$就是我们要求的右奇异向量。<br>其次，我们将A和A的转置做矩阵的乘法，得到一个方阵，用这样的方阵进行特征分解，得到的特征和特征向量满足下面的等式：<br>$$(AA^T)u_i=\lambda_iu_i$$<br>这里的$u_i$就是左奇异向量。<br><strong>思考：</strong>上面我们说$A^TA$的特征向量组成的矩阵是我们SVD中的V矩阵，而$AA^T$的特征向量组成的就是我们SVD的U矩阵，这有什么根据么？我们来证明一下，以V举证的证明为例：<br>$$A=U\Sigma V^T\Rightarrow A^T=V\Sigma^TU^T\Rightarrow A^TA=V\Sigma^TU^TU\Sigma V^T=V\Sigma^2V^T$$</p>
<p>上式证明中使用了$U^TU=I,\Sigma^T\Sigma=\Sigma^2$,可以看出，$A^TA$的特征向量组成的矩阵就是我们SVD中的V矩阵，而$AA^T$的特征向量组成的就是我们SVD中的U矩阵。</p>
<p><strong>补充定义：</strong><br>$$U\in M_n(R)满足U^TU=I，则U是实正交矩阵$$<br>此外，我们还可以得到奇异值，奇异值求法有两种：</p>
<p><strong>a)第一种：</strong><br>$$A=U\Sigma V^T\Rightarrow AV\Rightarrow U\Sigma V^TV\Rightarrow AV = U\Sigma\Rightarrow Av_i=\sigma u_i\Rightarrow \sigma_i=\frac{Av_i}{u_i}$$</p>
<p><strong>b)第二种</strong> </p>
<p>通过上面的证明，我们还可以看出，特征值举证等于奇异值矩阵的平方，也就是说特征值和奇异值满足如下关系：<br>$$\sigma_i=\sqrt{\lambda_i}$$<br>这里的$\sigma_i$就是奇异值，奇异值$\sigma_i$跟特征值类似，在矩阵$\Sigma$中也是从大到小排列。</p>
<p><strong>思考：</strong><br>我们已经知道如何用奇异值分解任何矩阵了，那么问题又来了，一个m<em>n的矩阵A，你把它分解成m</em>m的矩阵U、m<em>n的矩阵$\Sigma$和n</em>n的矩阵$V^T$</p>
<p>这三个矩阵中任何一个的维度似乎一点也不比A的维度小，而且还要做两次矩阵的乘法，这不是把简单的事情变得更加复杂了吗？</p>
<p><strong>答案：</strong><br>在奇异值分解矩阵中$\Sigma$里面的奇异值按从大到小的顺序排列，奇异值$\sigma_i$从大到小的顺序减小的特别快。<strong>在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上，也就是说，剩下的90%甚至99%的奇异值几乎没有什么作用。</strong>因此，我们可以用前面r个打的奇异值来近似描述矩阵，于是奇异值分解公式可以写成如下：</p>
<p>$$A_{m * n}\approx U_{m * n}\Sigma_{r * r}V_{r * n}^T$$</p>
<p>其中r是一个远远小于m和n的数，右边的三个举证相乘的结果会将使一个接近A的矩阵。如果r越接近于n，则相乘的结果越接近于A。如果r的取值远远小于n，从计算机内存的角度来说，右边三个矩阵的存储内存要远远小于矩阵A的。<strong>所以在奇异值分解中r的取值很重要，就是在计算精度和事件空间之间做选择。</strong></p>
<h5 id="2-1-3-协方差和散度矩阵"><a href="#2-1-3-协方差和散度矩阵" class="headerlink" title="2.1.3 协方差和散度矩阵"></a>2.1.3 协方差和散度矩阵</h5><p><strong>样本均值：</strong></p>
<p>$$\bar x = \frac{1}{n}\sum_{i=1}^Nx_i$$</p>
<p><strong>样本方差：</strong><br>$$S^2=\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar x)^2$$</p>
<p><strong>样本X和样本Y的协方差</strong></p>
<p>$$Cov(X,Y)=E[(X-E(X))(Y-E(Y))]=\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar x)(y_i-\bar y)$$</p>
<p>由上面的公式，我们可以得到以下结论：</p>
<p>（1）方差的计算公式是针对一维特征，即针对同一特征不同样本的取值来进行计算得到；而协方差则必须要求至少满足二维特征；方差是协方差的特殊情况。</p>
<p>（2）方差和协方差的除数是n-1，这是为了得到方差和协方差的无偏估计。</p>
<p>协方差为正时，说明X和Y是正相关关系；协方差为负时，说明X和Y是负相关关系；协方差为0时，说明X和Y是相互独立。Cov(X,X)就是X的方差。当样本是n维数据时，它们的协方差实际上式协方差矩阵（对称方阵）。例如，对于3维数据（x,y,z），计算它的协方差就是：</p>
<p>$$<br>Cov(X,Y,Z)=\begin{bmatrix}<br>Cov(x,x) &amp; Cov(x,y) &amp;Cov(x,z) \\<br>Cov(y,x) &amp; Cov(y,y) &amp; Cov(y,x)\\<br>Cov(z,x) &amp; Cov(z,x) &amp; Cov(z,z)<br>\end{bmatrix}<br>$$</p>
<p><strong>散度矩阵定义为：</strong><br>$$S=\sum_{k=1}^n(x_k-m)(x_k-m)^T$$</p>
<p>$$m=\frac{1}{n}\sum_{k=1}^nx_k$$</p>
<p>对于数据X的<strong>散度矩阵为：</strong>$$XX^T$$</p>
<p>其实协方差矩阵和三都矩阵关系密切，散度矩阵就是协方差矩阵乘以（总数据量-1）。因此它们的特征值和特征向量是一样的。这里值得注意的是，散度矩阵是SVD奇异值分解的一步，因此PCA和SVD是由很大联系的。</p>
<h4 id="2-2-PCA算法两种实现方法"><a href="#2-2-PCA算法两种实现方法" class="headerlink" title="2.2 PCA算法两种实现方法"></a>2.2 PCA算法两种实现方法</h4><h5 id="2-2-1-基于特征值分解协方差矩阵实现PCA算法"><a href="#2-2-1-基于特征值分解协方差矩阵实现PCA算法" class="headerlink" title="2.2.1 基于特征值分解协方差矩阵实现PCA算法"></a>2.2.1 基于特征值分解协方差矩阵实现PCA算法</h5><p>输入数据集：<br>$$X={x_1,x_2,x_3,\dots,x_n}$$</p>
<p>需要降到K维</p>
<ol>
<li><p>去平均值（即去中心化），即每一位特征减去各自的平均值</p>
</li>
<li><p>计算协方差矩阵$$\frac{1}{n}XX^T$$</p>
<p> 注：这里除或不除n或n-1，其实对求出的特征向量没有影响。</p>
</li>
<li><p>用特征值分解方法求协方差矩阵</p>
<p> $$\frac{1}{n}XX^T$$的特征值与特征向量。</p>
</li>
<li><p>对特征值从大到小排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P。</p>
</li>
<li><p>将数据转换到k个特征向量构建的新空间中，即Y=PX。</p>
</li>
</ol>
<h5 id="2-2-2-基于SVD分解协方差矩阵实现PCA算法"><a href="#2-2-2-基于SVD分解协方差矩阵实现PCA算法" class="headerlink" title="2.2.2 基于SVD分解协方差矩阵实现PCA算法"></a>2.2.2 基于SVD分解协方差矩阵实现PCA算法</h5><p>输入数据集：<br>$$X={x_1,x_2,x_3,\dots,x_n}$$</p>
<p>需要降到K维</p>
<ol>
<li><p>去平均值（即去中心化），即每一位特征减去各自的平均值</p>
</li>
<li><p>计算协方差矩阵$$\frac{1}{n}XX^T$$</p>
<p> 注：这里除或不除n或n-1，其实对求出的特征向量没有影响。</p>
</li>
<li><p>用SVD计算协方差矩阵</p>
<p> $$\frac{1}{n}XX^T$$的特征值与特征向量。</p>
</li>
<li><p>对特征值从大到小排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P。</p>
</li>
<li><p>将数据转换到k个特征向量构建的新空间中，即Y=PX。</p>
<p> 在PCA降维中，我们需要找到样本协方差矩阵$XX^T$的最大K个特征向量，然后用这个最大的K个特征向量组成的矩阵来做低维投影降维。</p>
<p> 当样本数多、样本特征数也多的时候，这个计算还是很大的。</p>
</li>
</ol>
<p><strong>当我们用SVD分解协方差矩阵的时候SVD有两个好处：</strong></p>
<ol>
<li>有一些SVD的实现算法可以先不求出协方差矩阵$XX^T$也能求出我们的右奇异矩阵V。也就是说，我们的PCA算法可以不用做特征分解而是通过SVD来完成，这个方法在样本量很大的时候很有效。实际上，scikit-learn的PCA算法的背后真正的实现就是用的SVD，而不是特征值分解。</li>
</ol>
<ol start="2">
<li>注意到PCA仅仅使用了我们SVD的左奇异矩阵，没有使用到右奇异值矩阵，那么右奇异值矩阵有什么用呢？假设我们的样本是$m * n$的矩阵X，如果我们通过SVD找到了矩阵$X^TX$最大的k个特征向量组成的$k * n$的矩阵$V^T$,可以得到一个$m * k$的矩阵$X^{‘}$,这个矩阵和我们原来$m * n$的矩阵X相比，列数从n减到了K,可见对列数进行了压缩，也就是说，左奇异矩阵可以用于对行数的压缩；右奇异矩阵可以用于对列（即特征维度）的压缩。这就是我们用SVD分解协方差矩阵实现PCA可以得到两个方向的PCA降维（即行和列两个方向）</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux知识点总结</title>
    <url>/2020/08/29/linux/</url>
    <content><![CDATA[<h1 id="1-Linux文件类型"><a href="#1-Linux文件类型" class="headerlink" title="1 Linux文件类型"></a>1 Linux文件类型</h1><p>Linux支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字等</p>
<ul>
<li>普通文件</li>
<li>目录文件(d, directory file)</li>
<li>符号链接文件(l, symbolic link)：保留了指向文件的地址而不是文件本身</li>
<li>字符设备(c, char)：用来访问字符设备比如硬盘</li>
<li>设备文件(b,block)：用来访问设备比如硬盘、软盘</li>
<li>管道文件(p,pipe)：用于进程之间的通信</li>
<li>套接字(s,socket)：进程间网络通信，也可以用于本机之间的非网络通信<a id="more"></a>

</li>
</ul>
<h1 id="2-Linux目录树"><a href="#2-Linux目录树" class="headerlink" title="2 Linux目录树"></a>2 Linux目录树</h1><p>Linux的目录结构如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/0C7AA0164FE549559D468081C86A2731?method=download&shareKey=f44a7c3f8e85e2be6d1b8beeb0d25216" alt></p>
<p>常用目录说明：</p>
<ul>
<li><code>/bin</code>：存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里</li>
<li><code>/etc</code>：存放系统管理和配置文件</li>
<li><code>/home</code>：存放所有用户文件的根目录，是用户目录的基点</li>
<li><code>/usr</code>：用于存放系统应用程序</li>
<li><code>/opt</code>：额外安装的可选应用程序包所放置的位置</li>
<li><code>/proc</code>：虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息</li>
<li><code>/root</code>：超级用户（系统管理员）的主目录</li>
<li><code>/sbin</code>：存放二进制可执行文件，只有root才能访问，系统级别的管理命令和程序</li>
<li><code>/dev</code>：用于存放设备文件</li>
<li><code>/mnt</code>：系统管理员安装临时文件系统的安装点</li>
<li><code>/boot</code>：存放用于系统引导时使用的各种文件</li>
<li><code>/lib</code>：存放着和系统运行相关的库文件</li>
<li><code>/tmp</code>：用于存放各种临时文件</li>
<li><code>/var</code>：用于存放运行时需要改变数据的文件，比如各服务的日志文件</li>
<li><code>/lost+found</code>：系统非正常关机而留下的文件</li>
</ul>
<h1 id="3-Linux基本命令"><a href="#3-Linux基本命令" class="headerlink" title="3 Linux基本命令"></a>3 Linux基本命令</h1><p>Linux 命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p>
<h2 id="3-1-目录切换命令"><a href="#3-1-目录切换命令" class="headerlink" title="3.1 目录切换命令"></a>3.1 目录切换命令</h2><ul>
<li><code>cd usr</code>：切换到该目录下的usr目录</li>
<li><code>cd ..</code>：切换到上一层目录</li>
<li><code>cd /</code>：切换到系统根目录</li>
<li><code>cd ~</code>：切换到用户主目录</li>
<li><code>cd -</code>：切换到上一个操作所在目录</li>
</ul>
<h2 id="3-2-目录的操作命令（增删改查）"><a href="#3-2-目录的操作命令（增删改查）" class="headerlink" title="3.2 目录的操作命令（增删改查）"></a>3.2 目录的操作命令（增删改查）</h2><ul>
<li><code>mkdir</code> 目录名称：增加目录</li>
<li><code>ls/ll（ll是 ls -l的别名，可以查看该目录下的所有目录文件的详细信息）</code>：查看目录信息</li>
<li><code>find 目录 参数</code>：找到目录</li>
<li><code>mv 目录：新目录名称</code>：修改目录的名称</li>
<li><code>mu 目录名称 新目录名称</code>：修改目录的位置（剪切）</li>
<li><code>cp -r 目录名称 目录拷贝的目标位置</code>：拷贝目录</li>
<li><code>rm [-rf] 目录</code>：目录删除</li>
</ul>
<h2 id="3-3-文件的操作命令"><a href="#3-3-文件的操作命令" class="headerlink" title="3.3 文件的操作命令"></a>3.3 文件的操作命令</h2><ul>
<li><code>touch 文件名称</code>：文件的创建</li>
<li><code>cat/more/less/tail 文件名称</code>：文件的查看</li>
<li><code>vim 文件</code>：修改文件的内容</li>
<li><code>rm -rf 文件</code>：删除文件</li>
</ul>
<h2 id="3-4-压缩文件的操作命令"><a href="#3-4-压缩文件的操作命令" class="headerlink" title="3.4 压缩文件的操作命令"></a>3.4 压缩文件的操作命令</h2><p>1）打开并压缩文件</p>
<p>Linux中的打包和压缩是一起进行的，打包并压缩文件的后缀名一般为<code>.tar.gz</code></p>
<ul>
<li><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></li>
</ul>
<p>其中：</p>
<ul>
<li>z：调用gzip压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>2）解压压缩包：</p>
<ul>
<li><code>tar [-xvf] 压缩文件</code></li>
</ul>
<p>其中：</p>
<ul>
<li>x：代表解压</li>
</ul>
<h2 id="3-5-Linux的权限命令"><a href="#3-5-Linux的权限命令" class="headerlink" title="3.5 Linux的权限命令"></a>3.5 Linux的权限命令</h2><p>linux中权限一般分为读(readable)、写(writable)、执行(excutable)三组。分别对应文件的属主(owner)、属组(group)和其他用户(other)</p>
<p>通过<code>ls -l</code>命令</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/E17C3D4A7E5B4CD3B7097099277E7B70?method=download&shareKey=1d7ba2648463666978de2b54a718b3b0" alt></p>
<p>第一列的内容信息解释如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/3608EE6D1AAD49ABB8C7DB547871DEE1?method=download&shareKey=b86faced23e0328c128443cf66255de1" alt></p>
<p>文件的类型：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：软连接</li>
</ul>
<p>Linux中权限分为以下几种：</p>
<ul>
<li>r：可读</li>
<li>w：可写</li>
<li>x：可执行</li>
</ul>
<p>文件和目录权限的区别：</p>
<p>对文件和目录而言，读写执行表示不同的意义</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以使用cat查看文件内容</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以修改文件内容</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以查看目录下列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以使用cd进入目录</td>
</tr>
</tbody></table>
<p>超级用户可以无视普通用户的权限</p>
<p>在Linux中的每一个用户必须属于一个组，不能独立于组外，在Linux中每个文件有所有者、所在组、其它组的概念</p>
<ul>
<li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的称为该文件的所有者</li>
<li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</li>
<li>其他组(o)：除开文件的所有者和所在组用户外，系统的其他用户都是文件的其他组</li>
</ul>
<p>修改文件/目录的权限命令</p>
<ul>
<li>chmod</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/D0D5A242004E4058AB3D4D0AF2795B10?method=download&shareKey=84cd39dd258f0930b7bb7fdb91ddfea3" alt></p>
<h2 id="3-6-Linux用户管理"><a href="#3-6-Linux用户管理" class="headerlink" title="3.6 Linux用户管理"></a>3.6 Linux用户管理</h2><ul>
<li><code>useradd 选项 用户名</code>：添加用户账号</li>
<li><code>userdel 选项 用户名</code>：删除用户账号 </li>
<li><code>usermod 选项 用户名</code>：修改账号</li>
<li><code>passwd 用户名</code>：更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code>：显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>：清除用户密码</li>
</ul>
<h2 id="3-7-系统用户组的管理"><a href="#3-7-系统用户组的管理" class="headerlink" title="3.7 系统用户组的管理"></a>3.7 系统用户组的管理</h2><ul>
<li><code>groupadd 选项 用户组</code>：添加一个新的用户组</li>
<li><code>groupedl 用户组</code>：要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code>：修改用户组的属性</li>
</ul>
<h2 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8 其他常用命令"></a>4.8 其他常用命令</h2><ul>
<li><code>pwd</code>：显示当前所在位置</li>
<li><code>sudo + 其他命令</code> ： 以系统管理者的身份执行命令</li>
<li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令， –color代表高亮显示</li>
<li><code>ps -ef/ps -aux</code>：查看当前系统正在运行进程</li>
<li><code>kill -9 进程的Pid</code>：杀死进程</li>
<li><code>shutdown</code>：关机</li>
<li><code>reboot</code>：重启</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（三）：数据链路层</title>
    <url>/2020/08/13/network3/</url>
    <content><![CDATA[<h1 id="1-数据链路层的功能"><a href="#1-数据链路层的功能" class="headerlink" title="1 数据链路层的功能"></a>1 数据链路层的功能</h1><p>链路层主要包括链路管理、帧同步、流量控制、差错控制、数据和控制信息分开、透明传输和寻址</p>
<a id="more"></a>

<h1 id="2-组帧"><a href="#2-组帧" class="headerlink" title="2 组帧"></a>2 组帧</h1><p>封装成帧就是在一段数据的前后分别添加首部和尾部。</p>
<p>控制字符SOH放在帧的最前面，表示帧的首部开始，EOT表示帧的结束</p>
<p>为解决透明传输问题，发送端在数据链路层在数据中出现控制字符SOH或EOT的前面插入一个转义字符ESC</p>
<p>（1）面向比特的方法</p>
<p>PPP协议采用零比特填充方法来实现透明传输（只要发现5个连续1，则立即填入一个0）</p>
<p>（2）面向字符的异步传输</p>
<p>把转义字符定义为0x7D（011111101）</p>
<ol>
<li>把信息字段中出现的每一个0x7E转变为2字节序列（0x7D,0x5E）</li>
<li>若信息字段中出现一个0x7D字节，把0x7D转换为2字节序列(0x7D,0x5D)</li>
<li>若出现ASCII码控制字符，在该字符前面加入0x7D字节，同时将该字符的编码加以改变</li>
</ol>
<h1 id="3-差错控制"><a href="#3-差错控制" class="headerlink" title="3 差错控制"></a>3 差错控制</h1><p>循环冗余校验CRC技术</p>
<p>在数据M的后面添加提供差错检测用的n位冗余码，然后构成一个帧发送出去，一共发送(k+n)位</p>
<p>在接收端把每一个帧都除以相同的除数p，检查得到的余数R</p>
<p>如果传输过程中无差错，那么经过CRC校验后得出的余数R为0</p>
<h1 id="4-流量控制与可靠传输机制"><a href="#4-流量控制与可靠传输机制" class="headerlink" title="4 流量控制与可靠传输机制"></a>4 流量控制与可靠传输机制</h1><p>流量控制的目的是控制双方发送的速率，可靠传输保证不丢帧</p>
<h2 id="4-1-停止-等待协议"><a href="#4-1-停止-等待协议" class="headerlink" title="4.1 停止-等待协议"></a>4.1 停止-等待协议</h2><p>每发送完一个分组就停止发送，等待对方的确认，收到确认后再发送下一个分组</p>
<p>具有确认和重传机制的可靠传输协议称为自动重传请求ARQ，为提高传输效率，采用连续ARQ协议，发送方每收到一个确认，就把发送串口向前滑动一个分组的位置</p>
<p>接收方采用累积确认的方式</p>
<h2 id="4-2-退后N帧协议（GBN）"><a href="#4-2-退后N帧协议（GBN）" class="headerlink" title="4.2 退后N帧协议（GBN）"></a>4.2 退后N帧协议（GBN）</h2><p>若发现N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧</p>
<h2 id="4-3-选择重传协议（SR）"><a href="#4-3-选择重传协议（SR）" class="headerlink" title="4.3 选择重传协议（SR）"></a>4.3 选择重传协议（SR）</h2><p>当接收方发现某镇出错后，某后继续送来的正确的帧虽然不能立即递交给接受方的高层，但接受方仍可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧</p>
<h1 id="5-介质访问控制"><a href="#5-介质访问控制" class="headerlink" title="5 介质访问控制"></a>5 介质访问控制</h1><h2 id="5-1-信道划分介质访问控制"><a href="#5-1-信道划分介质访问控制" class="headerlink" title="5.1 信道划分介质访问控制"></a>5.1 信道划分介质访问控制</h2><p>1、频分复用FDM、时分复用TDM和统计时分复用</p>
<p>2、波分复用WDM</p>
<p>3、码分复用CDM</p>
<p>更常用的名词是码分多址CDMA，每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p>
<h2 id="5-2-随机访问介质控制访问"><a href="#5-2-随机访问介质控制访问" class="headerlink" title="5.2 随机访问介质控制访问"></a>5.2 随机访问介质控制访问</h2><p>1、ALOHA协议</p>
<p>用户有帧即发送，采用冲突监听与随机重发机制。两帧冲突或重叠则会被破坏，因此效率不高</p>
<p>2、载波监听多路访问CSMA</p>
<p>当一个站点要发送数据前，监听总线，如果总线空闲则发送数据</p>
<p>3、载波监听多路访问/冲突检测 CSMA/CD</p>
<p>载波监听就是用电子技术检测总线上有没有其他计算机也在发送，碰撞检测也就是边发送边监听，判断自己在发送数据时其他站点是否也在发送数据</p>
<p>4、CSMA/CA</p>
<p>CSMA/CD协议已经成功地应用于有线连接的局域网，但无线局域网要使用CSMA/CA</p>
<h1 id="6-局域网"><a href="#6-局域网" class="headerlink" title="6 局域网"></a>6 局域网</h1><p>（1）具有广播功能，从一个站点可很方便地访问全网</p>
<p>（2）各设备的位置可灵活调整和改变，提高了系统的可靠性、可用性和生存性</p>
<p>为了使数据链路层更好地适应多种局域网标准，将IEEE 802委员会把局域网的数据链路层拆成两个子层，即逻辑链路控制LLC和媒体接入控制MAC</p>
<p>与接入到传输谋体有关的内容放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的</p>
<p>MAC层的硬件地址</p>
<p>在局域网中，硬件地址又称为物理地址或MAC地址</p>
<h1 id="7-广域网"><a href="#7-广域网" class="headerlink" title="7 广域网"></a>7 广域网</h1><h2 id="7-1-PPP协议"><a href="#7-1-PPP协议" class="headerlink" title="7.1 PPP协议"></a>7.1 PPP协议</h2><p>当PPP使用异步传输时，把转义字符定义为0x7D，并用字节填充</p>
<p>用SONET/SDH链路时，使用同步传输，采用零比特填充方法来实现透明传输</p>
<h2 id="7-2-HDLC协议"><a href="#7-2-HDLC协议" class="headerlink" title="7.2 HDLC协议"></a>7.2 HDLC协议</h2><p>通用的数据链路控制协议，在开始建立数据链路时，允许选用特定的操作方式</p>
<p>所谓操作方式，通俗来将就是某站点是以主站点方式操作还是从站点方式操作，或者二者兼备。</p>
<h1 id="8-数据链路设备"><a href="#8-数据链路设备" class="headerlink" title="8 数据链路设备"></a>8 数据链路设备</h1><p>1、网桥</p>
<p>在数据链路层扩展局域网是使用网桥。根据MAC帧的目的地址对收到的帧进行转发</p>
<p>2、交换机</p>
<p>以太网交换机实质上就是一个多接口的网桥</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（一）：计算机体系结构</title>
    <url>/2020/08/11/network/</url>
    <content><![CDATA[<h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1 计算机网络概述"></a>1 计算机网络概述</h1><h2 id="1-1-计算机网络的分类"><a href="#1-1-计算机网络的分类" class="headerlink" title="1.1 计算机网络的分类"></a>1.1 计算机网络的分类</h2><p>（1）按照网络的作用范围进行分类</p>
<ul>
<li>广域网WAN</li>
</ul>
<p>广域网是互联网的核心部分，其任务是通过长距离运送主机所发送的数据</p>
<ul>
<li><p>城域网MAN</p>
</li>
<li><p>局域网LAN</p>
</li>
<li><p>个人局域网PAN</p>
</li>
</ul>
<a id="more"></a>

<p>（2）按照网络的使用者进行分类</p>
<ul>
<li><p>公用网</p>
</li>
<li><p>专用网</p>
</li>
</ul>
<h1 id="2-计算机网络体系结构与参考模型"><a href="#2-计算机网络体系结构与参考模型" class="headerlink" title="2 计算机网络体系结构与参考模型"></a>2 计算机网络体系结构与参考模型</h1><h2 id="2-1-计算机网络分层结构"><a href="#2-1-计算机网络分层结构" class="headerlink" title="2.1 计算机网络分层结构"></a>2.1 计算机网络分层结构</h2><p>（1）各层之间是独立的</p>
<p>（2）灵活性好</p>
<p>（3）结构上可分割开</p>
<p>（4）易于实现和维护</p>
<p>（5）能促进标准化工作</p>
<h2 id="2-2-计算机网络协议、接口、服务等概念"><a href="#2-2-计算机网络协议、接口、服务等概念" class="headerlink" title="2.2 计算机网络协议、接口、服务等概念"></a>2.2 计算机网络协议、接口、服务等概念</h2><p>（1）协议</p>
<p>为进行网络的数据交换而建立的规则、标准或约定，由下面三个要素组成</p>
<ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li>同步：事件实现顺序的详细说明</li>
</ul>
<p>（2）接口</p>
<p>同一系统中相邻两层的实体进行交互的地方</p>
<p>（3）服务</p>
<p>为保证上层对等体之间能相互通信，下层向上层提供的功能。</p>
<h2 id="2-3-ISO-OSI参考模型和TCP-IP模型"><a href="#2-3-ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="2.3 ISO/OSI参考模型和TCP/IP模型"></a>2.3 ISO/OSI参考模型和TCP/IP模型</h2><p>（1）ISO/OSI参考模型</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/F1CCFE10950B4F57AE2928BFBA07FEA4?method=download&shareKey=405e790fa1ddef9c62d3294c3c01c2f9" alt></p>
<p>1、物理层</p>
<p>负责透明的传输比特，为上层（数据链路层）提供一个物理连接</p>
<p>2、数据链路层</p>
<p>负载在两个相邻结点之间，无差错地传送以“帧”为单位的数据</p>
<p>3、网络层</p>
<p>在不同网络系统中的两个结点设备提供一条逻辑通路，包括路由选择、拥塞控制与网络互连等功能</p>
<p>4、传输层</p>
<p>向用户提供可靠的端到端服务，关心包括建立、维护和中断虚电路、传输差错校验和恢复以及信息流量控制机制等</p>
<p>5、会话层</p>
<p>负责通讯的双方在正式开始传输前的沟通，建立传输时所遵循的规则</p>
<p>6、表示层</p>
<p>两个应用实体之间进行数据交换的语法问题，解决数据交换中存在的数据格式不一致以及数据表示方法不同等问题</p>
<p>7、应用层</p>
<p>直接提供文件传输、电子邮件、网页浏览等服务</p>
<p>（2）TCP/IP模型</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/13EA864C84874CADA4CC1A5E17F85F57?method=download&shareKey=86152b4f8c72d7864a84ee9792faf527" alt></p>
<p>1、网络接口层</p>
<p>负责网络发送和接受IP数据报，并未对网络接口层使用权的一些做出强硬的规定，它允许炼乳网络时使用多种现成的和流形的协议</p>
<p>2、网际层</p>
<p>功能相当于OSI参考模型网络层</p>
<ol>
<li>处理来自传输层的分组发送请求，将分组装入IP数据报，填充报头，选择发送路径，然后将数据报发送到相应的网络输出线</li>
<li>处理接收的数据报，检查其目的地址</li>
<li>处理互连的路径，流量控制与拥塞问题</li>
</ol>
<p>3、传输层</p>
<p>负责应用进程之间的端到端通信，与OSI参考模型的传输层功能相似</p>
<p>定义了传输控制协议（TCP）和用户数据报协议（UDP）</p>
<p>TCP协议是一种可靠的面向连接的协议，允许将一台主机的字节流无差错地传送到目的主机</p>
<p>UDP协议是一种不可靠的无连接协议，主要用于不要求分组顺序到达的传输，分组传输顺序检查与排序由应用层完成</p>
<p>4、应用层</p>
<ol>
<li>文件传输协议FTP</li>
<li>简单邮件传输协议SMTP</li>
<li>域名系统DNS</li>
<li>超文本传输协议HTTP</li>
<li>路由信息协议RIP</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/67FDE0789DBC414F82B41687EE292E78?method=download&shareKey=759fca82e178d04bba1ca0f6ab45e8e8" alt></p>
<hr>
<h1 id="3-常见面试问题总结"><a href="#3-常见面试问题总结" class="headerlink" title="3 常见面试问题总结"></a>3 常见面试问题总结</h1><h2 id="3-1-OSI与TCP-IP各层的结构与功能，都有哪些协议？"><a href="#3-1-OSI与TCP-IP各层的结构与功能，都有哪些协议？" class="headerlink" title="3.1 OSI与TCP/IP各层的结构与功能，都有哪些协议？"></a>3.1 OSI与TCP/IP各层的结构与功能，都有哪些协议？</h2><p>采用只有五层协议的体系结构，自上而下的介绍各层的作用</p>
<p>（1）应用层</p>
<p>应用层的任务是通过应用进程的交互来完成特定网络应用，应用层协议定义是应用进程间的通信和交互的规则，对于不同的网络应用需要不同的应用层协议，互联网中应用层的协议很多，如域名系统DNS,支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等，我们把应用层交互的数据单位称为报文</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统是因特网的一项核心服务，它可以将域名和IP地址相互映射，使人更方便的访问互联网，而不用去记住能够被机器读取的IP地址</p>
</blockquote>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超文本传输协议是互联网最为广泛的一种网络协议，所有的文件都必须遵循这个标准</p>
</blockquote>
<p>（2）传输层</p>
<p>传输层的主要任务是负责向两台主机进程之间的通信提供通用的数据传输服务。</p>
<p>运输层主要使用以下两种协议：</p>
<ol>
<li>传输控制协议TCP–提供面向连接的，可靠的数据传输服务</li>
<li>用户数据报协议UDP–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</li>
</ol>
<p>（3）网络层</p>
<p>在计算机进行通信的两个计算机之间可能会经过很多个数据链路，也可能经过很多通信子网，网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。</p>
<p>（4）数据链路层</p>
<p>两台主机之间的数据传输，总是在一段段的链路上传送的，这就需要使用专门的链路层协议，在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</p>
<p>（5）物理层</p>
<p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（四）：网络层</title>
    <url>/2020/08/15/network4/</url>
    <content><![CDATA[<h1 id="1-网络层的功能"><a href="#1-网络层的功能" class="headerlink" title="1 网络层的功能"></a>1 网络层的功能</h1><h2 id="1-1-异构网络互联"><a href="#1-1-异构网络互联" class="headerlink" title="1.1 异构网络互联"></a>1.1 异构网络互联</h2><p>由于参加互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看作一个虚拟互联网络，所谓虚拟互联网络也就是逻辑互联网络，互联起来的各个捂脸网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。</p>
<a id="more"></a>

<h2 id="1-2-路由与转发"><a href="#1-2-路由与转发" class="headerlink" title="1.2 路由与转发"></a>1.2 路由与转发</h2><p>在路由表中，对每一条路由最主要的是以下两个信息：目的网络地址、下一跳地址</p>
<p>我们根据目的网络地址来确定下一跳路由器，这样可得出以下结果</p>
<p>（1）IP数据报最终一定可以找到目的主机所在目的网络上的路由器</p>
<p>（2）只有到达最后一个路由器时，才视图向目的主机进行直接交付</p>
<p>分组转发算法：</p>
<p>（1）从数据报的首部提取目的主机IP地址D，得出目的网络地址为N</p>
<p>（2）若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址D转换为具体的硬件地址）；否则就是间接交付，执行（3）</p>
<p>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</p>
<p>（4）路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器：否则，执行（5）</p>
<p>（5）若路由表中有一个默认路由，则把数据表传送给路由表中所指明的默认路由器；否则执行（6）</p>
<p>（6）报告转发分组出错</p>
<p>路由表想主要字段：目的网络、子网掩码、下一跳路由器、经由接口</p>
<p>默认路由：若匹配路由表中其它项都不匹配，则走默认路由指明的路由</p>
<p>若路由表项都不匹配且无默认路由，则向源主机发送错的ICMP包</p>
<p>主机路由：IP地址，255.255.255.255 下一跳 接口</p>
<h2 id="1-3-拥塞控制"><a href="#1-3-拥塞控制" class="headerlink" title="1.3 拥塞控制"></a>1.3 拥塞控制</h2><p>1、拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该网络来不及处理以致引起这部分乃至整个网络性能下降的现象，严重时会出现死锁。拥塞现象产生的原因主要有三个方面：路由器缓冲区不够；通信线路的带宽不够；处理器速度慢</p>
<p>2、拥塞控制：目的是确保子网能够承载所有到达流量，是全局问题，涉及节点包括：主机、路由器</p>
<p>3、流量控制：目的是确保发送端的发送速度小于接受端的接收速度，使接收端来得及正确接收。流量控制只与发送和接收端有关系，是局部问题</p>
<h1 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2 路由算法"></a>2 路由算法</h1><h2 id="2-1-静态路由与动态路由"><a href="#2-1-静态路由与动态路由" class="headerlink" title="2.1 静态路由与动态路由"></a>2.1 静态路由与动态路由</h2><p>静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由</p>
<p>动态路由选择也叫自适应路由选择，其特点是能较好地自适应网络状态的变化，但实现起来较为复杂，开销也较大，因此，适用于较复杂的大网络。</p>
<h2 id="2-2-距离-向量路由算法"><a href="#2-2-距离-向量路由算法" class="headerlink" title="2.2 距离-向量路由算法"></a>2.2 距离-向量路由算法</h2><h2 id="2-3-链路状态路由算法"><a href="#2-3-链路状态路由算法" class="headerlink" title="2.3 链路状态路由算法"></a>2.3 链路状态路由算法</h2><h2 id="2-4-层次路由"><a href="#2-4-层次路由" class="headerlink" title="2.4 层次路由"></a>2.4 层次路由</h2><p>（1）互联网的规模非常大，如果让所有路由器知道所有网络应该怎样到达，则这种路由表将非常大</p>
<p>（2）许多单位不愿意外界了解自己单位网络的布局细节和本部分所采用的路由选择协议</p>
<p>为此，将整个互联网划分成许多较小的自治系统</p>
<h1 id="3-IPv4"><a href="#3-IPv4" class="headerlink" title="3 IPv4"></a>3 IPv4</h1><h2 id="3-1-IPv4分组"><a href="#3-1-IPv4分组" class="headerlink" title="3.1 IPv4分组"></a>3.1 IPv4分组</h2><p>IP数据报的格式能够说明IP协议都具有什么功能，在TCP/IP的标准中，各种数据格式常常以32位（4字节）为单位来表述</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/587F26252FD94B0A8E49E55E40988A0F?method=download&shareKey=d8379ce9bacd34421d0217526f1108b3" alt></p>
<p>（1）IP数据报首部的固定部分中的各字段</p>
<ol>
<li>版本占4位，指IP协议的版本，通信双方使用的IP协议版本必须一致，目前广泛使用的为4（即IPv4）</li>
<li>首部长度占4位</li>
<li>区分服务占8位，用来获得更好的服务</li>
<li>总长度指首部和数据之和的长度</li>
<li>标识占16位</li>
<li>标志占3位</li>
<li>片偏移占13位。较长的分组在分片后，某片在原分组中的相对位置</li>
<li>生存时间占8位</li>
<li>协议占8位，指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理</li>
<li>首部检验和占16位</li>
</ol>
<h2 id="3-2-IPv4地址与NAT"><a href="#3-2-IPv4地址与NAT" class="headerlink" title="3.2 IPv4地址与NAT"></a>3.2 IPv4地址与NAT</h2><p>（1）IP地址及其表示方法</p>
<p>IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配以个在全世界范围内是唯一的32位标识符，具有以下重要特点</p>
<ol>
<li>每一个IP地址都由网络号和主机号两部分组成</li>
<li>实际上IP地址标志一台主机（或路由器）和一条链路的接口。路由器至少应当有两个不同的IP地址</li>
<li>一个网络是指具有相同网络号net-id的主机的集合，因此用转发器或网桥连接起来的若干个局域网仍为一个网络</li>
<li>在IP地址中，所有分配到网络号的网络都是平等的</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/27C68544341842C9A1439F6AF31EC516?method=download&shareKey=dff0f29f2e04b88dca9d17e7bf85a20c" alt></p>
<p>主机号全0，或全1不使用</p>
<p>A类地址：网络号：0-127，主机地址24位：$2^24-2$个</p>
<p>B类地址：网络号：128.0-191.255,主机地址16位：$2^16-2$个</p>
<p>C类地址：网络号：192.0.0-223.255.255，主机地址8位：$2^8-2$</p>
<p>D类地址：网络号：224~239之间，一般用于多路广播用户</p>
<p>E类地址：网络号：240~250之间，保留地址</p>
<p>（2）NAT技术</p>
<p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件，装有NAT软件的路由器叫作NAT路由器，至少有一个有效的外部全球IP地址，这样，所有使用本地地址的主机和外界通信时，都要在NAT路由器上讲本地地址转换成全球IP地址，才能和互联网连接。</p>
<h2 id="3-3-子网划分、路由聚集、子网掩码、CIDR"><a href="#3-3-子网划分、路由聚集、子网掩码、CIDR" class="headerlink" title="3.3 子网划分、路由聚集、子网掩码、CIDR"></a>3.3 子网划分、路由聚集、子网掩码、CIDR</h2><p>（1）从两级IP地址到三级IP地址</p>
<p>划分子网的基本思路如下：</p>
<ol>
<li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。</li>
<li>划分子网的方法是从网络的主机号借用若干位作为子网号，当然主机号也就相应减少了同样的位数，IP地址在单位内部变为三级IP地址：网络号、子网号、主机号</li>
<li>范式从其他网络发送给本单位某台主机的IP数据报，仍是根据IP数据报的目的网络号找到链接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，吧IP数据报交付目的主机</li>
</ol>
<p>（2）子网掩码</p>
<p>使用子网掩码的好处就是，不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的与运算，就立即得出网络地址来。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/15B0A407CC8747CAAB1084D4E6EA4484?method=download&shareKey=c11b3faa3b315d7e7c0b52a797c0fdb9" alt></p>
<p>（3）使用子网分组的转发</p>
<p>在划分子网的情况下，分组转发的算法必须做相应的改动，使用子网划分后，路由表必须包括以下三项内容：目的网络地址、子网掩码和下一跳地址，下划分子网情况下，路由转发分组的算法如下：</p>
<ol>
<li>从收到的数据报的首部提取目的IP地址D</li>
<li>先判断是否为直接交付，用各网络的子网掩码和D逐位相与，看结果是否和相应的网络地址匹配，若匹配进行直接交付，否则间接交付，执行（3）</li>
<li>若路由表中有目的地址为D的特点主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</li>
<li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相与，其结果为N，若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器，否则执行5</li>
<li>路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由器，否则执行6</li>
<li>报告转发分组出错</li>
</ol>
<h2 id="3-4-无分类编址CIDR（构造超网）"><a href="#3-4-无分类编址CIDR（构造超网）" class="headerlink" title="3.4 无分类编址CIDR（构造超网）"></a>3.4 无分类编址CIDR（构造超网）</h2><p>CIDR最主要的特点有两个：</p>
<p>（1）CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，把32位的IP地址划分为前后两个部分，前面部分是“网络前缀”，用来指明网络，后面部分则用来指明主机。因此CIDR使IP地址从三级编址回到了两级编址：IP地址=网络前缀、主机号，在IP地址后面加上斜线，然后写上网络前缀所占的位数</p>
<p>（2）CIDR把网络前缀都相同的连续的IP地址组成一个CIDR地址块。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数</p>
<p>路由聚合</p>
<p>这个ISP共拥有64个C类网络，如果不采用CIDR技术，则与该ISP的路由器交换路由信息的每一个路由器的路由表中，就需要有64个项目，但采用地址聚合后，就只需用路由聚合后的一个项目206.0.64.0/18就能找到该ISP</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/C6F0B28F52FA4CBB8912A657C5DA19A7?method=download&shareKey=e71d81b3e28fa6b144aaac0811d2ff5a" alt></p>
<p>最长前缀匹配</p>
<p>每个项目由网络前缀和下一跳地址组成，但是在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由</p>
<h2 id="3-5-ARP协议、DHCP协议与ICMP协议"><a href="#3-5-ARP协议、DHCP协议与ICMP协议" class="headerlink" title="3.5 ARP协议、DHCP协议与ICMP协议"></a>3.5 ARP协议、DHCP协议与ICMP协议</h2><h3 id="3-5-1-地址解析协议ARP"><a href="#3-5-1-地址解析协议ARP" class="headerlink" title="3.5.1 地址解析协议ARP"></a>3.5.1 地址解析协议ARP</h3><p>从网络层使用的IP地址，解析出在数据链路层使用的硬件地址</p>
<ul>
<li>ARP请求分组：包含发送方硬件地址和IP地址，目标方硬件地址（未知填0），目标方IP地址</li>
<li>本地广播ARP请求（路由器不转发ARP请求）</li>
<li>ARP相应分组：发送方硬件地址、发送方IP地址、目标方硬件地址、目标方IP地址</li>
<li>ARP分组封装在物理网络的帧中传输</li>
</ul>
<h3 id="3-5-2-网络控制报文协议ICMP"><a href="#3-5-2-网络控制报文协议ICMP" class="headerlink" title="3.5.2 网络控制报文协议ICMP"></a>3.5.2 网络控制报文协议ICMP</h3><ul>
<li>为了提高IP数据交付成功的机会</li>
<li>允许主机或路由器报告差错情况和提供有关异常情况的报告</li>
<li>不是高层协议而是IP层的协议</li>
<li>作为IP层数据报的数据</li>
<li>有差错报告和询问报文</li>
<li>前4个字节是统一的格式，共有三个字段：即类型、代码和校验和，接着的4个字节的内容与ICMP的类型有关</li>
</ul>
<h3 id="3-5-3-动态主机设置协议DHCP"><a href="#3-5-3-动态主机设置协议DHCP" class="headerlink" title="3.5.3 动态主机设置协议DHCP"></a>3.5.3 动态主机设置协议DHCP</h3><ul>
<li>动态主机配置协议DHCP提供了即插即用连网的机制</li>
<li>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参加</li>
<li>需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就称为DHCP客户</li>
<li>本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文</li>
<li>DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文</li>
</ul>
<h1 id="4-IPv6"><a href="#4-IPv6" class="headerlink" title="4 IPv6"></a>4 IPv6</h1><h2 id="4-1-IPv6的主要特点"><a href="#4-1-IPv6的主要特点" class="headerlink" title="4.1 IPv6的主要特点"></a>4.1 IPv6的主要特点</h2><p>（1）地址从IPv4的32位增加到128位</p>
<p>（2）扩展地址层次结构</p>
<p>（3）灵活的首部格式</p>
<p>（4）改进的选项</p>
<p>（5）允许协议继续扩充</p>
<p>（6）支持资源的预分配</p>
<p>（7）支持即插即用</p>
<p>（8）首部8字节对齐</p>
<h2 id="4-2-IPv6的地址"><a href="#4-2-IPv6的地址" class="headerlink" title="4.2 IPv6的地址"></a>4.2 IPv6的地址</h2><p>（1）单播：传统的点到点通信</p>
<p>（2）组播：一点对多点通信</p>
<p>（3）任播：终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个</p>
<p>为了使地址再稍简洁，使用冒号十六进制法</p>
<h1 id="5-路由协议"><a href="#5-路由协议" class="headerlink" title="5 路由协议"></a>5 路由协议</h1><h2 id="5-1-自治系统"><a href="#5-1-自治系统" class="headerlink" title="5.1 自治系统"></a>5.1 自治系统</h2><ul>
<li>核心是路由寻址的“自治”</li>
<li>自治系统内部的路由器了解内部全部网路的路由信息</li>
<li>自治系统内部的路由器要向主干路由器报告内部路由信息</li>
</ul>
<h2 id="5-2-域内路由与域间路由"><a href="#5-2-域内路由与域间路由" class="headerlink" title="5.2 域内路由与域间路由"></a>5.2 域内路由与域间路由</h2><ul>
<li>内部网关协议IGP，如RIP,OSPF协议</li>
<li>外部网关协议EGP，如BGP-4</li>
</ul>
<h2 id="5-3-RIP路由协议"><a href="#5-3-RIP路由协议" class="headerlink" title="5.3 RIP路由协议"></a>5.3 RIP路由协议</h2><p>1、工作原理</p>
<ul>
<li>内部网关协议</li>
<li>分布式的基于距离向量</li>
<li>要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</li>
</ul>
<p>距离的定义：</p>
<ol>
<li>路由器到直接连接的网络距离定义为1</li>
<li>路由器到非直连的网络的距离为所经过的路由器加1</li>
<li>RIP协议的距离也称为跳数</li>
<li>距离指的是最短距离</li>
<li>允许一条路径最多只包含15个路由器</li>
<li>16个路由器则不可达，可见RIP适用于小型网络</li>
<li>不能再两个网络之间同时使用多条路由</li>
</ol>
<p>RIP三个要点：</p>
<ul>
<li>仅和相邻路由交换信息</li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表</li>
<li>按固定的时间间隔交换路由信息</li>
</ul>
<p>2、距离向量算法</p>
<p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p>
<ol>
<li><p>对地址为X相邻路由器发来的RIP报文，先修改此报文中的所有项目：把下一跳字段中的地址都改为X，并把所有距离字段的值都加1，每一项目都有三个关键数据，即：目的网络N，距离d,下一跳路由X</p>
</li>
<li><p>对修改后的RIP报文中的每一个项目，进行以下步骤:若原来的路由表中没有目的网络N，则把该项目添加到路由表中，否则（即在路由表中有目的网络N，这时就再查看下一跳路由地址）</p>
<ul>
<li>若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目，否则</li>
<li>若收到项目中的距离小于路由表中的距离，则进行更新，否则什么都不做</li>
</ul>
</li>
<li><p>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器</p>
</li>
</ol>
<h2 id="5-4-OSPF路由协议"><a href="#5-4-OSPF路由协议" class="headerlink" title="5.4 OSPF路由协议"></a>5.4 OSPF路由协议</h2><p>1、OSPF的三个要点</p>
<ul>
<li>向本自治系统中所有路由器发送信息</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</li>
<li>只有当链路状态发生变化时，路由器才想所有路由器用洪泛法发送此信息</li>
</ul>
<p>2、OSPF的五种分组类型</p>
<ul>
<li>问候分组</li>
<li>数据库描述</li>
<li>链路状态请求</li>
<li>链路状态更新</li>
<li>链路状态确认</li>
</ul>
<h2 id="5-5-BGP路由协议"><a href="#5-5-BGP路由协议" class="headerlink" title="5.5 BGP路由协议"></a>5.5 BGP路由协议</h2><ul>
<li>因特网的规模太大，寻找最佳路径不现实，只交换可达性的信息</li>
<li>自治系统之间的路由必须考虑有关策略</li>
<li>边界网关协议BGP只能是力求寻找一条能够到达目的地网络且比较好的路由</li>
</ul>
<h1 id="6-IP组播"><a href="#6-IP组播" class="headerlink" title="6 IP组播"></a>6 IP组播</h1><h2 id="6-1-组播的概念"><a href="#6-1-组播的概念" class="headerlink" title="6.1 组播的概念"></a>6.1 组播的概念</h2><p>在一对多的通信中，组播可大大节约网络资源，组播组的标识符就是IP地址的D类地址</p>
<h1 id="7-移动IP"><a href="#7-移动IP" class="headerlink" title="7 移动IP"></a>7 移动IP</h1><h2 id="7-1-移动IP的概念"><a href="#7-1-移动IP的概念" class="headerlink" title="7.1 移动IP的概念"></a>7.1 移动IP的概念</h2><p>这种技术允许计算机移动到外地时，仍然保留原来的IP地址，使用户的移动性对上层的网络应用是透明的</p>
<h1 id="8-网络层设备"><a href="#8-网络层设备" class="headerlink" title="8 网络层设备"></a>8 网络层设备</h1><ul>
<li>路由器</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode学习笔记</title>
    <url>/2020/08/11/leetcode/</url>
    <content><![CDATA[<h1 id="1-数组与矩阵"><a href="#1-数组与矩阵" class="headerlink" title="1 数组与矩阵"></a>1 数组与矩阵</h1><h2 id="Problem-1-数组中重复的数字"><a href="#Problem-1-数组中重复的数字" class="headerlink" title="Problem 1 数组中重复的数字"></a>Problem 1 数组中重复的数字</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="方法一：-先排序，然后看相邻元素是否有相同的，直接return-时间O-nlogn-，空间O-1"><a href="#方法一：-先排序，然后看相邻元素是否有相同的，直接return-时间O-nlogn-，空间O-1" class="headerlink" title="方法一： 先排序，然后看相邻元素是否有相同的，直接return,时间O(nlogn)，空间O(1)"></a>方法一： 先排序，然后看相邻元素是否有相同的，直接return,时间O(nlogn)，空间O(1)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findRepeatNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        pre &#x3D; nums[0]</span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        for index in range(1,n):</span><br><span class="line">            if pre &#x3D;&#x3D; nums[index]:</span><br><span class="line">                return pre</span><br><span class="line">            pre &#x3D; nums[index]</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用哈希表，时间O-n-，空间O-n"><a href="#方法二：使用哈希表，时间O-n-，空间O-n" class="headerlink" title="方法二：使用哈希表，时间O(n)，空间O(n)"></a>方法二：使用哈希表，时间O(n)，空间O(n)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findRepeatNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        repeatDict &#x3D; &#123;&#125;</span><br><span class="line">        for num in nums:</span><br><span class="line">            if num not in repeatDict:</span><br><span class="line">                repeatDict[num] &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                return num</span><br></pre></td></tr></table></figure>

<h2 id="Problem-2-二维数组中的查找"><a href="#Problem-2-二维数组中的查找" class="headerlink" title="Problem 2 二维数组中的查找"></a>Problem 2 二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 20，返回 false</span><br></pre></td></tr></table></figure>
<h3 id="方法一：-利用矩阵特点引入标志数"><a href="#方法一：-利用矩阵特点引入标志数" class="headerlink" title="方法一： 利用矩阵特点引入标志数"></a>方法一： 利用矩阵特点引入标志数</h3><ol>
<li>若flag&gt;target，则target一定在flag所在行的上方，即flag所在行可被消除</li>
<li>若flag&lt;target, 则target一定在flag所在列的右方，即flag所在列可被消除</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool:</span><br><span class="line">        i, j &#x3D; len(matrix) - 1, 0</span><br><span class="line">        while i &gt;&#x3D; 0 and j &lt; len(matrix[0]):</span><br><span class="line">            if matrix[i][j] &gt; target: i -&#x3D; 1</span><br><span class="line">            elif matrix[i][j] &lt; target: j +&#x3D; 1</span><br><span class="line">            else: return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<h2 id="Problem-3-删除排序数组中的重复项"><a href="#Problem-3-删除排序数组中的重复项" class="headerlink" title="Problem 3 删除排序数组中的重复项"></a>Problem 3 删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素</span><br></pre></td></tr></table></figure>

<h3 id="方法一：使用双指针"><a href="#方法一：使用双指针" class="headerlink" title="方法一：使用双指针"></a>方法一：使用双指针</h3><ol>
<li>慢指针i从0开始,快指针j从1开始，两个指针每次移动一步</li>
<li>当指针i与j所指数字不同时，i后移一步，把j的值复制给i，j后移一步</li>
<li>当i与j所指数字相同，i不动，j后移一步</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        j &#x3D; 1</span><br><span class="line">        while j &lt; len(nums):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; nums[j]:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                nums[i]&#x3D;nums[j]</span><br><span class="line">        return i+1</span><br></pre></td></tr></table></figure>


<h2 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem 4"></a>Problem 4</h2><h3 id="方法一：每一天做一次清算"><a href="#方法一：每一天做一次清算" class="headerlink" title="方法一：每一天做一次清算"></a>方法一：每一天做一次清算</h3><ol>
<li>设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1] ；</li>
<li>当该天利润为正 tmp &gt; 0，则将利润加入总利润 profit；当利润为 00 或为负，则直接跳过；</li>
<li>遍历完成后，返回总利润 profit。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices: List[int]) -&gt; int:</span><br><span class="line">        profit &#x3D; 0</span><br><span class="line">        for i in range(1,len(prices)):</span><br><span class="line">            if prices[i] &gt; prices[i-1]:</span><br><span class="line">                profit +&#x3D; prices[i] - prices[i-1]</span><br><span class="line">        return profit</span><br></pre></td></tr></table></figure>

<h2 id="Problem-5"><a href="#Problem-5" class="headerlink" title="Problem 5"></a>Problem 5</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="方法一：-数组移动使用三次反转"><a href="#方法一：-数组移动使用三次反转" class="headerlink" title="方法一： 数组移动使用三次反转"></a>方法一： 数组移动使用三次反转</h3><p>三次反转</p>
<p>对于[1,2,3,4,5,6,7]，根据k = k%n，数组分为两段：</p>
<ul>
<li>第一段，对应数组下标[0,n-k-1],即[1,2,3,4]</li>
<li>第二段，对应数组下标[n-k, n-1],即[5,6,7]</li>
</ul>
<p>分为三步:</p>
<ol>
<li>反转第一段[4,3,2,1,5,6,7]</li>
<li>反转第二段[4,3,2,1,7,6,5]</li>
<li>反转整体[5,6,7,1,2,3,4]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        k&#x3D;k%n</span><br><span class="line">        def swap(l,r):</span><br><span class="line">            while(l&lt;r):</span><br><span class="line">                nums[l],nums[r]&#x3D;nums[r],nums[l]</span><br><span class="line">                l&#x3D;l+1</span><br><span class="line">                r&#x3D;r-1</span><br><span class="line">        swap(0,n-k-1)</span><br><span class="line">        swap(n-k,n-1)</span><br><span class="line">        swap(0,n-1)</span><br></pre></td></tr></table></figure>

<h2 id="Problem-6-只出现一次的数字"><a href="#Problem-6-只出现一次的数字" class="headerlink" title="Problem 6 只出现一次的数字"></a>Problem 6 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h3 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p>使用异或的性质</p>
<ol>
<li>任何数和本身异或则为0</li>
<li>任何数和0异或是本身</li>
<li>异或运算满足交换律</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        single_number &#x3D; 0</span><br><span class="line">        for num in nums:</span><br><span class="line">            single_number ^&#x3D; num</span><br><span class="line">        return single_number</span><br></pre></td></tr></table></figure>

<h2 id="Problem-7-两个数组的交集-II"><a href="#Problem-7-两个数组的交集-II" class="headerlink" title="Problem 7 两个数组的交集 II"></a>Problem 7 两个数组的交集 II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<h3 id="方法一：-哈希表"><a href="#方法一：-哈希表" class="headerlink" title="方法一： 哈希表"></a>方法一： 哈希表</h3><ul>
<li>collections.Counter()利用哈希表对元素进行计数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        num1 &#x3D; collections.Counter(nums1)</span><br><span class="line">        num2 &#x3D; collections.Counter(nums2)</span><br><span class="line">		# 取与计算交集，返还哈希表字典元素</span><br><span class="line">        num &#x3D; num1 &amp; num2</span><br><span class="line">        return num.elements()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h3><p>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line"></span><br><span class="line">        length1, length2 &#x3D; len(nums1), len(nums2)</span><br><span class="line">        intersection &#x3D; list()</span><br><span class="line">        index1 &#x3D; index2 &#x3D; 0</span><br><span class="line">        while index1 &lt; length1 and index2 &lt; length2:</span><br><span class="line">            if nums1[index1] &lt; nums2[index2]:</span><br><span class="line">                index1 +&#x3D; 1</span><br><span class="line">            elif nums1[index1] &gt; nums2[index2]:</span><br><span class="line">                index2 +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                intersection.append(nums1[index1])</span><br><span class="line">                index1 +&#x3D; 1</span><br><span class="line">                index2 +&#x3D; 1</span><br><span class="line">        </span><br><span class="line">        return intersection</span><br></pre></td></tr></table></figure>


<h2 id="Problem-8-加一"><a href="#Problem-8-加一" class="headerlink" title="Problem 8 加一"></a>Problem 8 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<h3 id="方法一：从后往前依次判断末尾是否为9-如果是-则去除："><a href="#方法一：从后往前依次判断末尾是否为9-如果是-则去除：" class="headerlink" title="方法一：从后往前依次判断末尾是否为9 如果是 则去除："></a>方法一：从后往前依次判断末尾是否为9 如果是 则去除：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        newlst &#x3D; []</span><br><span class="line">        while digits and digits[-1] &#x3D;&#x3D; 9:</span><br><span class="line">            digits.pop()</span><br><span class="line">            newlst.append(0)</span><br><span class="line">        if not digits:</span><br><span class="line">            return [1] + newlst</span><br><span class="line">        else:</span><br><span class="line">            digits[-1] +&#x3D; 1</span><br><span class="line">            return digits + newlst</span><br></pre></td></tr></table></figure>

<h3 id="方法二：先将数字列表转化为数字，然后-1-再转化为数组"><a href="#方法二：先将数字列表转化为数字，然后-1-再转化为数组" class="headerlink" title="方法二：先将数字列表转化为数字，然后+1,再转化为数组"></a>方法二：先将数字列表转化为数字，然后+1,再转化为数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        a &#x3D; [i *10**index for index,i in enumerate(digits[::-1])]</span><br><span class="line">        num &#x3D; sum(a) + 1</span><br><span class="line">        return [int(x) for x in str(num)]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Problem-9-移动零"><a href="#Problem-9-移动零" class="headerlink" title="Problem 9 移动零"></a>Problem 9 移动零</h2><h3 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h3><p>参照快速排序的思想，用0当做中间点，把不等于0的放到中间点的左边，等于零0的放到其右边</p>
<p>使用两个指针$i,j$，只要$nums[i]!=0$就交换$nums[i]$和$nums[j]$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 找到第一个0</span><br><span class="line">        for i in range(0,len(nums)):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; 0:</span><br><span class="line">                break</span><br><span class="line">        for j in range(i+1,len(nums)):</span><br><span class="line">            if nums[j] !&#x3D; 0:</span><br><span class="line">                temp &#x3D; nums[i]</span><br><span class="line">                nums[i] &#x3D; nums[j]</span><br><span class="line">                nums[j] &#x3D; temp</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>

<h2 id="Problem-10-有效的数独"><a href="#Problem-10-有效的数独" class="headerlink" title="Problem 10 有效的数独"></a>Problem 10 有效的数独</h2><h3 id="方法一：哈希表一次迭代完成"><a href="#方法一：哈希表一次迭代完成" class="headerlink" title="方法一：哈希表一次迭代完成"></a>方法一：哈希表一次迭代完成</h3><p>通过三个哈希表映射记录 行/列/子数独出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValidSudoku(self, board):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # init data</span><br><span class="line">        rows &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line">        columns &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line">        boxes &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line"></span><br><span class="line">        # validate a board</span><br><span class="line">        for i in range(9):</span><br><span class="line">            for j in range(9):</span><br><span class="line">                num &#x3D; board[i][j]</span><br><span class="line">                if num !&#x3D; &#39;.&#39;:</span><br><span class="line">                    num &#x3D; int(num)</span><br><span class="line">                    box_index &#x3D; (i &#x2F;&#x2F; 3 ) * 3 + j &#x2F;&#x2F; 3</span><br><span class="line">                    </span><br><span class="line">                    # keep the current cell value</span><br><span class="line">                    rows[i][num] &#x3D; rows[i].get(num, 0) + 1</span><br><span class="line">                    columns[j][num] &#x3D; columns[j].get(num, 0) + 1</span><br><span class="line">                    boxes[box_index][num] &#x3D; boxes[box_index].get(num, 0) + 1</span><br><span class="line">                    </span><br><span class="line">                    # check if this value has been already seen before</span><br><span class="line">                    if rows[i][num] &gt; 1 or columns[j][num] &gt; 1 or boxes[box_index][num] &gt; 1:</span><br><span class="line">                        return False         </span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>


<h2 id="Problem-11"><a href="#Problem-11" class="headerlink" title="Problem 11"></a>Problem 11</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="方法一：-转置加翻转"><a href="#方法一：-转置加翻转" class="headerlink" title="方法一： 转置加翻转"></a>方法一： 转置加翻转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :rtype: void Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n &#x3D; len(matrix[0])        </span><br><span class="line">        # transpose matrix</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i, n):</span><br><span class="line">                matrix[j][i], matrix[i][j] &#x3D; matrix[i][j], matrix[j][i] </span><br><span class="line">        </span><br><span class="line">        # reverse each row</span><br><span class="line">        for i in range(n):</span><br><span class="line">            matrix[i].reverse()</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h1><h2 id="Problem-1-字符串转换整数-atoi"><a href="#Problem-1-字符串转换整数-atoi" class="headerlink" title="Problem 1 字符串转换整数 (atoi)"></a>Problem 1 字符串转换整数 (atoi)</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</li>
</ul>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<h3 id="方法一：普通使用字符串转换写法"><a href="#方法一：普通使用字符串转换写法" class="headerlink" title="方法一：普通使用字符串转换写法"></a>方法一：普通使用字符串转换写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s: str) -&gt; int:</span><br><span class="line">        s &#x3D; s.strip(&#39; &#39;)</span><br><span class="line">        string &#x3D; &#39;0&#39;</span><br><span class="line">        if len(s) &gt; 0:</span><br><span class="line">            if s[0] &#x3D;&#x3D; &#39;-&#39; or s[0].isdigit() or s[0] &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">                string &#x3D; s[0]</span><br><span class="line">                if s[0] &#x3D;&#x3D; &#39;+&#39; or s[0] &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">                    string +&#x3D; &#39;0&#39;</span><br><span class="line">                for c in range(1,len(s)):</span><br><span class="line">                    if s[c].isdigit():</span><br><span class="line">                        string +&#x3D; s[c]</span><br><span class="line">                    else:</span><br><span class="line">                        break</span><br><span class="line">        num &#x3D; int(string)</span><br><span class="line">        if num &lt; -2**31:</span><br><span class="line">            return -2**31</span><br><span class="line">        elif num &gt; 2**31-1:</span><br><span class="line">            return 2**31-1</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>

<h3 id="方法二：利用Python正则化"><a href="#方法二：利用Python正则化" class="headerlink" title="方法二：利用Python正则化"></a>方法二：利用Python正则化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s: str) -&gt; int:</span><br><span class="line">        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;, s.lstrip())), 2**31 - 1), -2**31)</span><br></pre></td></tr></table></figure>

<p>^：匹配字符串开头<br>[+-]：代表一个+字符或-字符<br>?：前面一个字符可有可无<br>\d：一个数字<br>+：前面一个字符的一个或多个<br>\D：一个非数字字符<br>*：前面一个字符的0个或多个</p>
<hr>
<h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3 链表"></a>3 链表</h1><h2 id="Problem-1-删除链表的倒数第N个节点"><a href="#Problem-1-删除链表的倒数第N个节点" class="headerlink" title="Problem  1 删除链表的倒数第N个节点"></a>Problem  1 删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<p>对于链表类题目，对某一个特定索引的元素进行操作往往会成为增加运算时间的瓶颈，因此如何通过尽可能少的遍历次数寻找到所要操作的元素就成为关键。</p>
<h3 id="方法一：-双指针"><a href="#方法一：-双指针" class="headerlink" title="方法一： 双指针"></a>方法一： 双指针</h3><p>为了方便，我们在原有链表前面设置一个哑结点，哑结点的好处在于，因为这里我们是要删除一个结点，所以我们可以定位到被删除结点的前置结点，然后将前置结点的后续指针指向被删除结点的后续结点，则可完成删除。</p>
<p>我们设置两个指针，两个指针初始状态都指向哑结点，指针fast 先走n步，然后指针fast和指针slow同步往前继续遍历链表，直至fast的后续结点为空，此时指针slow到达被删除结点的前置结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode:</span><br><span class="line">	def __init__(self, x):</span><br><span class="line">		self.val &#x3D; x</span><br><span class="line">		self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">	def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">		if not head:</span><br><span class="line">			return head</span><br><span class="line">		slownode &#x3D; ListNode(None)</span><br><span class="line">		slownode.next &#x3D; head</span><br><span class="line">		fastnode &#x3D; slownode</span><br><span class="line">		for i in range(n):</span><br><span class="line">			fastnode &#x3D; fastnode.next</span><br><span class="line">		while(fastnode.next!&#x3D;None):</span><br><span class="line">			slownode &#x3D; slownode.next</span><br><span class="line">			fastnode &#x3D; fastnode.next</span><br><span class="line">		if slownode.next &#x3D;&#x3D; head:</span><br><span class="line">			head &#x3D; head.next</span><br><span class="line">		else:</span><br><span class="line">			slownode.next &#x3D; slownode.next.next</span><br><span class="line">		return head</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>先通过head.next = self.removeNthFromEnd(head.next,n)，找到base case也就是if head is None时，设i=0.<br>然后通过递归慢慢向前并每次加一，找到倒数第n个节点，并且返回这个要删除节点的next。<br>如果i!=n，也就是这个节点要保留，返回这个节点（通过.next也包括了他后面的那些节点）。<br>返回节点时会通过head.next = self.removeNthFromEnd(head.next,n)把每次返回的节点接到head.next上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        global i </span><br><span class="line">        if head is None:</span><br><span class="line">            i&#x3D;0</span><br><span class="line">            return None</span><br><span class="line">        head.next &#x3D; self.removeNthFromEnd(head.next,n)</span><br><span class="line">        i+&#x3D;1</span><br><span class="line">        return head.next if i&#x3D;&#x3D;n else head</span><br></pre></td></tr></table></figure>





<h2 id="Problem-2-翻转链表"><a href="#Problem-2-翻转链表" class="headerlink" title="Problem 2  翻转链表"></a>Problem 2  翻转链表</h2><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="方法一：双指针法"><a href="#方法一：双指针法" class="headerlink" title="方法一：双指针法"></a>方法一：双指针法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        cur &#x3D; head</span><br><span class="line">        while cur:</span><br><span class="line">            temp &#x3D; cur.next   # 先把原来cur.next位置存起来</span><br><span class="line">            cur.next &#x3D; pre</span><br><span class="line">            pre &#x3D; cur</span><br><span class="line">            cur &#x3D; temp</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归-1"><a href="#方法二：递归-1" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        ## 递归</span><br><span class="line">        if not (head and head.next):</span><br><span class="line">            return head</span><br><span class="line">        </span><br><span class="line">        newHead &#x3D; self.reverseList(head.next)</span><br><span class="line">        </span><br><span class="line">        head.next.next &#x3D; head</span><br><span class="line">        head.next &#x3D; None</span><br><span class="line">        return newHead</span><br></pre></td></tr></table></figure>

<h2 id="Problem-3-合并两个有序链表"><a href="#Problem-3-合并两个有序链表" class="headerlink" title="Problem 3 合并两个有序链表"></a>Problem 3 合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="方法一：-递归"><a href="#方法一：-递归" class="headerlink" title="方法一： 递归"></a>方法一： 递归</h3><p>当我们使用递归方法解题时，主要思考两个关键</p>
<ul>
<li>递归的中值条件</li>
<li>递归不断调用自身，直到遇到终止条件后进行回溯，最终返回答案</li>
</ul>
<p>所以根据以上考虑本题</p>
<ul>
<li>终止条件： 当两个链表都为空时，表示我们对链表已合并完成</li>
<li>如何递归： 判断l1,l2头结点哪个更小，然后较小结点next指针指向其余结点的合并结果（调用递归）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1: return l2  # 终止条件，直到两个链表都空</span><br><span class="line">        if not l2: return l1</span><br><span class="line">        if l1.val &lt;&#x3D; l2.val:  # 递归调用</span><br><span class="line">            l1.next &#x3D; self.mergeTwoLists(l1.next,l2)</span><br><span class="line">            return l1</span><br><span class="line">        else:</span><br><span class="line">            l2.next &#x3D; self.mergeTwoLists(l1,l2.next)</span><br><span class="line">            return l2</span><br></pre></td></tr></table></figure>

<h3 id="方法二：-双指针"><a href="#方法二：-双指针" class="headerlink" title="方法二： 双指针"></a>方法二： 双指针</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        phead &#x3D; ListNode(0)</span><br><span class="line">        dummy &#x3D; phead</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt;&#x3D; l2.val:</span><br><span class="line">                dummy.next &#x3D; l1</span><br><span class="line">                dummy &#x3D; dummy.next</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            else:</span><br><span class="line">                dummy.next &#x3D; l2</span><br><span class="line">                dummy &#x3D; dummy.next</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">        if l1:</span><br><span class="line">            dummy.next &#x3D; l1</span><br><span class="line">        if l2:</span><br><span class="line">            dummy.next &#x3D; l2</span><br><span class="line">        return phead.next</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（六）：应用层</title>
    <url>/2020/08/17/network6/</url>
    <content><![CDATA[<h1 id="1-网络应用模型"><a href="#1-网络应用模型" class="headerlink" title="1 网络应用模型"></a>1 网络应用模型</h1><h2 id="1-1-客户-服务器模型"><a href="#1-1-客户-服务器模型" class="headerlink" title="1.1 客户/服务器模型"></a>1.1 客户/服务器模型</h2><p>分为客户和服务器</p>
<h2 id="1-2-P2P模型"><a href="#1-2-P2P模型" class="headerlink" title="1.2 P2P模型"></a>1.2 P2P模型</h2><p>两台主机通信不区分哪一个是服务请求那有个是服务器提供方，进行平等，对等连接通信</p>
<a id="more"></a>

<h1 id="2-DNS系统"><a href="#2-DNS系统" class="headerlink" title="2 DNS系统"></a>2 DNS系统</h1><p>DNS基于UDP协议实现</p>
<p>采用层次树桩结构的命名方式</p>
<p>（1）根域名服务器</p>
<p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器</p>
<p>（2）顶级域名服务器</p>
<p>负责管理在该顶级域名服务器注册的所有二级域名</p>
<p>（3）权限域名服务器</p>
<p>（4）本地域名服务器</p>
<p>本地域名服务器采用迭代查询</p>
<h1 id="3-FTP"><a href="#3-FTP" class="headerlink" title="3 FTP"></a>3 FTP</h1><p>使用TCP可靠的传输服务，主进程工作步骤如下</p>
<p>（1）打开熟知端口，使客户进程能够连接上</p>
<p>（2）等待客户进程发出连接请求</p>
<p>（3）启动从属进程处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程</p>
<p>（4）回到等待状态，继续接受其他客户进程发来的请求</p>
<h1 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h1><p>（1）MIME</p>
<p>SMTP有以下缺点</p>
<ol>
<li>不能传送可执行文件或其他二进制对象</li>
<li>限于传送7位ASCII码</li>
<li>SMTP服务器会拒绝超过一定长度的邮件</li>
<li>某些SMTP的实现并没有完全按照SMTP互联网标准</li>
</ol>
<p>于是提出了互联网邮件扩充MIME</p>
<p>（2）SMTP协议</p>
<p>规定了两个相互通信的SMTP进程之间如何交换信息</p>
<p>（3）POP</p>
<p>邮局协议POP是一个非常简单、但功能有限的邮件读取协议</p>
<h1 id="5-WWW"><a href="#5-WWW" class="headerlink" title="5 WWW"></a>5 WWW</h1><p>并非某种特殊的计算机网络，是一个大规模的、联机式的信息储藏所，能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息，这种访问方式称为链接</p>
<h1 id="6-HTTP协议"><a href="#6-HTTP协议" class="headerlink" title="6 HTTP协议"></a>6 HTTP协议</h1><p>HTTP是面向事务的应用层协议</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/A52B3CB112F24C5E9369903B8FEB75A7?method=download&shareKey=811633ce773f37161ee8950040f2b30c" alt></p>
<p>用户点击鼠标后所发生的时间</p>
<ol>
<li>浏览器分析超链接所指向页面的URL</li>
<li>浏览器想DNS请求<a href="http://www.tsinghua.edu.cn的IP地址" target="_blank" rel="noopener">www.tsinghua.edu.cn的IP地址</a></li>
<li>域名系统DNS解析出清华大学服务器IP地址</li>
<li>浏览器与服务器建立TCP连接</li>
<li>浏览器发出取文件命令</li>
<li>服务器给出相应，把文件发给浏览器</li>
<li>TCP连接释放</li>
<li>浏览器显示文本文件内容</li>
</ol>
<p>HTTP两类报文：</p>
<p>（1）请求报文————从客户想服务器发送请求报文</p>
<p>（2）响应报文————从服务器到客户的回答</p>
<hr>
<h1 id="7-常见面试问题总结"><a href="#7-常见面试问题总结" class="headerlink" title="7 常见面试问题总结"></a>7 常见面试问题总结</h1><h2 id="7-1-在浏览器输入url地址，显示主页的过程"><a href="#7-1-在浏览器输入url地址，显示主页的过程" class="headerlink" title="7.1 在浏览器输入url地址，显示主页的过程"></a>7.1 在浏览器输入url地址，显示主页的过程</h2><p>总体来说分为以下几个过程</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理并换回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/73A4BC32978B40C59BA640BB36EC3F56?method=download&shareKey=f38ebfffcb05bc48176deed0c0ed2c7a" alt></p>
<h2 id="7-2-状态码"><a href="#7-2-状态码" class="headerlink" title="7.2 状态码"></a>7.2 状态码</h2><p><img src="https://note.youdao.com/yws/api/personal/file/3BEA8247A061405F821B87E697558037?method=download&shareKey=8281ad343ddc80a635d32d1eff1f3216" alt></p>
<h2 id="7-3-各种协议与HTTP协议之间的关系"><a href="#7-3-各种协议与HTTP协议之间的关系" class="headerlink" title="7.3 各种协议与HTTP协议之间的关系"></a>7.3 各种协议与HTTP协议之间的关系</h2><p><img src="https://note.youdao.com/yws/api/personal/file/DC3E01C9A25B4DCE99F6018F5A51636F?method=download&shareKey=5017d608dee88ba4252fd3c868f7d7c2" alt></p>
<h2 id="7-4-HTTP长连接，短连接"><a href="#7-4-HTTP长连接，短连接" class="headerlink" title="7.4 HTTP长连接，短连接"></a>7.4 HTTP长连接，短连接</h2><p>在HTTP/1.0中默认使用短连接，也就是说，客户端和服务端每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p>
<p>从HTTP/1.1起，默认使用长连接，用以保持连接特性，在当一个网页打开完成后，客户端和服务器之间用于传输HTTP的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用一条已经建立的连接</p>
<h2 id="7-5-HTTP是不保存状态的协议，如何保存用户状态"><a href="#7-5-HTTP是不保存状态的协议，如何保存用户状态" class="headerlink" title="7.5 HTTP是不保存状态的协议，如何保存用户状态"></a>7.5 HTTP是不保存状态的协议，如何保存用户状态</h2><p>HTTP协议自身不对请求和相应之间的通信状态进行保存，Session机制的存在可以通过服务端记录用户的状态</p>
<p>在服务端保存Session的方法，最常用的就是内存和数据库，通过Cookie中附加一个Session ID来跟踪</p>
<p>Cookie被禁用怎么办？</p>
<p>最常用的就是利用URL重写把Session ID直接附加在URL路径的后面</p>
<h2 id="7-6-Cookie的作用是什么？和Session有什么区别？"><a href="#7-6-Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="7.6 Cookie的作用是什么？和Session有什么区别？"></a>7.6 Cookie的作用是什么？和Session有什么区别？</h2><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样</p>
<p>Cookie一般用来保存用户信息</p>
<p>Session主要作用就是通过服务端记录用户的状态</p>
<h2 id="7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？"><a href="#7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？" class="headerlink" title="7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？"></a>7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？</h2><ol>
<li>长连接</li>
<li>错误状态响应码</li>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用</li>
</ol>
<h2 id="7-8-URI和URL的区别是什么？"><a href="#7-8-URI和URL的区别是什么？" class="headerlink" title="7.8 URI和URL的区别是什么？"></a>7.8 URI和URL的区别是什么？</h2><ul>
<li>URI是统一资源标志符，可以唯一标志一个资源</li>
<li>URL是统一资源定位符，可以提供该资源的路径</li>
</ul>
<h2 id="7-9-HTTP和HTTPS的区别"><a href="#7-9-HTTP和HTTPS的区别" class="headerlink" title="7.9 HTTP和HTTPS的区别"></a>7.9 HTTP和HTTPS的区别</h2><ol>
<li>端口：HTTP默认端口为80，而HTTPS默认端口443</li>
<li>安全性和资源消耗：HTTP协议运行在TCP纸上。所有传输的内容都是明文，客户端和服务器都无法验证对方的身份，HTTPS运行在SSL/TLS纸上的HTTP协议，所有传输内容都经过加密，加密采用对称加密，但密钥用服务器的证书使用非对称加密<ul>
<li>对称加密：密钥只有一个，加密解密为同一密码，典型的对称加密算法有：DES、AES等</li>
<li>非对称加密：密钥成对出现，加密解密使用不同密钥</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（五）：传输层</title>
    <url>/2020/08/16/network5/</url>
    <content><![CDATA[<h1 id="1-传输层提供的服务"><a href="#1-传输层提供的服务" class="headerlink" title="1 传输层提供的服务"></a>1 传输层提供的服务</h1><h2 id="1-1-传输层的功能"><a href="#1-1-传输层的功能" class="headerlink" title="1.1 传输层的功能"></a>1.1 传输层的功能</h2><ul>
<li>传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务</li>
<li>传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网在技术、设计上的差异和服务质量的不足，想高层提供一个标准的完善的通信服务</li>
<li>从通信和信息处理的角度看，应用层是面向信息处理的，而传输层是为应用层提供通信服务的</li>
<li>对收到的报文进行差错校验</li>
<li>面向连接的TCP和无连接的UDP</li>
</ul>
<a id="more"></a>

<h2 id="1-2-传输层寻址与端口"><a href="#1-2-传输层寻址与端口" class="headerlink" title="1.2 传输层寻址与端口"></a>1.2 传输层寻址与端口</h2><p>TCP/IP传输层端口</p>
<ul>
<li>用16位端口</li>
<li>只具有本地含义</li>
<li>不同计算机的相同端口号没有联系</li>
</ul>
<p>两个计算机中的进程要相互通信，不仅要知道对方的IP地址，还要知道对方的端口号</p>
<p>两大类端口</p>
<p>（1）服务器</p>
<ul>
<li>熟知端口，一般0-1023</li>
<li>登记端口号，一般为1024-49151</li>
</ul>
<p>（2）客户端</p>
<ul>
<li>短暂端口号，留给客户进程使用，一般为49152-65535</li>
<li>端口为动态的</li>
</ul>
<h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2 UDP协议"></a>2 UDP协议</h1><p>（1）UPD无连接的</p>
<p>（2）使用尽最大努力交付，不保证可靠交付</p>
<p>（3）UPD是面向报文的</p>
<p>（4）UPD没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低</p>
<p>（5）UPD支持一对一、一对多、多对一和多对多的交互通信</p>
<p>（6）UPD的首部开销小，只有8个字节，比TCP的20字节小</p>
<h2 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h2><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8字节，由四个字段组成，每个字段长度都是两个字节</p>
<p>（1）源端口</p>
<p>（2）目的端口</p>
<p>（3）长度UPD用户数据报的长度</p>
<p>（4）检验和检测UDP用户数据报在传输中是否有错</p>
<p>UDP校验是伪首部和尾部一起校验</p>
<h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3 TCP协议"></a>3 TCP协议</h1><h2 id="3-1-TCP段"><a href="#3-1-TCP段" class="headerlink" title="3.1 TCP段"></a>3.1 TCP段</h2><ul>
<li>面向连接</li>
<li>只能有两个端点，只能是点对点</li>
<li>可靠交付</li>
<li>提供全双工</li>
<li>面向字节流</li>
<li>TCP连接是一条虚连接</li>
<li>根据对方给出的窗口值和当前网络拥塞程度来决定一个报文段应包含多少个字节</li>
<li>TCP可把太长的数据块划分短一些再传送</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/3CCDFBC7B5024E868952FBEC3B448C20?method=download&shareKey=4bfc577c3122e1322f3393d6719657e4" alt></p>
<h2 id="3-2-TCP的连接管理"><a href="#3-2-TCP的连接管理" class="headerlink" title="3.2 TCP的连接管理"></a>3.2 TCP的连接管理</h2><ul>
<li>TCP把连接作为最基本的抽象</li>
<li>每一条TCP连接有两个端点</li>
<li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口，TCP连接的端点叫做套接字或插口</li>
<li>端口号拼接到IP地址即构成了套接字</li>
<li>传输连接有三个阶段，即：建立连接，数据传送和连接释放</li>
<li>建立连接过程要解决一下三个问题<ul>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数</li>
<li>能够传输实体资源</li>
</ul>
</li>
</ul>
<p>（1）建立连接（三次握手）</p>
<p>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段，称为三报文握手，主要是为了防止已失效的连接请求报文突然又传送到了，因而产生错误</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/5CEAF751EA4C4C7C9704310F6F7FCBA0?method=download&shareKey=ad2bd6d9c823843d2879523899a3111a" alt></p>
<p>一开始TCP服务器创建传输控制块，准备接受客户进程的连接请求，然后服务器进程处理LISTEN收听状态，等待客户的连接请求，如有即作出响应</p>
<ol>
<li><p>TCP客户也创建传输控制模块，在打算建立TCP连接时，向服务端发出连接请求报文，TCP客户端进程进入SYN-SENT同步已发送状态</p>
</li>
<li><p>服务端到请求报文后，如同意建立连接，则发送确认，进入同步收到状态</p>
</li>
<li><p>TCP客户进程收到服务端的确认后，再给服务端给出确认，这时TCP连接已经建立，客户端进入已建立连接状态</p>
</li>
</ol>
<p>当服务端收到客户端的确认后，也进入已建立连接状态</p>
<p>（2）连接释放（四次握手）</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/1F81C26CCC94472593D302BE252F06E1?method=download&shareKey=90481f9f275da417bc784de3e700f2b1" alt></p>
<ol>
<li>客户端先想服务端发出连接释放报文，并停止再发送数据，主动关闭TCP连接，等待服务端的确认</li>
<li>服务端收到连接释放报文后即发出确认，这时TCP连接处于半关闭状态，即服务端到客户端连接并未关闭</li>
<li>客户端收到服务端的确认后，等待服务端发送的连接释放报文，若服务端也没有要发送的数据，则发出连接释放报文，等待客户端的确认</li>
<li>客户端收到服务端的连接释放报文后，对此发出确认，经过时间等待计时器设置的时间后，进入关闭状态</li>
</ol>
<h2 id="3-3-TCP可靠传输"><a href="#3-3-TCP可靠传输" class="headerlink" title="3.3 TCP可靠传输"></a>3.3 TCP可靠传输</h2><ul>
<li>TCP连接的每一端都必须设有两个窗口，一个发送窗口和一个接受窗口</li>
<li>TCP的可靠传输机制用字节的序号进行控制，所有的确认都是基于序号而不是基于报文段</li>
<li>TCP两端的四个窗口处于动态变化之中</li>
<li>TCP连接的往返时间RTT也不是固定不变的，需要使用特点的算法估算较为合理的重传时间</li>
</ul>
<p>（1）TCP的滑动窗口</p>
<p>发送窗口的范围与接收方给发送方设置的“窗口”值有关，也与发送方已发送但未被确认的TCP报文段的数量有关，每当接收方正确收到一个TCP报文段并交给上层，便发回相应的确认报文，发送方收到相应的确认，便将对应已发并确认的发送缓冲释放，发送窗口同时向前滑动</p>
<h2 id="3-4-TCP流量控制与拥塞控制"><a href="#3-4-TCP流量控制与拥塞控制" class="headerlink" title="3.4 TCP流量控制与拥塞控制"></a>3.4 TCP流量控制与拥塞控制</h2><p>（1）流量控制</p>
<p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受</p>
<p>（2）拥塞控制</p>
<p>TCP基于窗口进行拥塞控制，属于闭环控制方法</p>
<p>TCP发送方维持一个拥塞窗口CWND</p>
<ul>
<li>大小取决于网络的拥塞程度，并且动态地在变化</li>
<li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量</li>
<li>发送窗口大小不仅取决于接收方公告的接受窗口，还取决于网络的拥塞情况，所以真正的发送窗口值为：</li>
</ul>
<p>真正的发送窗口值=MIN（公告接受窗口值，拥塞窗口值）</p>
<p>只要网络没有出现拥塞，拥塞窗口可以大一些，只要出现拥塞，就必须把拥塞窗口减小一点</p>
<p>拥塞的判断</p>
<ul>
<li>重传定时器超时</li>
<li>收到三个相同重复的ACK，预示可能会出现拥塞</li>
</ul>
<p>TCP拥塞控制算法</p>
<p>（1）慢开始</p>
<p>由小到大逐渐增大拥塞窗口数值</p>
<p>初始拥塞窗口cwnd设置：</p>
<ul>
<li>旧的规定：设置为1-2个发送方的最大报文段SMSS的数值</li>
<li>新的固定：设置2-4个SMSS</li>
</ul>
<p>没有特殊说明就是1个SMSS</p>
<p>慢开始门限：防止拥塞窗口增长过大</p>
<p>每收到一个新的报文段确认，可以把拥塞窗口增加多一个</p>
<p>每经过一个传输轮次，拥塞窗口加倍。窗口按指数增加</p>
<p><img src="http://note.youdao.com/noteshare?id=82b0ebf222a392a52865e1c74a15e32f&sub=9845A0F352624ADC8CBD58346DC17652" alt></p>
<p>（2）拥塞避免算法</p>
<p>没经过一个往返时间RTT就把拥塞窗口加1，使拥塞窗口按线性规律缓慢增大</p>
<p>当网络出现拥塞时</p>
<p>门限阈值设为窗口/2</p>
<p>窗口设置为1</p>
<p>执行慢开始算法</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/E4D159D17BC24A0BBAC287D02DFFE98B?method=download&shareKey=a7eaab7740e883c4240ec1404c584dd8" alt></p>
<p>（3）快重传算法</p>
<p>只要收到三个重复确认，立即进行重传</p>
<p>（4）快恢复</p>
<p>当连续收到三个重复确认</p>
<ol>
<li>慢开始门限=当前拥塞窗口/2</li>
<li>新拥塞窗口=慢开始门限</li>
<li>执行拥塞避免算法</li>
</ol>
<hr>
<h1 id="4-面试常见问题总结"><a href="#4-面试常见问题总结" class="headerlink" title="4 面试常见问题总结"></a>4 面试常见问题总结</h1><h2 id="4-1-三次握手和四次握手"><a href="#4-1-三次握手和四次握手" class="headerlink" title="4.1 三次握手和四次握手"></a>4.1 三次握手和四次握手</h2><p>（1）三次握手</p>
<ul>
<li>客户端发送带有SYN标志的数据报给服务端</li>
<li>服务端发送带有SYN/ACK标志的数据报给客户端</li>
<li>客户端发送带有ACK标志的数据报给服务端</li>
</ul>
<blockquote>
<p>SYN同步序列编号，是TCP/IP建立连接时使用的握手信号，在客户机和服务器之间建立正常的TCP网络连接时，客户端首先发出一个SYN消息，服务器使用SYN-ACK应答表示接受到了这个消息，最后客户端再以ACK消息响应，这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户端和服务器之间传递</p>
</blockquote>
<p>三次握手的目的是建立可靠通信，能够使双方确认自己与对方的发送与接收都是正常的</p>
<p>（2）四次握手</p>
<ul>
<li>客户端发送一个FIN用来关闭客户端到服务器的数据发送</li>
<li>服务器收到FIN，发回一个ACK，确认序号为收到的序号加1</li>
<li>服务器关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态，当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接</p>
<h2 id="4-2-TCP和UDP协议的区别"><a href="#4-2-TCP和UDP协议的区别" class="headerlink" title="4.2 TCP和UDP协议的区别"></a>4.2 TCP和UDP协议的区别</h2><ul>
<li>UPD在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给任何确认，虽然UDP不提供可靠交付，但在某些情况下UDP却是一种罪有效的工作方式（一般永固即时通信），比如语音、视频、直播等</li>
<li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束要释放连接，TCP不提供广播或多播服务，由于TCP要提供可靠的，面向连接的传输服务，会增加许多开销，一般用于文件传送，接受邮件、远程登录等</li>
</ul>
<h2 id="4-3-TCP协议如何保证可靠传输"><a href="#4-3-TCP协议如何保证可靠传输" class="headerlink" title="4.3 TCP协议如何保证可靠传输"></a>4.3 TCP协议如何保证可靠传输</h2><ol>
<li>应用数据被分割成TCP认为最适合发送的数据块</li>
<li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层</li>
<li>校验和：TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测书剑在传送过程中的任何变化，如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li>
<li>TCP的接受端会丢弃重复的数据</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只会允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送速率，防止包丢失，TCP使用的流量控制协议是可变大小的滑动窗口协议</li>
<li>拥塞控制：当网络拥塞时，减少数据的发送</li>
<li>ARQ协议：每发完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li>
<li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</li>
</ol>
<p>（1）ARQ协议</p>
<p>自动重传请求是OSI模型中数据链路层和传输层错误纠正协议之一，通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输，如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送，ARQ包括停止等待协议ARQ和连续ARQ</p>
<p><strong>停止等待ARQ协议</strong></p>
<ul>
<li>停止等待协议是为了实现可靠传输的，基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK），如果过了一段时间后，还没有收到ACK确认，就说明没有发送成功，需要重新发送，知道收到确认后再发送下一个分组</li>
<li>若收到重复分组，就丢弃该分组，但同时还要发送确认</li>
</ul>
<p>简单，但是信道利用率低</p>
<p><strong>无差错情况</strong></p>
<p>在规定时间能收到，并回复确认，发送方再次传送下一个数据</p>
<p><strong>出现差错情况（超时重传）</strong></p>
<p>每发送完一个分组需要设置一个超时计时器，重传时间比数据在分组传输的平均往返时间更长一些，称为自动重传请求ARQ。</p>
<p>而连续ARQ可提高信道利用率，发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p>
<p><strong>确认丢失和确认迟到</strong></p>
<ul>
<li>确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失，而A不知道，在超时计时后，A重传M1下次，B再次收到该消息后采取以下两点措施：1.丢弃这个重复的M1消息，不向上层交付。2.向A发送确认消息</li>
<li>确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认，在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息，此时A收到了B第二次发送的确认消息，接着发送其他数据，过了一会儿，A又收到了B第一次发送的迟到确认消息，处理如下：1.A收到重复的确认后，直接丢弃2.B收到重复的M1也直接丢弃重复的M1</li>
</ul>
<p><strong>连续ARQ协议</strong></p>
<p>连续ARQ协议可提高信道利用率，发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p>
<p>优点是信道利用率高，容易实现，即使确认丢失，也不必重传</p>
<p>缺点是不能像发送方反映出接受方已经正确收到的所有分组信息。当出现丢失时，需要退回重传已经发送过的N个消息</p>
<p>（2）滑动窗口和流量控制</p>
<p>TCP利用滑动窗口实现流量控制，为了控制发送方发送的速率，保证接收方来得及接收</p>
<p>（3）拥塞控制</p>
<p>拥塞控制是一个全局性的过程，设计到所有的主机，所有的路由器，以及降低网络传输性能有关的所有因素</p>
<p>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</p>
<p>TCP的拥塞控制采用了四种算法：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使用路由器采用适当的分组丢弃策略（主动队列管理AQM），以减少网络拥塞的发生</p>
<ul>
<li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入网络，那么可能会引起网络阻塞，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，cwnd初始值为1，每经过一个传播轮次，cwnd加倍</li>
<li>拥塞避免：拥塞避免算法的思路是rag拥塞窗口cwnd缓慢增大，没经过一个往返时间RTT就把发送的cwnd加1</li>
<li>快重传和快恢复：在TCP/IP中，快重传和恢复是一种拥塞控制算法，它能快速恢复丢失的数据报。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。有了FRR，如果接收机收到了一个不按顺序的数据段，它会立即给发送机发送一个重复确认，如果接受到三个重复确认，它会假定确认件直除的数据段丢失了，并立即重传这些丢失的数据段</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结（四）：文件系统</title>
    <url>/2020/08/28/os4/</url>
    <content><![CDATA[<h1 id="1-文件系统基础"><a href="#1-文件系统基础" class="headerlink" title="1 文件系统基础"></a>1 文件系统基础</h1><h2 id="1-1-文件的概念"><a href="#1-1-文件的概念" class="headerlink" title="1.1 文件的概念"></a>1.1 文件的概念</h2><p>文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。</p>
<a id="more"></a>
<p>用户通过文件系统建立文件，提供应用程序的输入输出，对资源进行管理。首先了解文件的结构，我们通过自底向上的方式来定义。</p>
<ol>
<li>数据项：数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：基本数据项和组合数据项</li>
<li>记录：记录是一组相关的数据项集合，用于描述一个对象在某方面的属性</li>
<li>文件：文件是指由穿件这所定义的一组相关信息的集合，可分为有结构文件和无结构文件两种。</li>
</ol>
<p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：</p>
<ul>
<li>名称</li>
<li>标识符</li>
<li>类型</li>
<li>位置</li>
<li>大小</li>
<li>保护</li>
<li>时间、日期和用户标识</li>
</ul>
<p>文件属于抽象数据类型。为了恰当的定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，他对文件进行创建、写、读、定位和截断。</p>
<p>每个打开文件都有如下关联信息：</p>
<ul>
<li>文件指针</li>
<li>文件打开计数</li>
<li>文件磁盘位置</li>
<li>访问权限</li>
</ul>
<h2 id="1-2-文件的逻辑结构"><a href="#1-2-文件的逻辑结构" class="headerlink" title="1.2 文件的逻辑结构"></a>1.2 文件的逻辑结构</h2><p>按逻辑结构，文件有无结构文件和有结构文件两种类型：</p>
<ol>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序表</li>
<li>直接文件或散列文件</li>
</ol>
<h1 id="1-3-目录结构"><a href="#1-3-目录结构" class="headerlink" title="1.3 目录结构"></a>1.3 目录结构</h1><p>与文件管理系统和文件集合相关联的是文件目录，它包含有文件的信息，包括属性、位置和所有权等，这些信息都由操作系统进行管理。首先我们来看目录管理的基本要求 ：从用户的角度看，目录在用户所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在共享系统中，目录还需要提供用于控制访问文件的信息。此外，文件允许重名也是用户的合理和必然要求，目录管理通过树形结构来解决和实现。</p>
<h1 id="1-4-文件共享"><a href="#1-4-文件共享" class="headerlink" title="1.4 文件共享"></a>1.4 文件共享</h1><p>文件共享十多个用户进程共享同一份文件，系统中只需保留该文件的一份副本。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。</p>
<p>随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过c/s模型共享网络中的服务器文件。</p>
<h1 id="1-5-文件保护"><a href="#1-5-文件保护" class="headerlink" title="1.5 文件保护"></a>1.5 文件保护</h1><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p>
<p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了方式用户文件被他人存取或盗取，而访问控制则用于控制用户对文件的访问方式。</p>
<p>对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：</p>
<ul>
<li><p>读：从文件中读。</p>
</li>
<li><p>写：向文件中写。</p>
</li>
<li><p>执行：将文件装入内存并执行。</p>
</li>
<li><p>添加：将信息添加到文件结尾部分。</p>
</li>
<li><p>删除：删除文件，释放空间。</p>
</li>
<li><p>列表清单：列出文件名和文件属性。</p>
</li>
</ul>
<h1 id="2-文件系统实现"><a href="#2-文件系统实现" class="headerlink" title="2 文件系统实现"></a>2 文件系统实现</h1><h2 id="2-1-文件系统层次结构"><a href="#2-1-文件系统层次结构" class="headerlink" title="2.1 文件系统层次结构"></a>2.1 文件系统层次结构</h2><p>现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。</p>
<p>文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。</p>
<h2 id="2-2-目录实现"><a href="#2-2-目录实现" class="headerlink" title="2.2 目录实现"></a>2.2 目录实现</h2><p>在读文件前，必须先打开文件。打开文件时，操作系统利用路径名吵到相应目录项，目录项中提供了查找文件磁盘块所需要的信息，目录实现的基本方法有线性列表和哈希表两种方法。</p>
<h2 id="2-3-文件实现"><a href="#2-3-文件实现" class="headerlink" title="2.3 文件实现"></a>2.3 文件实现</h2><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方式有三种：连续分配、链接分配和索引分配。有的系统对三种方式都支持，但是更普遍的是一个系统只提供一种方法支持。</p>
<h1 id="3-磁盘组织与管理"><a href="#3-磁盘组织与管理" class="headerlink" title="3 磁盘组织与管理"></a>3 磁盘组织与管理</h1><h2 id="3-1-磁盘的结构"><a href="#3-1-磁盘的结构" class="headerlink" title="3.1 磁盘的结构"></a>3.1 磁盘的结构</h2><p>磁盘是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称谓磁头的到体系安全从磁盘中存取数据。在读写操作期间，磁头固定，磁盘在下面高速旋转。</p>
<h2 id="3-2-磁盘调度算法"><a href="#3-2-磁盘调度算法" class="headerlink" title="3.2 磁盘调度算法"></a>3.2 磁盘调度算法</h2><p>1、先来先服务（FCFS）算法</p>
<p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度处理，这是一种最简单的调度算法。这种算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则会达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往低于随即调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。</p>
<p>2、最短寻找时间优先（SSTF）算法</p>
<p>SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，一是每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能。这种算法会产生饥饿现象</p>
<p>3、扫描（SCAN）算法</p>
<p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最扫描过的区域不公平，因此，他在访问局部性方面不如FCFS算法和SSTF算法好。</p>
<p>4、循环扫描算法（C-SCAN）</p>
<p>在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p>
<h2 id="3-3-磁盘的管理"><a href="#3-3-磁盘的管理" class="headerlink" title="3.3 磁盘的管理"></a>3.3 磁盘的管理</h2><p>了使用磁盘存储文件。操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为一个或多个柱面组成分区；低而不对物理分区进行逻辑格式化，操作系统将出师的文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结（二）：进程管理</title>
    <url>/2020/08/28/os2/</url>
    <content><![CDATA[<h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h1><h2 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h2><p>（1）进程的概念</p>
<p>从不同的角度，进程可以由不同的定义：</p>
<ol>
<li>进程是程序的一次执行过程</li>
<li>进程是一个程序及其数据在处理器上顺序执行时发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</li>
</ol>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<a id="more"></a>

<p>（2）进程的特征</p>
<ol>
<li>动态性：他有着创建、活动、暂停、终止过程</li>
<li>并发性：多个进程实体，同存于内存中，能在一段时间内同时运行</li>
<li>独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li>
<li>异步性：由于进程的相互制约，是进程具有执行的间断性</li>
<li>结构性：进程实体是由程序段、数据段和进程控制段三部分组成</li>
</ol>
<h2 id="1-2-进程的状态和转换"><a href="#1-2-进程的状态和转换" class="headerlink" title="1.2 进程的状态和转换"></a>1.2 进程的状态和转换</h2><ol>
<li>运行状态</li>
<li>就绪状态：准备运行的状态</li>
<li>阻塞状态：等待状态，等待某一时间而暂停运行</li>
<li>创建状态：进程正在被创建，尚未转到就绪状态</li>
<li>结束状态</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/6D5D188BA55446DFB84D2D1071280B51?method=download&shareKey=c78907ea956c694fbab1ef69a75a8d42" alt></p>
<h2 id="1-3-进程控制"><a href="#1-3-进程控制" class="headerlink" title="1.3 进程控制"></a>1.3 进程控制</h2><p>在操作系统中，一般把进程控制用的程序段称为原语:由若干条指令构成的院子操作，作为一个整体不可分割，要么全都做，要么全部做</p>
<p>允许一个进程创建另一个进程</p>
<p>创建一个新进程的过程如下</p>
<ol>
<li>为新进程分配一个唯一进程标示号，申请一个空白PCB</li>
<li>为进程分配资源</li>
<li>初始化PCB，主要包括初始化标识信息，初始化处理器状态信息和初始化处理器控制信息</li>
<li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行</li>
</ol>
<p>终止进程的过程如下：</p>
<ol>
<li>根据终止进程标识符，检索PCB，从中读出该进程的状态</li>
<li>若被终止进程处于执行状态，立即终止进程的执行，将处理器资源分配给其他进程</li>
<li>若该进程还有子进程，则应将其所有子进程终止</li>
<li>将该进程拥有所有资源返还给操作系统</li>
<li>将该PCB从所在队列中删除</li>
</ol>
<p>进程的阻塞如下：</p>
<ol>
<li>找到将要被阻塞的标示号对应PCB，如果该进程为运行状态，则保护线程，将其状态改为阻塞状态，停止运行</li>
<li>若为就绪状态，则将其状态改为阻塞状态，把它溢出就绪队列，插入等待队列</li>
</ol>
<p><strong>进程的阻塞是进程自身的一种主动行为</strong></p>
<p>进程唤醒如下：</p>
<ol>
<li>在改时间的等待队列中找到相应进程的PCB，然后把该PCB插入到就绪队列中，等待调度程序调度</li>
</ol>
<p>进程切换过程如下：</p>
<ol>
<li>保存处理器上下文</li>
<li>更新PCB信息</li>
<li>把PCB移入相应队列</li>
<li>选择另一个进程执行</li>
<li>恢复处理器上下文</li>
</ol>
<h1 id="1-4-进程的组织"><a href="#1-4-进程的组织" class="headerlink" title="1.4 进程的组织"></a>1.4 进程的组织</h1><p>PCB主要包括：进程描述信息、进程控制和管理信息、资源分配清淡和处理器相关信息等</p>
<p>放了方便进程调度和管理，需要将各进程的PCB用适当的方法组织起来，目前常用的组织方式有连接方式和索引方式两种。连接方式将同一状态的PCB连接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项只想相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p>
<h1 id="1-5-进程的通信"><a href="#1-5-进程的通信" class="headerlink" title="1.5 进程的通信"></a>1.5 进程的通信</h1><p>（1）共享存储</p>
<p>在通信的进程之间存在着一款可以直接访问的共享空间，通过对这块共享空间的读写操作时间进程之间的信息交换。</p>
<p>（2）消息传递</p>
<p>进程之间的数据交换，是以格式化的消息为单位，在计算机网络中，又称为报文</p>
<p>（3）管道通信</p>
<p>管道是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件</p>
<ul>
<li>互斥，即当一个进程执行读写操作，其它进程必须等待</li>
<li>同步</li>
</ul>
<h1 id="1-6-线程概念和多线程模型"><a href="#1-6-线程概念和多线程模型" class="headerlink" title="1.6 线程概念和多线程模型"></a>1.6 线程概念和多线程模型</h1><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单元，线程是进程中的一个实体，是被系统独立调度和分配的基本单位</p>
<p>（1）线程和进程的比较</p>
<ol>
<li>调度：线程是独立调度的基本单位，进程是资源拥有的基本单位</li>
<li>拥有资源：进程是拥有资源的基本单位，而线程只拥有必不可少的资源</li>
<li>并发性：进程和线程都有并发性，一个进程间的多个线程可并发</li>
<li>系统开销：线程的开销极小</li>
<li>地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程共享进程的资源</li>
<li>通信方面：进程需要保证数据的一致性，而线程可以直接读写进程数据段来进行通信</li>
</ol>
<p>（2）线程的属性</p>
<ol>
<li>线程是一个轻型实体，只拥有必不可少的资源</li>
<li>不同的线程可以执行相同的程序</li>
<li>同一进程中的各个线程共享该进程所有用的系统资源</li>
<li>线程是处理器的独立调度单位，多个线程是可以并发执行的</li>
<li>一个线程创建后开始了声明周期，直至终止，会经历等待态、就绪态和运行态</li>
</ol>
<p>（3）线程的实现方法</p>
<p>线程的实现可分为两类：用户级线程和内核级线程</p>
<ul>
<li>用户级线程速度快，不用调用核心，但若核心阻塞进程，则进程中所有线程都被阻塞，同一进程中的两个线程不能同时运行于两个处理器上</li>
</ul>
<p>（4）多线程模型</p>
<ol>
<li>多对一模型：多个用户级线程映射到一个内核级线程</li>
<li>一对一模型</li>
<li>多对多模型</li>
</ol>
<h1 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2 线程的调度"></a>2 线程的调度</h1><h2 id="2-1-调度的概念"><a href="#2-1-调度的概念" class="headerlink" title="2.1 调度的概念"></a>2.1 调度的概念</h2><p>作业时用户在一次解题或事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据命令等</p>
<p>一个作业从提交开始直到完成，要经历以下三级调度</p>
<p>1、作业调度</p>
<p>作业调度又称高级调度，按照一定原则挑选一个或多个作业，分配内存、输入输出设备等必要资源，并建立相应的进程</p>
<p>2、中级调度</p>
<p>又称为内存调度，为了提高内存利用率和系统吞吐率</p>
<p>3、进程调度</p>
<p>又称为低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理器分配给它</p>
<h2 id="2-2-调度的时机、切换与过程"><a href="#2-2-调度的时机、切换与过程" class="headerlink" title="2.2 调度的时机、切换与过程"></a>2.2 调度的时机、切换与过程</h2><p>不能进行进程的调度与切换的情况有以下几种</p>
<p>1、处理中断过程中：中断处理是系统工作的一部分，逻辑上不属于某一进程</p>
<p>2、进程在操作系统内存程序临界区中</p>
<p>3、其他需要完全屏蔽中断的院子操作过程：如加锁、解锁、中断现场保护、恢复等</p>
<p>如果在上述过程中引发了调度的条件，并不能马上进行调度和切换，系统请求调度标志，上述过程结束后才能进行相应的调度</p>
<p>应当进行进程调度与切换的情况有</p>
<p>1、当发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换</p>
<p>2、当中断处理结束后或自陷处理结束后</p>
<p>进程切换往往在调度完成后立即发生</p>
<h2 id="2-3-进程调度方式"><a href="#2-3-进程调度方式" class="headerlink" title="2.3 进程调度方式"></a>2.3 进程调度方式</h2><p>1、非剥夺调度方式</p>
<p>非剥夺调度方式又称为非抢占式调度，指一个进程正在处理器上执行，有某个更为重要的进程进入就绪状态，仍然让正在执行进程继续执行，直到该进程完成或发生某种事件进入阻塞状态，才把处理器分配给更为重要的进程</p>
<p>2、剥夺调度方式</p>
<p>又称为抢占方式，若有某个更为重要的进程需要使用处理器，立即暂停正在执行的进程，将处理器分配给这个更为重要或紧迫的进程</p>
<h2 id="2-4-调度的基本原则"><a href="#2-4-调度的基本原则" class="headerlink" title="2.4 调度的基本原则"></a>2.4 调度的基本原则</h2><p>1、CPU利用率</p>
<p>应尽可能使CPU保持在忙状态</p>
<p>2、系统吞吐量</p>
<p>表示单位时间内CPU完成作业的数量</p>
<p>3、周转时间</p>
<p>4、等待时间</p>
<p>5、响应时间</p>
<p>6、具有公平性</p>
<h2 id="2-5-经典的调度算法"><a href="#2-5-经典的调度算法" class="headerlink" title="2.5 经典的调度算法"></a>2.5 经典的调度算法</h2><p>1、FIFS先来先服务/先进先出（FIFO）调度算法：可用于作业调度，也可以用于进程调度</p>
<ul>
<li>有利于长作业，而不利于短作业</li>
<li>有利于CPU繁忙，不利于IO繁忙</li>
<li>适用于批处理</li>
</ul>
<p>2、SJF短作业优先调度算法</p>
<p>选择估计运行时间最短的作业先运行  </p>
<p>3、优先级调度算法</p>
<ul>
<li>静态优先权：默认优先数<ul>
<li>进程的类型</li>
<li>进程对资源的要求</li>
<li>用户要求</li>
</ul>
</li>
<li>动态优先权<ul>
<li>岁等待时间的增加而改变</li>
</ul>
</li>
</ul>
<p>4、高响应比优先调度算法</p>
<p>是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</p>
<p>优先权=（等待时间+要求服务时间）/ 要求服务时间</p>
<p>对短作业、等待时间越长越有利</p>
<p>5、时间轮片调度算法</p>
<p>6、多级反馈队列调度算法</p>
<h1 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3 进程同步"></a>3 进程同步</h1><h2 id="3-1-进程同步的基本概念"><a href="#3-1-进程同步的基本概念" class="headerlink" title="3.1 进程同步的基本概念"></a>3.1 进程同步的基本概念</h2><p>进程是并发进行的，不同进程存在不同的相互制约关系，为了避免进程之间的冲突，引入进程同步的概念</p>
<p>1、临界资源</p>
<p>一次只允许一个进程使用的资源称为邻接资源，对邻接资源的访问，必须互斥的进行</p>
<p>把临界资源的访问过程分为四个部分</p>
<ol>
<li>进入区</li>
<li>临界区</li>
<li>退出区</li>
<li>剩余区</li>
</ol>
<p>2、同步</p>
<p>为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置协调他们的工作次序而等待，传递信息所产生的制约关系，进程间的直接制约关系就是他们之间的相互合作</p>
<p>遵循的原则：</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待：对要求访问临界资源的进程，应保证在有限时间内进入自己的临界区，防止“死等”</li>
<li>让权等待：进程不能进入自己临界区时，应立即释放处理机制，防止“忙等”</li>
</ul>
<p>3、互斥</p>
<p>互斥称为间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待</p>
<h2 id="3-2-实现临界区互斥的基本方法"><a href="#3-2-实现临界区互斥的基本方法" class="headerlink" title="3.2 实现临界区互斥的基本方法"></a>3.2 实现临界区互斥的基本方法</h2><p>1、硬件实现方法</p>
<ol>
<li><p>中断屏蔽法</p>
</li>
<li><p>硬件指令法（TS）</p>
</li>
</ol>
<h2 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h2><p>1、整型信号量</p>
<p>被定义为一个用于表示资源个数的整型量</p>
<p>2、记录型号量</p>
<p>P(S)和V(S)操作可描述为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P(semaphore S)&#123;</span><br><span class="line">	S.value&#x3D;S.vauel-1; ##请求一个资源</span><br><span class="line">		if(S.value&lt;0) Block(S.L) # 自我阻塞，插入到信号链表S.L中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore S)&#123;</span><br><span class="line">	S.value +&#x3D;1</span><br><span class="line">	if(S.value&lt;&#x3D;0) wakeup(S.L); # 有进程被阻塞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、利用信号量实现同步</p>
<p>4、利用信号量实现互斥</p>
<p>5、利用信号量实现前驱关系</p>
<h2 id="3-4-管程"><a href="#3-4-管程" class="headerlink" title="3.4 管程"></a>3.4 管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据</p>
<p>管程由三部分组成：</p>
<ul>
<li>局部于管程的共享变量说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部管程的数据设置初始值语句</li>
<li>管程还必须有一个名字</li>
</ul>
<p>在实现管程，必须考虑</p>
<ol>
<li>互斥：通常编译程序对每个管程自动产生一个互斥信号量，每次只准许一个进程进入管程，其他调用管程者必须等待</li>
<li>同步：当某进程通过管程请求临界资源而不能满足时，管程便调用wait原语使用该进程等待，并将它排在等待队列上</li>
</ol>
<h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4 死锁"></a>4 死锁</h1><h2 id="4-1-死锁的概念"><a href="#4-1-死锁的概念" class="headerlink" title="4.1 死锁的概念"></a>4.1 死锁的概念</h2><p>多个进程因竞争资源造成的一种僵局，若无外力作用，这些进程都将无法向前推进</p>
<p>1、系统资源的竞争</p>
<p>2、进程推进顺序非法</p>
<p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁</p>
<p>3、死锁产生的必要条件</p>
<ol>
<li><p>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程占用</p>
</li>
<li><p>不剥夺条件：进程所获得的资源在未使用完毕前，不能被其它进程强行夺走</p>
</li>
<li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p>
</li>
<li><p>循环等待条件：存在一种进程循环等待链</p>
</li>
</ol>
<ul>
<li>参与死锁的进程最少是两个</li>
<li>至少有两个已经占有资源</li>
<li>死锁所有进程都在等待资源</li>
<li>参与死锁的进程是当前系统中所有进程的子集</li>
</ul>
<h2 id="4-2-死锁处理策略"><a href="#4-2-死锁处理策略" class="headerlink" title="4.2 死锁处理策略"></a>4.2 死锁处理策略</h2><p>1、破坏死锁的四个必要条件之一</p>
<p>2、用某种方式防止系统进入不安全状态</p>
<p>3、允许进程在运行过程中发生死锁，通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁</p>
<p><strong>死锁预防</strong></p>
<ul>
<li>摒弃请求和保持条件：所有进程必须一次性的申请整个运行过程所需的全部资源</li>
<li>摒弃不可剥夺条件：进程逐个申请所需资源，但是申请新资源不能得到满足时，必须放弃自己所保持的资源</li>
<li>摒弃环路等待：将资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序</li>
</ul>
<p><strong>死锁避免</strong></p>
<p>在避免死锁的方法，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性</p>
<p>所谓安全状态，是指系统能按某种进程顺序来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，如果系统无法找到这样一个安全序列，则称系统处于不安全状态</p>
<p>可以用银行家算法检测安全状态</p>
<p><strong>死锁检测</strong></p>
<ul>
<li>死锁定理：某一时刻系统状态S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全化简的，此充分条件称为死锁定理</li>
</ul>
<p><strong>死锁解除</strong></p>
<p>死锁解除的主要方法有</p>
<ol>
<li>资源剥夺法：挂起某些死锁进程，抢占其资源，将这些资源分配给其他死锁进程</li>
<li>进程撤销法：强制撤销一个或一部分进程并剥夺这些进程的资源</li>
<li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺</li>
</ol>
<hr>
<h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-进程和线程的区别"><a href="#5-1-进程和线程的区别" class="headerlink" title="5.1 进程和线程的区别"></a>5.1 进程和线程的区别</h2><p>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，而进程正相反</p>
<h2 id="5-2-进程有哪几种状态"><a href="#5-2-进程有哪几种状态" class="headerlink" title="5.2 进程有哪几种状态"></a>5.2 进程有哪几种状态</h2><ul>
<li>创建状态：进程正在被创建，尚未到就绪状态</li>
<li>就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行</li>
<li>运行状态：进程正在处理器上运行（单核CPU下任意时刻只有一个进程处于运行状态）</li>
<li>阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成，即使处理器空闲，该进程也不能运行</li>
<li>结束状态：进程正在从系统中消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<h2 id="5-3-进程间的通信方式"><a href="#5-3-进程间的通信方式" class="headerlink" title="5.3 进程间的通信方式"></a>5.3 进程间的通信方式</h2><ol>
<li>管道/匿名管道：用于具有亲缘关系的父子进程或兄弟进程之间的通信</li>
<li>有名管道：有名管道严格遵循先进先出，以磁盘文件的方式存在，可以实现本机任意两个进程通信</li>
<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列克服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>信号量：信号量是一个计数器，用于多线程对共享数据的访问，信号量的意图在于进程间同步，这种通信方式主要用于解决与同步相关的问题并避免竞争条件</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量，可以说是最有用的进程间通信方式</li>
<li>套接字：此方法主要用于客户端和服务器之间的网络通信</li>
</ol>
<h2 id="5-4-线程间的同步方式"><a href="#5-4-线程间的同步方式" class="headerlink" title="5.4 线程间的同步方式"></a>5.4 线程间的同步方式</h2><p>线程同步是两个或多个共享关键资源的线程的并发执行，同步线程以避免关键资源使用冲突</p>
<ol>
<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限</li>
<li>信号量：允许统一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li>时间：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先极的比较</li>
</ol>
<h2 id="5-5-进程的调度算法"><a href="#5-5-进程的调度算法" class="headerlink" title="5.5 进程的调度算法"></a>5.5 进程的调度算法</h2><ul>
<li>先到先服务：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某时间而被阻塞放弃占用CPU时再重新调度</li>
<li>短作业优先调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源</li>
<li>时间片轮转调度算法：每个进程被分配一段时间</li>
<li>优先极调度：为每个流程分配优先级</li>
<li>高响应比优先调度算法：是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</li>
<li>多级反馈队列调度算法：即能使高优先级的作业得到响应，又能使短作业迅速完成</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结（五）：输入输出管理</title>
    <url>/2020/08/28/os5/</url>
    <content><![CDATA[<h1 id="1-IO管理概述"><a href="#1-IO管理概述" class="headerlink" title="1 IO管理概述"></a>1 IO管理概述</h1><h2 id="1-1-IO设备"><a href="#1-1-IO设备" class="headerlink" title="1.1 IO设备"></a>1.1 IO设备</h2><p>IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。</p>
<a id="more"></a>

<p>计算机系统中的IO设备按使用特性可以分为一下类型：</p>
<ol>
<li><p>人机交互类外部设备，又称慢速IO设备，用于桶计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。</p>
</li>
<li><p>存储设备，用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。</p>
</li>
<li><p>网络通信设备，用于与远程设备通信的设备，如各种网络接口、调制解调器等。其数据交换速度介于外部设备与存储设备之间。网络通信设备在使用和管理上与前两者设备有很大的不同。</p>
</li>
</ol>
<h2 id="1-2-IO管理目标"><a href="#1-2-IO管理目标" class="headerlink" title="1.2 IO管理目标"></a>1.2 IO管理目标</h2><p>IO设备管理的主要目标有以下三个方面。</p>
<p>方便使用：方便用户使用外部设备，控制设备工作完成用户的输入输出要求。</p>
<p>提高效率：提高系统的并行工作能力，提高设备的使用效率。</p>
<p>方便控制：提高外围设备和系统的可靠性和安全性，以使系统能正常工作。</p>
<h2 id="1-3-IO管理功能"><a href="#1-3-IO管理功能" class="headerlink" title="1.3 IO管理功能"></a>1.3 IO管理功能</h2><p>IO设备管理的功能是按照输入输出子系统的结构和设备类型制定分配和使用设备的策略，主要包括：</p>
<p>设备的分配和回收。</p>
<p>外围设备的启动。</p>
<p>对磁盘的驱动调度。</p>
<p>外部设备中断处理。</p>
<p>虚拟设备的实现。</p>
<h2 id="1-4-IO应用接口"><a href="#1-4-IO应用接口" class="headerlink" title="1.4 IO应用接口"></a>1.4 IO应用接口</h2><p>划分IO设备所属的通用类型的依据：</p>
<ul>
<li><p>字符设备还是块设备。</p>
</li>
<li><p>顺序访问还是随机访问。</p>
</li>
<li><p>IO传输是同步还是异步。</p>
</li>
<li><p>共享设备还是独占设备。</p>
</li>
<li><p>操作速度的高低。</p>
</li>
<li><p>访问模式是读写、只读还是只写。</p>
</li>
</ul>
<h2 id="1-5-设备控制器"><a href="#1-5-设备控制器" class="headerlink" title="1.5 设备控制器"></a>1.5 设备控制器</h2><p>设备控制器的主要功能为：</p>
<ul>
<li><p>接收和识别CPU或通道发来的命令，如磁盘控制器能就收读、写、查找、搜索等命令。</p>
</li>
<li><p>实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。</p>
</li>
<li><p>发现和记录设备及自身的状态信息，供CPU处理使用。</p>
</li>
<li><p>设备地址识别。</p>
</li>
</ul>
<h2 id="1-6-IO控制方式"><a href="#1-6-IO控制方式" class="headerlink" title="1.6 IO控制方式"></a>1.6 IO控制方式</h2><p>中断驱动方式中，CPU仍然需要主动处理在存储器和IO设备之间的数据传送，所以速度还是受限，而直接内存存取（DMA）方式的基本思想是在外围设备和内存之间开辟直接的数据交换通路，彻底解放CPU。该方式的特点是：</p>
<ul>
<li><p>基本单位是数据块。</p>
</li>
<li><p>所传诵的数据，是从设备直接送入内存的，或者相反。</p>
</li>
<li><p>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p>
</li>
</ul>
<p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p>
<ul>
<li><p>命令/状态寄存器（CR）。用于接收从CPU发来的IO命令或有关控制信息，或设备的状态。</p>
</li>
<li><p>内存地址寄存器（MAR）。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</p>
</li>
<li><p>数据寄存器（DR）。用于暂存从设备到内存或从内存到设备的数据。</p>
</li>
<li><p>数据计数器（DC）。存放本次CPU要读或写的字节数。</p>
</li>
</ul>
<p>DMA的工作过程是：CPU读写数据时，他给IO控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把这个操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此，只有在传送开始和结束时才需要CPU的参与。</p>
<h1 id="2-IO核心子系统"><a href="#2-IO核心子系统" class="headerlink" title="2 IO核心子系统"></a>2 IO核心子系统</h1><h2 id="2-1-IO层次结构"><a href="#2-1-IO层次结构" class="headerlink" title="2.1 IO层次结构"></a>2.1 IO层次结构</h2><p>一个比较合理的层次划分为四个层次的系统结构，各层次及其功能如下：</p>
<ol>
<li><p>用户层IO软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与IO操作有关的库函数，对设备进行操作。</p>
</li>
<li><p>设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p>
</li>
<li><p>设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。</p>
</li>
<li><p>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并回复被中断进程的现场后，返回到被中断进程。</p>
</li>
</ol>
<h2 id="2-2-IO调度概念"><a href="#2-2-IO调度概念" class="headerlink" title="2.2 IO调度概念"></a>2.2 IO调度概念</h2><p>调度一组IO请求就是确定确定一个好的顺序来执行这些请求。应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要调度来改善系统整体性能，是进程之间公平的共享设备访问，减少IO完成所需要的平均等待时间。</p>
<p>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞IO系统调用时，该请求就加到相应设备的队列上。IO调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。</p>
<p>IO子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等。</p>
<h2 id="2-3-高速缓存与缓冲区"><a href="#2-3-高速缓存与缓冲区" class="headerlink" title="2.3 高速缓存与缓冲区"></a>2.3 高速缓存与缓冲区</h2><p>在设备管理子系统中，引入缓冲区的目的有：</p>
<ol>
<li><p>缓和CPU与IO 设备间速度不匹配的矛盾。</p>
</li>
<li><p>减少对CPU的中断频率，放宽对CPU 中断响应时间的限制。</p>
</li>
<li><p>解决基本数据单元大小不匹配的问题。</p>
</li>
<li><p>提高CPU和IO设备之间的并行性。</p>
</li>
</ol>
<h2 id="2-4-设备的分配与回收"><a href="#2-4-设备的分配与回收" class="headerlink" title="2.4 设备的分配与回收"></a>2.4 设备的分配与回收</h2><p>设备分配的基本任务是根据用户的IO请求，为他们分配所需的设备。设备分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类。</p>
<h2 id="2-5-假脱机技术"><a href="#2-5-假脱机技术" class="headerlink" title="2.5 假脱机技术"></a>2.5 假脱机技术</h2><p>为了缓和CPU的高速型与IO设备低速性之间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速IO设备上的数据传送到高速磁盘上；或者相反。SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结（三）：内存管理</title>
    <url>/2020/08/28/os3/</url>
    <content><![CDATA[<h1 id="1-内存管理基础"><a href="#1-内存管理基础" class="headerlink" title="1 内存管理基础"></a>1 内存管理基础</h1><h2 id="1-1-内存管理的概念"><a href="#1-1-内存管理的概念" class="headerlink" title="1.1 内存管理的概念"></a>1.1 内存管理的概念</h2><p>内存管理是操作系统设计中最重要和做复杂的内容之一，内存管理的功能有：</p>
<ol>
<li>内存空间的分配与回收，包括分配与共享</li>
<li>地址转换，把逻辑地址转换成相应的物理地址</li>
<li>内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存</li>
<li>内存保护，保证各道作业在各自存储空间内运行，互不干扰</li>
</ol>
<a id="more"></a>

<p>创建进程首先要将程序和数据装入内存，将用户原程序编程可在内存中执行的程序，通常需要以下几个步骤</p>
<ol>
<li>编译，由编译程序将用户源代码编译成若干个目标模块</li>
<li>链接，由链接程序将编译后形成一组目标模块</li>
<li>装入，由装入程序将装入模块装入内存</li>
</ol>
<p>程序的连接有以下三种方式</p>
<ol>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完成的可执行程序，以后不再拆开</li>
<li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，再装入内存时，采用边装入边链接方式</li>
<li>运行时动态链接：对某些目标模块的连接，是在程序执行中需要该目标模块时，才进行链接，其优点是便于修改和更新</li>
</ol>
<p>装入内存时，同样有以下三种方式：</p>
<ol>
<li>绝对装入：在编译时，产生绝对地址的目标代码</li>
<li>可重定位装入：在多道程序环境下，多个目标目标的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的</li>
<li>动态运行时装入：程序在内存中发生移动，需要采用动态装入方式</li>
</ol>
<h2 id="1-2-覆盖与交换"><a href="#1-2-覆盖与交换" class="headerlink" title="1.2 覆盖与交换"></a>1.2 覆盖与交换</h2><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法</p>
<p>覆盖的基本思想：</p>
<p>由于程序运行时并非任何时候都要访问程序和数据的各个部分，因此可以把用户控件分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定区，其余部分按照调用关系分段</p>
<p>交换的基本思想：</p>
<p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的进程从内存移到辅存，把内存空间腾出来，把准备好竞争CPU运行的进程从辅存移到内存</p>
<p>有关交换需要注意以下问题：</p>
<ul>
<li>交换需要备份存储</li>
<li>为了有效使用CPU，需要每个进程的执行时间比交换时间长</li>
<li>如果换出进程，必须确保该进程是完全处于空闲状态</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统</li>
<li>交换通常有许多进程运行且内存空间吃紧的时候开始启动</li>
<li>普通的交换使用不多，但交换策略的某些变种在许多系统中仍发挥作用</li>
</ul>
<h2 id="1-3-连续分配管理方式"><a href="#1-3-连续分配管理方式" class="headerlink" title="1.3 连续分配管理方式"></a>1.3 连续分配管理方式</h2><p>连续分配，是指为一个用户程序分配一个连续的内存空间，主要包括单一连续分配、固定分区分配和动态分区分配</p>
<p>内存在此方式下分为系统区和用户区</p>
<p>固定分区分配是最简单的一种多道程序储存管理方式，将内存划分为若干个固定大小的区域，每个分区只装入一道作业</p>
<p>固定分区分配在划分分区时，有两种不同的方法</p>
<ol>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ol>
<p>固定分区不能实现多进程共享一个主存区，空间利用率低</p>
<p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好合适进程的需要，但是随着时间的推移，内存中会产生越来越多的碎片</p>
<p>动态分区的分配策略，可以考虑以下几种算法：</p>
<ol>
<li>首次适应算法：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区</li>
<li>最佳适应算法：空闲分区按容量递增形成分区连，找到第一个能满足要求的空闲分区</li>
<li>最坏适应算法：空闲分区以容量递减次序链接，找到第一个能满足要求的空闲分区</li>
<li>临近适应算法：由首次适应算法演变而成，不同之处是分配内存时从查找结束的位置开始继续查找</li>
</ol>
<h2 id="1-4-非连续分配管理方式"><a href="#1-4-非连续分配管理方式" class="headerlink" title="1.4 非连续分配管理方式"></a>1.4 非连续分配管理方式</h2><p>非连续分配允许一个程序分散的装入不相邻的内存分区中，根据分区的大小是否固定为分页存储管理方式和分段存储管理方式</p>
<p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本页存储管理和请求页存储管理方式</p>
<p>1、分页存储的几个基本概念</p>
<ul>
<li>页面和页面大小：进程中的块称为页，内存中的块称为页框。外存也以同样单位划分，直接称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</li>
<li>地质结构：分页存储管理的地质结构包含两部分：前一部分为页号，后一部分为页内偏移量</li>
<li>页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</li>
</ul>
<p>2、基本地质变换机构</p>
<p>将逻辑地址中的页号，转换为内存中物理块号，地址变换是借助于页表实现的</p>
<p>逻辑地址到物理地址的变换过程如下：</p>
<ol>
<li>地址变换机构自动将有效地址分为页号和页内偏移量两部分，再用页号去检索页表，在执行检索之前，现将页号与页表长度比较，如果页号大于或等于页表长度，则表示地址越界并中断</li>
<li>若未越界，则将页表始址和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号</li>
<li>与此同时，将有效地址中的页内偏移量送入物理地址寄存器的块内地址字段中</li>
</ol>
<p>3、具有块表的地址变换机构</p>
<ol>
<li>CPU给出有效地址后，由硬件进行地址转换，并将页号送入高速缓存寄存器，并将此页号与快表的所有页号同时进行比较</li>
<li>如果有找到匹配的页号，说明要访问的页表项在快表中，则可以直接从中读出该页对应的页框号，送到物理地址寄存器</li>
<li>如果没有找到，则需要访问主存中的页表，在读出页表项后，同时将其存入快表中，以供后面可能的再次访问</li>
</ol>
<p>4、两级页表</p>
<p>由于引入了分页管理，进程在执行时不需要将所有页调入内存框中，而只要将保存有映射关系的页表调入内存即可</p>
<h1 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2 虚拟内存"></a>2 虚拟内存</h1><h2 id="2-1-虚拟内存的基本概念"><a href="#2-1-虚拟内存的基本概念" class="headerlink" title="2.1 虚拟内存的基本概念"></a>2.1 虚拟内存的基本概念</h2><p>内存管理策略有两个共同特质：</p>
<ol>
<li>一次性：作业必须一次全部装入内存后，方可运行</li>
<li>驻留性：作业被装入内存后，就一直驻留在内存中</li>
</ol>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><p>时间局部性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p>
</li>
<li><p>空间局部性。一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p>
</li>
</ol>
<p>时间局部性是通过将进来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。</p>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行，这样，计算机好像为用户提供了一个比实际内存大得多的储存器，称为虚拟储存器，主要有以下三个主要特征：</p>
<ol>
<li>多次性：无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行</li>
<li>对换性：无需作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出</li>
<li>虚拟性：逻辑上扩充内存的容量</li>
</ol>
<p>虚拟内存建立在离散分配的内存管理方式的基础上，有以下三种方式</p>
<ol>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ol>
<p>不管哪种方式，都需要有一定的硬件支持</p>
<ol>
<li>一定的内存和外存</li>
<li>页表机制或段表机制</li>
<li>中断机构</li>
<li>地址变换机构</li>
</ol>
<h2 id="2-2-请求分页管理方式"><a href="#2-2-请求分页管理方式" class="headerlink" title="2.2 请求分页管理方式"></a>2.2 请求分页管理方式</h2><p>请求分页系统建立在基本分页系统基础上，为了支持寻你存储器功能而增肌阿勒请求分页功能和页面置换功能</p>
<h2 id="2-3-页面置换算法"><a href="#2-3-页面置换算法" class="headerlink" title="2.3 页面置换算法"></a>2.3 页面置换算法</h2><p>进程运行时，若访问的页面不在内存，需要将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘兑换区，常见的置换算法有以下四种：</p>
<ol>
<li>最佳置换算法</li>
<li>先进先出页面置换算法</li>
<li>最近最久未使用置换算法</li>
<li>最少使用置换算法</li>
</ol>
<h2 id="2-4-页面分配策略"><a href="#2-4-页面分配策略" class="headerlink" title="2.4 页面分配策略"></a>2.4 页面分配策略</h2><p>给特定的进程分配多大的主存空间，需要考虑以下几点：</p>
<ol>
<li>分配给一个进程的存储量越小，在任何时候驻留在主存的进程数越多，可以提高处理器的时间利用率</li>
<li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高</li>
<li>如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</li>
</ol>
<p>基于这些因素，现代操作系统通常采用三种策略：</p>
<ol>
<li>固定分配局部置换：它为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发现缺页，则只能从该进程在内存的页面中选出一个换出，然后再调入需要的页面。</li>
<li>可变分配全局置换：这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数量的物理块，操作系统自身也保持一个空闲物理块队列。当某进程发现缺页时，系统从空闲物理块队列中取出物理块分配给该进程，并将于调入的页装入其中。</li>
<li>可变分配局部置换：它为每个进程分配一定数目的物理块，当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁的换页，系统需再为该进程分配若干附加物理块，直至该进程缺页率趋于适当程度为止；反之，若一个进程在运行过程中缺页率特别低，则此时可适当减少该进程的物理块。</li>
</ol>
<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：</p>
<ol>
<li>预调页策略：根据局部性原理，一次调入若干个相邻的页可能比一次调入一页更高效。但如果调入的一批页面中大厦多数都未被访问，则又是低效的。所以就需要采用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。股这种策略主要用于进程的首次调入时，有程序员指出应该先调入哪些页。</li>
<li>请求调页策略：进程在运行中需要访问的页面不在内存而提出的请求，由系统将所需页面调入内存。这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。它的缺点在于每次调入一页，会花费过多的IO开销。</li>
<li>从何处调入页面。请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘IO速度比文件区高。这里从何处调入页面有三种情况</li>
</ol>
<h2 id="2-5-抖动和工作集"><a href="#2-5-抖动和工作集" class="headerlink" title="2.5 抖动和工作集"></a>2.5 抖动和工作集</h2><p>在进程的页面置换过程中，频繁的页面调度行为成为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p>
<p>使用虚拟内存技术，操作系统中进程通常只有一部分块位于主存中，从而可以在内存中保留更多的进程以提高系统效率。此外，由于未用到的块不需要换入换出内存，因为节省了时间。但是系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被禁成块占据，处理器和操作系统可以直接访问到尽可能多的进程。但如果管理不当，系统发生抖动现象，处理器的大部分时间都将用于交换快，及请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。前面讲解的页面置换算法就是是讨论这里的分配方案，尽量避免抖动现象。</p>
<p>另外，为了防止出现抖动现象，需要选择合适的驻留集大小。驻留集（或工作集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。驻留集模型使用较为简单：操作系统跟踪每个进程的驻留集，并为进程分配大于驻留集的的空间。如果还有空闲，那么可启动另一个进程。如果所有驻留集之和增加一直超过了可用物理块啊的总数，那么系统会怎听一个进程，将其页面调出并且将其物理块分配给其他进程。</p>
<p>正确选择驻留集的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。</p>
<h2 id="2-6-请求分段管理方式"><a href="#2-6-请求分段管理方式" class="headerlink" title="2.6 请求分段管理方式"></a>2.6 请求分段管理方式</h2><p>请求分段存储管理系统已基本短时存储管理为基础，为用户提供一个比主存容量更大的虚拟存储器。作业的若干分段别放入内存，就可以开始作业运行，作业的其他部分被放在外存中，等到需要的时候才被调入内存。</p>
<h2 id="2-7-请求段页式管理方式"><a href="#2-7-请求段页式管理方式" class="headerlink" title="2.7 请求段页式管理方式"></a>2.7 请求段页式管理方式</h2><p>请求段页式管理方式只要求将作业若干页或段装入内存就可以开始运行作业，作业的其他部分别放在外存中，等待运行需要的时候才被调入内存，</p>
<p>请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结（一）：操作系统概述</title>
    <url>/2020/08/27/os/</url>
    <content><![CDATA[<h1 id="1-操作系统的概念、特征、功能和提供的服务"><a href="#1-操作系统的概念、特征、功能和提供的服务" class="headerlink" title="1 操作系统的概念、特征、功能和提供的服务"></a>1 操作系统的概念、特征、功能和提供的服务</h1><h2 id="1-1-操作系统的概念"><a href="#1-1-操作系统的概念" class="headerlink" title="1.1 操作系统的概念"></a>1.1 操作系统的概念</h2><p>操作系统的目标</p>
<ol>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ol>
<a id="more"></a>

<h2 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h2><p>（1）并发</p>
<p>并行性和并发性是即详细又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个时间在同一时间间隔内发生</p>
<p>在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的实施程序能并发执行。</p>
<p>（2）共享</p>
<p>指系统中的可供内存中多个并发执行的进程（线程）共同使用</p>
<p>1、互斥共享方式</p>
<p>系统中的某些资源，如打印机、磁带机，虽然他们可以提供给多个进程使用，但为使所打印的内容不致造成混淆，应规定在同一段时间内只允许一个进程方位该资源。</p>
<p>2、同时访问方式</p>
<p>系统中还有一种资源，允许在一段时间内由多个进程“同时”对它进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问即“分时共享”。典型的可供多个进程同时访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<p>（3）虚报</p>
<p>通过某种技术把一个物理实体变为若干个逻辑上的对应物，物理实体是实的，后者是虚的，用于实现虚拟的技术称为虚拟技术，利用时分复用和控分复用技术实现</p>
<p>（4）异步</p>
<p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<h2 id="1-3-操作系统的功能"><a href="#1-3-操作系统的功能" class="headerlink" title="1.3 操作系统的功能"></a>1.3 操作系统的功能</h2><p>（1）处理机管理功能</p>
<ol>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度<ul>
<li>作业调度</li>
<li>进程调度</li>
</ul>
</li>
</ol>
<p>（2）存储器管理功能</p>
<ol>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ol>
<p>（3）设备管理功能</p>
<ol>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ol>
<p>（4）文件管理功能</p>
<ol>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件读/写管理和保护</li>
</ol>
<h2 id="1-4-操作系统所能提供的服务"><a href="#1-4-操作系统所能提供的服务" class="headerlink" title="1.4 操作系统所能提供的服务"></a>1.4 操作系统所能提供的服务</h2><p>（1）OS作为用户与计算机硬件系统之间的接口</p>
<p>（2）OS作为计算机系统资源的管理者</p>
<p>硬件和软件资源分为四类：处理机、存储器、I/O设备和文件，OS的主要功能是对这类资源进行有效的管理</p>
<p>（3）实现了对计算机资源的抽象</p>
<h1 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2 操作系统的发展与分类"></a>2 操作系统的发展与分类</h1><h2 id="2-1-操作系统的发展"><a href="#2-1-操作系统的发展" class="headerlink" title="2.1 操作系统的发展"></a>2.1 操作系统的发展</h2><p>（1）未配置操作系统的计算机系统</p>
<p>（2）单道批处理系统</p>
<p>（3）多道批处理系统</p>
<p>（4）分时系统</p>
<p>（5）实时系统</p>
<h1 id="3-操作系统的运行环境"><a href="#3-操作系统的运行环境" class="headerlink" title="3 操作系统的运行环境"></a>3 操作系统的运行环境</h1><h2 id="3-1-内核态与用户态"><a href="#3-1-内核态与用户态" class="headerlink" title="3.1 内核态与用户态"></a>3.1 内核态与用户态</h2><p>特权指令：有少数指令是为编制系统管理程序专门设置的，只有操作系统才能使用</p>
<ol>
<li>有关I/0的指令</li>
<li>访问程序状态字寄存器的指令</li>
<li>存取特殊寄存器指令</li>
<li>其他访问系统状态和直接访问系统资源的指令</li>
</ol>
<p>多数系统将处理器工作状态划分为内核态和用户态，前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为特权太、系统太或管态；后者一般指用户程序运行时的状态，具有较低的特权级别，又称普通态、目态</p>
<p>目态：程序执行时不可使用特权指令</p>
<p>管态：可以使用特权指令</p>
<h2 id="3-2-中断、异常"><a href="#3-2-中断、异常" class="headerlink" title="3.2 中断、异常"></a>3.2 中断、异常</h2><p>中断是由与现指令无关的中断信号触发的，且中断的发生与CPU处在用户模型或内核模式无关，在两条机器指令之间才可相应中断</p>
<p>异常处理程序提供的服务是为当前进程所用的</p>
<h2 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h2><p>当系统调用发生时，处理器通过一种特殊的机制，通常是中断或者异常处理，把控制流程序转移到监控程序内的一些特定的位置。</p>
<h1 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4 操作系统体系结构"></a>4 操作系统体系结构</h1><ol>
<li>无结构操作系统</li>
<li>模块化结构OS</li>
<li>分层式结构OS</li>
<li>微内核OS结构</li>
</ol>
<hr>
<h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-什么是操作系统？"><a href="#5-1-什么是操作系统？" class="headerlink" title="5.1 什么是操作系统？"></a>5.1 什么是操作系统？</h2><ol>
<li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石</li>
<li>操作系统本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源</li>
<li>操作系统存在屏蔽了硬件的复杂性</li>
<li>操作系统的内核是操作系统的核心部分，它负责内存管理，硬件设备的管理，文件管理以及应用程序的管理</li>
</ol>
<h2 id="5-2-系统调用"><a href="#5-2-系统调用" class="headerlink" title="5.2 系统调用"></a>5.2 系统调用</h2><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态：用户态运行的进程或可以直接读取用户程序的数据</li>
<li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</li>
</ol>
<p>在运行用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等）都必须经过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p>
<p>按系统调用功能大致可以分为如下几类：</p>
<ol>
<li>设备管理：完成设备请求或释放，以及设备启动等功能</li>
<li>文件管理：完成文件的读、写、创建以及删除等功能</li>
<li>进程控制：完成进程的创建、撤销、阻塞、唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能</li>
<li>内存管理：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（一）决策树</title>
    <url>/2020/07/15/tree/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="1-决策树原理"><a href="#1-决策树原理" class="headerlink" title="1 决策树原理"></a>1 决策树原理</h2><h3 id="1-1-决策树是如何工作的"><a href="#1-1-决策树是如何工作的" class="headerlink" title="1.1 决策树是如何工作的"></a>1.1 决策树是如何工作的</h3><p>决策树（Decision Tree）是一种非常参数的有监督学习方法，它能够从一系列有特征和标签的数据中总结出决策规则，并用树状图的结构来呈现这些规则，以解决分类和回归问题。决策树算法容易理解，适用各种数据，在解决各种问题时都有良好表现，尤其是以树模型为核心的各种集成算法，在各个行业和领域都有广泛的应用。</p>
<a id="more"></a>

<p><strong>决策树算法的核心是要解决两个问题：</strong><br>1）如何从数据表中找出最佳结点和最佳分枝<br>2）如何让决策树停止生长，防止过拟合？</p>
<p>几乎所有决策树有关的模型调整方法，都围绕这两个问题展开。</p>
<h3 id="1-2-构建决策树"><a href="#1-2-构建决策树" class="headerlink" title="1.2 构建决策树"></a>1.2 构建决策树</h3><p>原则上讲，任意一个数据集上的所有特征都可以被拿来分枝，特征上的任意结点又可以自由组合，所以一个数据集上可以发展处非常多测决策树，其数量可达指数级。但在这些树中，总有那么一棵树比其他的树分类效力都好，那样的树叫做“全局最优树”。</p>
<table>
<thead>
<tr>
<th align="left">关键概念：全局最优，局部最优</th>
</tr>
</thead>
<tbody><tr>
<td align="left">全局最优：经过组合形成的，整体来说分类效果最好的模型</td>
</tr>
<tr>
<td align="left">局部最优：每一次分枝的时候都向着更好的分类效果分枝，但无法确认如此生成的树在全局上是否是最优的</td>
</tr>
</tbody></table>
<p>要在这么多决策树中去一次性找到分类效果最佳的那一棵是不可能的，如果通过排列组合来进行筛选，计算量过于大而低效。<br>因此，机器学习研究者们开发了一些有效的算法，能够在合理的时间内构造出具有一定准确率的次最优决策树。这些算法基本都执行“贪心策略”，即通过局部最优来达到接近全局最优的结果</p>
<table>
<thead>
<tr>
<th align="left">关键概念：贪心算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">通过实现局部最优来达到接近全局最优结果的算法，所有的树模型都是这样的算法</td>
</tr>
</tbody></table>
<h3 id="1-2-1-ID3算法构建决策树"><a href="#1-2-1-ID3算法构建决策树" class="headerlink" title="1.2.1 ID3算法构建决策树"></a>1.2.1 ID3算法构建决策树</h3><p>ID3算法原型为J.R Quinlan的博士论文，是基础理论较为完善，使用较为广泛的决策树模型，并在此基础上优化退出了C4.5和C5.0决策树算法，后两者已经成为最流行的决策树算法。</p>
<p>决策树需要找出最佳节点和最佳的分枝方法，而衡量这个“最佳”的指标叫做“不纯度”。<br>不纯度基于叶子节点来计算的，所以树中的每个节点都会有一个不纯度，并且子节点的不纯度一定是低于父节点的。</p>
<table>
<thead>
<tr>
<th align="left">关键概念：不纯度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">如果有某一类标签占有较大的比例，我们就说叶子节点“纯”，分枝分得好。若各类标签都很平均，则说明叶子节点“不纯”</td>
</tr>
</tbody></table>
<h4 id="怎样计算不纯度？"><a href="#怎样计算不纯度？" class="headerlink" title="怎样计算不纯度？"></a>怎样计算不纯度？</h4><p>对于节点不纯度的计算和表示方法因决策树模型而异，但不管不纯度的度量方法如何，都是由误差率衍生而来，其计算公式如下：<br>$$Classification error(t) = 1-\max_{i=1}[p(i|t)]$$</p>
<p>误差率越低，则纯度越高。由此还衍生出了其他两个常用指标，一个是ID3重的Information gain（信息增益）的计算方法可用Entropy推导，即最为人熟知的信息熵，又叫香农熵，其计算公式如下：<br>$$Entropy(t)=-\sum^{c-1}_{i=0}p(i|t)\log_2p(i|t)$$</p>
<p>其中c表示叶子节点上标签类别的个数，c-1表示标签的索引</p>
<p><strong>从第0类标签开始计算，设定$\log_20=0$</strong></p>
<p>另一个指标则是<strong>Gini（基尼）指数</strong>，主要用于CART决策树的纯度判定中，其计算公式如下：<br>$$Gini = 1-\sum_{i=0}^{c-1}[p(i|t)]^2$$</p>
<p>决策树最终的优化目标是使得叶节点的总不纯度最低。因此ID3决策树在觉得是否对某节点进性切分的时候，会尽可能选取使得该节点对应的子节点信息熵最小的特征进行切分，换而言之，就是要求父节点信息熵和子节点总信息熵之差要最大，对ID3而言，二者之差就是信息增益。</p>
<p><strong>一个父节点下可能有多个子节点，所以信息增益为父节点信息熵-所有子节点信息熵的加权平均</strong></p>
<p>$$I(child) = \sum_{j=1}^k\frac{N(v_j)}{N}I(v_j)$$</p>
<p>而父节点和子节点的不纯度下降数可由下属公式进行计算：<br>$$\Delta = I(parent)-I(child)$$</p>
<p>$I(.)$是给定节点的不纯性度量，$N$是父节点上的样本树，$k$是这一层上子节点的个数，$N(v_j)$是与子节点$v_j$相关联的子样本个数</p>
<p>决策树算法会选择最大化增益的条件，因为对任何分枝过程来说，$I(parent)$都是一个不变的值，所以最大化增益等价于最小化子节点的不纯性衡量的加权平均。</p>
<h3 id="1-2-3-ID3的局限性"><a href="#1-2-3-ID3的局限性" class="headerlink" title="1.2.3 ID3的局限性"></a>1.2.3 ID3的局限性</h3><p>ID3局限性主要源于局部最优化条件，即信息增益的计算方法，其局限性主要有以下几点：</p>
<ul>
<li>分支度越高（分类水平越多）离散变量往往子节点的总信息熵会更小，ID3是按照某一列进行切分，在极限情况下取ID作为切分字段，每个分类的纯度都是100%，因此这样的分类方式是没有效益的</li>
<li>不能直接处理连续型变量，若使用ID3处理连续型变量，则首先需要对连续型变量进行离散化</li>
<li>对缺失值比较敏感，使用ID3之前需要提前对缺失值进行处理</li>
<li>没有剪枝的设置，容易导致过拟合，即在训练集上表现很好，测试集上表现很差</li>
</ul>
<h3 id="1-3-C4-5算法-amp-CART算法"><a href="#1-3-C4-5算法-amp-CART算法" class="headerlink" title="1.3 C4.5算法 &amp; CART算法"></a>1.3 C4.5算法 &amp; CART算法</h3><h3 id="1-3-1-修改局部最优化条件"><a href="#1-3-1-修改局部最优化条件" class="headerlink" title="1.3.1 修改局部最优化条件"></a>1.3.1 修改局部最优化条件</h3><p>在C4.5中，首先通过引入分支度（IV:Information Value）概念，对信息增益的计算方法进行修正。</p>
<p>将信息熵计算公式中的$p(i|t)$（<strong>即某类别样例占总样例数</strong>）改成了$P(v_i)$，即<strong>某子节点的总样本数占父节点总样本数的比例</strong></p>
<p>$$Information Value = -\sum_{i=1}^kP(v_i)\log_2P(v_i)$$</p>
<p>其中，$i$表示父节点的第$i$个子节点，$v_i$表示第$i$个子节点样例数，$P(v_i)$表示第$i$个子节点拥有样例数占父节点总样例数的比例。</p>
<p>最终，在C4.5中，使用之前的信息增益除以分支度作为选取切分字段的参考指标，该指标被称作Gain Ratio(增益率)，计算公式如下：<br>$$Gain Ratio = \frac{Information Gain}{Information Value}$$</p>
<p>本质是信息增益最大，分支度又比较小的列（也就是纯度提升很快，但又不是靠着把类别分特别细来提升的那些特征）</p>
<h3 id="1-3-2-连续变量处理手段"><a href="#1-3-2-连续变量处理手段" class="headerlink" title="1.3.2 连续变量处理手段"></a>1.3.2 连续变量处理手段</h3><p>在C4.5中，同样还增加了针对连续变量的处理手段。如果输入特征字段是连续型变量，则有下列步骤：</p>
<ol>
<li>算法首先会对这一列数进行从小到大排序</li>
<li>选取相邻的两个数的中间数作为切分数据集的备选点，若一个连续变量有N个值，则在C4.5的处理过程中将产生N-1个备选切点，并且每个切分点都代表着一种二叉树的切分方案</li>
</ol>
<p>因此在对于包含连续变量的数据集进行树模型构建的过程中要消耗更多的运算资源。但与此同时，我们也会发现，当连续变量的某中间点参与到决策树的二分过程中，往往代表该店对于最终分类结果有较大影响，这也为我们连续变量的分箱压缩提供了指导性的意见。也是最重要的模型指导分箱方法。</p>
<p>CART树本质其实和C4.5区别不大，只不过CART树所有的层都是二叉树</p>
<ol>
<li>首先特征从小到大一次排列</li>
<li>计算两两相邻的均值</li>
<li>按均值所在的点，对连续型变量进行二分，二分得到的点交做决策树的“树桩”</li>
<li>找每种二分切分方案的获益比例，获益比例最大的切分点，就是切点</li>
<li>切完之后，计算加权信息熵，计算信息增益，引入分支度，计算增益比例</li>
</ol>
<hr>
<h2 id="2-sklearn中的决策树"><a href="#2-sklearn中的决策树" class="headerlink" title="2 sklearn中的决策树"></a>2 sklearn中的决策树</h2><ul>
<li>模块sklearn.tree</li>
</ul>
<p>模块总共包含五个类：</p>
<table>
<thead>
<tr>
<th align="left">tree.DecisionTreeClassifier</th>
<th align="left">分类树</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tree.DecisionTreeRegressor</td>
<td align="left">回归树</td>
</tr>
<tr>
<td align="left">tree.export_graphviz</td>
<td align="left">将生成的决策树导出为DOT格式</td>
</tr>
<tr>
<td align="left">tree.ExtraTreeClassifier</td>
<td align="left">高随机版本的分类树</td>
</tr>
<tr>
<td align="left">tree.ExtraTreeRegressor</td>
<td align="left">高随机版本的回归树</td>
</tr>
</tbody></table>
<h3 id="2-1-重要参数"><a href="#2-1-重要参数" class="headerlink" title="2.1 重要参数"></a>2.1 重要参数</h3><h3 id="2-2-1-criterion"><a href="#2-2-1-criterion" class="headerlink" title="2.2.1 criterion"></a>2.2.1 criterion</h3><p>这个参数用来决定不纯度的计算方法</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">criterion</th>
</tr>
</thead>
<tbody><tr>
<td align="left">如何影响模型?</td>
<td align="left">确定不纯度的计算方法，帮忙找出最佳节点和最佳分枝，不纯度越低，决策树对训练集 的拟合越好</td>
</tr>
<tr>
<td align="left">可能的输入有哪些？</td>
<td align="left">不填默认基尼系数，填写gini使用基尼系数，填写entropy使用信息增益</td>
</tr>
<tr>
<td align="left">怎样选取参数？</td>
<td align="left">通常使用基尼系数</td>
</tr>
</tbody></table>
<h3 id="2-2-2-random-state-amp-splitter"><a href="#2-2-2-random-state-amp-splitter" class="headerlink" title="2.2.2 random_state &amp; splitter"></a>2.2.2 random_state &amp; splitter</h3><ul>
<li><p>random_state 用来设置分枝中的随机模式的参数，默认None，在高维度时随机性会表现更明显，低维度的数据（比如鸢尾花数据集），随机性几乎不会显现。输入任意整数，会一直长出同一棵树，让模型稳定下来。</p>
</li>
<li><p>splitter 也是用来控制决策树中的随机选项的，有两种输入值，输入”best”，决策树在分枝时虽然随机，但是还是会优先选择更重要的特征进行分枝（重要性可以通过属性feature_importances_查看），输入“random”，决策树在分枝时会更加随机，树会因为含有更多的不必要信息而更深更大，并因这些不必要信息而降低对训练集的拟合。这也是防止过拟合的一种方式。当你预测到你的模型会过拟合，用这两个参数来帮助你降低树建成之后过拟合的可能性。当然，树一旦建成，我们依然是使用剪枝参数来防止过拟合。</p>
</li>
</ul>
<h3 id="2-2-3-剪枝参数"><a href="#2-2-3-剪枝参数" class="headerlink" title="2.2.3 剪枝参数"></a>2.2.3 剪枝参数</h3><ul>
<li><p>max_depth 限制树的最大深度，超过设定深度的树枝全部剪掉这是用得最广泛的剪枝参数，在高维度低样本量时非常有效。决策树多生长一层，对样本量的需求会增加一倍，所  以限制树深度能够有效地限制过拟合。在集成算法中也非常实用。实际使用时，建议从=3开始尝试，看看拟合的效  果再决定是否增加设定深度。</p>
</li>
<li><p>min_samples_leaf 限定，一个节点在分枝后的每个子节点都必须包含至少min_samples_leaf个训练样本，否则分  枝就不会发生，或者，分枝会朝着满足每个子节点都包含min_samples_leaf个样本的方向去发生。一般搭配max_depth使用，在回归树中有神奇的效果，可以让模型变得更加平滑。这个参数的数量设置得太小会引起过拟合，设置得太大就会阻止模型学习数据。一般来说，建议从=5开始使用。如果叶节点中含有的样本量变化很 大，建议输入浮点数作为样本量的百分比来使用。同时，这个参数可以保证每个叶子的最小尺寸，可以在回归问题  中避免低方差，过拟合的叶子节点出现。对于类别不多的分类问题，=1通常就是最佳选择。</p>
</li>
<li><p>min_samples_split 限定，一个节点必须要包含至少min_samples_split个训练样本，这个节点才允许被分枝，否则  分枝就不会发生。</p>
</li>
<li><p>max_features 限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃。和max_depth异曲同工， max_features是用来限制高维度数据的过拟合的剪枝参数，但其方法比较暴力，是直接限制可以使用的特征数量而强行使决策树停下的参数，在不知道决策树中的各个特征的重要性的情况下，强行设定这个参数可能会导致模型学习不足。如果希望通过降维的方式防止过拟合，建议使用PCA，ICA或者特征选择模块中的降维算法。</p>
</li>
<li><p>min_impurity_decrease 限制信息增益的大小，信息增益小于设定数值的分枝不会发生。这是在0.19版本中更新的    功能，在0.19版本之前时使用min_impurity_split。</p>
</li>
</ul>
<h3 id="2-2-4-目标权重参数"><a href="#2-2-4-目标权重参数" class="headerlink" title="2.2.4 目标权重参数"></a>2.2.4 目标权重参数</h3><ul>
<li><p>class_weight 完成样本标签平衡的参数。样本不平衡是指在一组数据集中，标签的一类天生占有很大的比例。因此我们要使用class_weight参数对样本标签进行一定的均衡，给少量的标签更多的权重，让模型更偏向少数类，向捕获少数类的方向建模。该参数默认None，此模式表示自动给  与数据集中的所有标签相同的权重。</p>
</li>
<li><p>min_weight_fraction_leaf 有了权重之后，样本量就不再是单纯地记录数目，而是受输入的权重影响了，因此这时候剪枝，就需要搭配min_ weight_fraction_leaf这个基于权重的剪枝参数来使用。另请注意，基于权重的剪枝参数（例如min_weight_ fraction_leaf）将比不知道样本权重的标准（比如min_samples_leaf）更少偏向主导类。如果样本是加权的，则使用基于权重的预修剪标准来更容易优化树结构，这确保叶节点至少包含样本权重的总和的一小部分。</p>
</li>
</ul>
<h2 id="3-决策树的优缺点"><a href="#3-决策树的优缺点" class="headerlink" title="3 决策树的优缺点"></a>3 决策树的优缺点</h2><h3 id="3-1-决策树优点"><a href="#3-1-决策树优点" class="headerlink" title="3.1 决策树优点"></a>3.1 决策树优点</h3><ol>
<li>易于理解和解释，因为树木可以画出来被看见</li>
<li>需要很少的数据准备。其他很多算法通常都需要数据规范化，需要创建虚拟变量并删除空值等。但请注意，sklearn中的决策树模块不支持对缺失值的处理。</li>
<li>使用树的成本（比如说，在预测数据的时候）是用于训练树的数据点的数量的对数，相比于其他算法，这是一个很低的成本。</li>
<li>能够同时处理数字和分类数据，既可以做回归又可以做分类。其他技术通常专门用于分析仅具有一种变量类型的数据集。</li>
<li>能够处理多输出问题，即含有多个标签的问题，注意与一个标签中含有多种标签分类的问题区别开</li>
<li>是一个白盒模型，结果很容易能够被解释。如果在模型中可以观察到给定的情况，则可以通过布尔逻辑轻松解释条件。相反，在黑盒模型中（例如，在人工神经网络中），结果可能更难以解释。</li>
<li>可以使用统计测试验证模型，这让我们可以考虑模型的可靠性。</li>
<li>即使其假设在某种程度上违反了生成数据的真实模型，也能够表现良好。</li>
</ol>
<h3 id="3-2-决策树的缺点"><a href="#3-2-决策树的缺点" class="headerlink" title="3.2 决策树的缺点"></a>3.2 决策树的缺点</h3><ol>
<li>决策树学习者可能创建过于复杂的树，这些树不能很好地推广数据。这称为过度拟合。修剪，设置叶节点所需的最小样本数或设置树的最大深度等机制是避免此问题所必需的，而这些参数的整合和调整对初学者来说会比较晦涩</li>
<li>决策树可能不稳定，数据中微小的变化可能导致生成完全不同的树，这个问题需要通过集成算法来解决。</li>
<li>决策树的学习是基于贪婪算法，它靠优化局部最优（每个节点的最优）来试图达到整体的最优，但这种做法不能保证返回全局最优决策树。这个问题也可以由集成算法来解决，在随机森林中，特征和样本会在分枝过程中被随机采样。</li>
<li>有些概念很难学习，因为决策树不容易表达它们，例如XOR，奇偶校验或多路复用器问题。</li>
<li>如果标签中的某些类占主导地位，决策树学习者会创建偏向主导类的树。因此，建议在拟合决策树之前平衡数据集。</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>行测笔记（二）：言语理解与表达</title>
    <url>/2020/07/22/xingce2/</url>
    <content><![CDATA[<h1 id="1-片段阅读"><a href="#1-片段阅读" class="headerlink" title="1 片段阅读"></a>1 片段阅读</h1><p>解题顺序：提问————文段————选项</p>
<p>对比择优，好的答案是对比出来的</p>
<h2 id="一、中心理解题"><a href="#一、中心理解题" class="headerlink" title="一、中心理解题"></a>一、中心理解题</h2><h3 id="（1）重点词之关联词"><a href="#（1）重点词之关联词" class="headerlink" title="（1）重点词之关联词"></a>（1）重点词之关联词</h3><a id="more"></a>

<ol>
<li>转折关系，转折之后是重点</li>
</ol>
<p>错误选项特征：</p>
<ul>
<li>转折前的内容</li>
<li>例子、原因、背景…</li>
<li>无中生有</li>
<li>绝对表述</li>
<li>与文意相悖</li>
</ul>
<p>略读句子特征：</p>
<ul>
<li>例子</li>
<li>原因</li>
<li>背景</li>
</ul>
<ol start="2">
<li><p>因果关系，结论是重点</p>
</li>
<li><p>必要条件关系</p>
</li>
</ol>
<p>典型格式：只有…才…</p>
<p>必要条件是重点（“只有”和“才”之间的部分）</p>
<ol start="4">
<li>并列关系</li>
</ol>
<p>理论要点：概括全面完整</p>
<p>文段特征：</p>
<ul>
<li>包含并列关联词</li>
<li>句式相近或相同</li>
<li>无明显其他关联词</li>
</ul>
<p>选项特征：</p>
<ul>
<li>两方面情况：和、及、与、同</li>
<li>更多情况：许多、一些、不同、各种、一系列</li>
</ul>
<h3 id="（2）行文脉络"><a href="#（2）行文脉络" class="headerlink" title="（2）行文脉络"></a>（2）行文脉络</h3><p>理论要点：把握中心句及分述句的特点</p>
<p>中心句特征：观点（结论、评价、对策）</p>
<ol>
<li>总————分（观点+解释说明）</li>
<li>分————总</li>
<li>总————分————总</li>
<li>分————总————分</li>
<li>分————分</li>
</ol>
<h2 id="二、细节判断"><a href="#二、细节判断" class="headerlink" title="二、细节判断"></a>二、细节判断</h2><h3 id="（1）典型细节题"><a href="#（1）典型细节题" class="headerlink" title="（1）典型细节题"></a>（1）典型细节题</h3><p>错误选项类型：</p>
<ol>
<li>无中生有</li>
<li>偷换概念</li>
<li>偷换时态</li>
<li>偷换逻辑</li>
<li>因果偷换</li>
<li>并列偷换</li>
</ol>
<p>快速解题技巧：</p>
<ol>
<li><p>对比项</p>
</li>
<li><p>相对绝对项</p>
</li>
<li><p>表述与实际不符项</p>
</li>
</ol>
<h3 id="（2）细节主旨化"><a href="#（2）细节主旨化" class="headerlink" title="（2）细节主旨化"></a>（2）细节主旨化</h3><p>理论要点：优选契合主旨的选项</p>
<h1 id="2-语句表达"><a href="#2-语句表达" class="headerlink" title="2 语句表达"></a>2 语句表达</h1><h2 id="一、语句排序题"><a href="#一、语句排序题" class="headerlink" title="一、语句排序题"></a>一、语句排序题</h2><h3 id="（1）根据选项提示，对比后确定首句（一定要对比）"><a href="#（1）根据选项提示，对比后确定首句（一定要对比）" class="headerlink" title="（1）根据选项提示，对比后确定首句（一定要对比）"></a>（1）根据选项提示，对比后确定首句（一定要对比）</h3><ol>
<li>下定义 </li>
<li>背景引入</li>
<li>非首句特征<ul>
<li>关联词后半部分</li>
<li>指代词（一句话单独出现指代词，但是并未出现指代对象，则该句不能作首句）</li>
</ul>
</li>
</ol>
<h3 id="（2）确定捆绑集团（紧紧绑在一起，中间不允许有“第三者”介入）-确定顺序-确定尾句"><a href="#（2）确定捆绑集团（紧紧绑在一起，中间不允许有“第三者”介入）-确定顺序-确定尾句" class="headerlink" title="（2）确定捆绑集团（紧紧绑在一起，中间不允许有“第三者”介入）/确定顺序/确定尾句"></a>（2）确定捆绑集团（紧紧绑在一起，中间不允许有“第三者”介入）/确定顺序/确定尾句</h3><h4 id="确定捆绑集团"><a href="#确定捆绑集团" class="headerlink" title="确定捆绑集团"></a>确定捆绑集团</h4><ol>
<li>指代词捆绑（这、那、他、该、其）</li>
<li>关联词<ul>
<li>配套出现（不但…而且…）</li>
<li>单独一个（但、同时 分析句子意思）</li>
</ul>
</li>
</ol>
<h4 id="确定顺序"><a href="#确定顺序" class="headerlink" title="确定顺序"></a>确定顺序</h4><ol>
<li>时间顺序</li>
<li>逻辑顺序</li>
</ol>
<h4 id="确定尾句"><a href="#确定尾句" class="headerlink" title="确定尾句"></a>确定尾句</h4><p>结论、对策</p>
<h3 id="（3）验证（只验证你基本锁定的答案，而非全部验证）"><a href="#（3）验证（只验证你基本锁定的答案，而非全部验证）" class="headerlink" title="（3）验证（只验证你基本锁定的答案，而非全部验证）"></a>（3）验证（只验证你基本锁定的答案，而非全部验证）</h3><h2 id="二、语句填空题"><a href="#二、语句填空题" class="headerlink" title="二、语句填空题"></a>二、语句填空题</h2><h3 id="（1）横线在结尾"><a href="#（1）横线在结尾" class="headerlink" title="（1）横线在结尾"></a>（1）横线在结尾</h3><ol>
<li>总结前文</li>
<li>提出对策</li>
</ol>
<h3 id="（2）横线在开头"><a href="#（2）横线在开头" class="headerlink" title="（2）横线在开头"></a>（2）横线在开头</h3><p>需要概括文段的中心内容</p>
<h3 id="（3）横线在中间"><a href="#（3）横线在中间" class="headerlink" title="（3）横线在中间"></a>（3）横线在中间</h3><ol>
<li>注意与上下文联系</li>
<li>把握好主题词，保证文段话题一致</li>
</ol>
<h2 id="三、接语选择题"><a href="#三、接语选择题" class="headerlink" title="三、接语选择题"></a>三、接语选择题</h2><p>重点关注文段最后一句话</p>
<h1 id="3-逻辑填空"><a href="#3-逻辑填空" class="headerlink" title="3 逻辑填空"></a>3 逻辑填空</h1><h2 id="一、词的辨析"><a href="#一、词的辨析" class="headerlink" title="一、词的辨析"></a>一、词的辨析</h2><h3 id="（1）词义侧重"><a href="#（1）词义侧重" class="headerlink" title="（1）词义侧重"></a>（1）词义侧重</h3><ol>
<li>用不一样的字组词</li>
<li>整词进行固定搭配</li>
</ol>
<h3 id="（2）固定搭配"><a href="#（2）固定搭配" class="headerlink" title="（2）固定搭配"></a>（2）固定搭配</h3><p>找准搭配对象（常用词、热点词）</p>
<p>横线所填词搭配由“和、及、与”引导的并列结构，所填词语需与并列结构搭配恰当</p>
<h3 id="（3）程度轻重"><a href="#（3）程度轻重" class="headerlink" title="（3）程度轻重"></a>（3）程度轻重</h3><p>所填词语的程度与文段意思的轻重保持一致</p>
<h3 id="（4）感情色彩"><a href="#（4）感情色彩" class="headerlink" title="（4）感情色彩"></a>（4）感情色彩</h3><p>所填词语的感情色彩和文段的感情色彩保持一致</p>
<h2 id="二、语境分析"><a href="#二、语境分析" class="headerlink" title="二、语境分析"></a>二、语境分析</h2><p>###（1）关联关系</p>
<ol>
<li>转折</li>
<li>递进</li>
<li>并列</li>
</ol>
<h3 id="（2）对应关系"><a href="#（2）对应关系" class="headerlink" title="（2）对应关系"></a>（2）对应关系</h3><ol>
<li>解释类、重点语句<ul>
<li>指代词</li>
<li>主题词</li>
<li>形象表达</li>
<li>完整语句</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>行测笔试</category>
      </categories>
      <tags>
        <tag>行测笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结（二）：物理层</title>
    <url>/2020/08/12/network2/</url>
    <content><![CDATA[<h1 id="1-通信基础"><a href="#1-通信基础" class="headerlink" title="1 通信基础"></a>1 通信基础</h1><p>时延：是指数据（一个报文或者分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，网络中的时延由以下几个不同部分组成</p>
<ol>
<li>传输时延=发送时延：发送数据时，数据块从结点进入到传输媒体所需要的时间</li>
<li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间</li>
<li>处理时延：交换结点为储存转发而进行一些必要的处理所花费的时间</li>
<li>排序时延：结点缓存队列中分组排序所经历的时延</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/DDD4CD39869743DE8A80130BC9D21D21?method=download&shareKey=e60a924c7b234f947269dd2c1f6e99e1" alt></p>
<a id="more"></a>

<h1 id="2-电路交换、报文交换与分组交换"><a href="#2-电路交换、报文交换与分组交换" class="headerlink" title="2 电路交换、报文交换与分组交换"></a>2 电路交换、报文交换与分组交换</h1><p>（1）电路交换</p>
<p>在使用电路交换通话前，必须先拨号请求建立连接，当被叫用户听到交换机送来的震铃音并摘机后，从主叫端到被叫端建立了一条连接，也就是一条专用的物理通路，通话完毕后，交换机释放刚才使用的这条专用的物理通路。这种必须经过建立连接、通话和释放连接三个步骤的交换方式称为电路交换</p>
<p>（2）报文交换</p>
<p>传输单位是报文，一次性发送的数据块，当一个站要发送报文时，将一个目的地址附加到报文上，网络结点根据报文上的目的地址信息，把报文发送到下一节点，一直逐个节点地转送到目的节点，无需通过呼叫建立连接</p>
<p>（3）分组交换</p>
<p>分组交换是报文交换的一种改进，将报文分成若干个组，可以存储在内存中，提高了交换速度</p>
<h1 id="3-数据报与虚电路"><a href="#3-数据报与虚电路" class="headerlink" title="3 数据报与虚电路"></a>3 数据报与虚电路</h1><p>当两台计算机进行通信时，应当先建立连接（虚电路），预留双方通信所需要的一切网络资源，然后双方就沿着已建立的虚电路发送分组。这样分组的首部不需要填写完整的目的主机地址，只需要填写这条虚电路的编号，减少了分组的开销。</p>
<h1 id="4-传输介质"><a href="#4-传输介质" class="headerlink" title="4 传输介质"></a>4 传输介质</h1><p>1、双绞线<br>2、同轴电缆<br>3、光缆<br>4、无线通信</p>
<h1 id="5-物理层设备"><a href="#5-物理层设备" class="headerlink" title="5 物理层设备"></a>5 物理层设备</h1><p>（1）中继器</p>
<p>过去广泛使用粗缆或细缆以太网，常用工作在物理层的中继器又称转发器来扩展以太网的地理覆盖范围</p>
<p>（2）集线器</p>
<p>集线器是多端口的中继器，用多个集线器可以连成更大的局域网</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（二）支持向量机（SVM）</title>
    <url>/2020/07/16/svm/</url>
    <content><![CDATA[<h1 id="1-支持向量机（SVM）原理"><a href="#1-支持向量机（SVM）原理" class="headerlink" title="1 支持向量机（SVM）原理"></a>1 支持向量机（SVM）原理</h1><p>从算法的功能来看，SVM几乎涵盖了机器学习的所有算法需求</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">有监督学习</td>
<td align="left">线性二分类与多分类（Linear Support Vector Classiﬁcation）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">非线性二分类与多分类（Support Vector Classiﬁcation, SVC）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">普通连续型变量的回归（Support Vector Regression）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">概率型连续变量的回归（Bayesian SVM）</td>
</tr>
<tr>
<td align="left">无监督学习</td>
<td align="left">支持向量聚类（Support Vector Clustering，SVC）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">异常值检测（One-class SVM）</td>
</tr>
<tr>
<td align="left">半监督学习</td>
<td align="left">转导支持向量机（Transductive Support Vector Machines，TSVM）</td>
</tr>
</tbody></table>
<a id="more"></a>
<h2 id="1-1-线性SVM用于分类的原理"><a href="#1-1-线性SVM用于分类的原理" class="headerlink" title="1.1 线性SVM用于分类的原理"></a>1.1 线性SVM用于分类的原理</h2><p>要理解SVM的损失函数，先定义决策边界，假设数据中共计有$N$个训练样本，每个训练样本$i$可以被表示为$(x_i,y_i)(i=1,2,\dots N)$，其中$x_i$是$(x_{1i},x_{2i}\dots x_{ni})^T$这样一个特征向量，每个样本总共包含$n$个特征。</p>
<p>二分类标签$y_i$取值为${-1,1}$</p>
<p>若$n=2$，则有$i=(x_{1i},x_{2i},y_i)^T$，在二维平面上，以$x_2$为横坐标，$x_1$为从坐标，$y$为颜色，来可视化所有的$N$个样本</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/A4A7E90B88454F098F8BDBDCCF02B27D?method=download&shareKey=a5c90f8c069094d544bacfbb471dbd02" alt></p>
<p>所以要在这个数据集上找寻一个决策边界(超平面)，让紫色点的标签为1，红色点的标签为-1</p>
<p>二维平面上，任意一条线可以表示为：<br>$$x_1 = ax_2+b$$</p>
<p>将表达式变换：<br>$$0=ax_2-x_1+b$$<br>$$0=(a,-1)*\binom{x_2}{x_1}+b$$<br>$$0=w^Tx+b$$</p>
<p>其中$(a,-1)$是参数向量$w$，$x$是特征向量，$b$是截距，在SVM中，使用这个表达式表示决策边界。</p>
<p><strong>我们的目标是求解能够让边际最大化的决策边界</strong></p>
<p>如果在决策边界上任意取两个点$x_a,x_b$，并代入决策边界的表达式，则有：<br>$$w^Tx_a+b=0$$<br>$$w^Tx_b+b=0$$<br>两式相减，可以得到：<br>$$w^T*(x_a-x_b)=0$$</p>
<p>两个向量的点积为0，证明参数向量$w$的方向垂直与我们的决策边界</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/F29C776BA1854D9C87B9BA1EEFF2F3B9?method=download&shareKey=f6addba1a1e3223deb09059443ef2cf1" alt></p>
<p>由于紫色的点代表标签$y=1，y=-1$，因此以下式判定：<br>$$<br>y=<br>\begin{cases}<br>1, &amp;if\ w*x_t+b&gt;0\\<br>-1, &amp;if\ w * x_t+b&lt;0<br>\end{cases}<br>$$</p>
<p><strong>注意：决策边界以上的点都为正，以下的点都为负，是人为规定的，不会影响对参数$w$和截距$b$的求解</strong></p>
<p>决策边界的两边要有两个超平面，两个超平面在二维空间中是两条平行线（虚线超平面），而他们之间的距离就是我们的边际$d$。<br>我们将这两条平行线表示为：</p>
<p>$$w * x+b=k, w * x+b=-k$$</p>
<p>两边同时除以$k$,则可以得到：</p>
<p>$$w * x+b=1, w * x+b=-1$$</p>
<p>表达式两边1和-1分别表示了两条平行决策边界的虚线到决策边界的相对距离。让这两条线分别过两类数据中距离决策边界最近的点，这些点被称为“支持向量”。</p>
<p>令紫色类的点为$x_p$，红色类的点为$x_r$，则可以得到：</p>
<p>$$w * x_p+b=1,w * x_r+b=-1$$</p>
<p>两个式相减，则有：<br>$$w * (w_p-w_r)=2$$<br>如下图所示，$(x_p-x_r)$可以表示为两点之间的连线，而边际$d$是平行于$w$的。</p>
<p>又因为以下数学性质：</p>
<table>
<thead>
<tr>
<th align="left">线性代数中模长的运用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">向量$b$除以自身的模长可以得到$b$方向上的单位向量</td>
</tr>
<tr>
<td align="left">向量a乘以向量b方向上的单位向量，可以得到向量a在向量b方向上的投影的长度。</td>
</tr>
</tbody></table>
<p>所以，将上述式子两边同时除以$||w||$, 则可以得到：<br>$$\frac{w*(x_p-x_r)}{||w||}=\frac{2}{||w||}$$<br>$$d = \frac{2}{||w||}$$</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/B26C385AAC024C1791BBFDDF643F3D01?method=download&shareKey=aa3e06d8df0f9b472581aa1282400ae3" alt></p>
<p>所以，求最大边界，对应的就是最大化d,求解以下函数的最小值：<br>$$f(w)=\frac{||w||^2}{2}$$</p>
<p>对于任意样本，可以把决策函数写作：<br>$$w * x_i+b&gt;=1\   if\ y_i=1$$<br>$$w * x_i+b&lt;=-1 \  if\ y_i=-1$$<br>将两个式子整合：<br>$$y_i(w*x_i+b)&gt;=1, i=1,2,\dots N$$</p>
<h2 id="1-2-线性SVM的拉格朗日对偶函数和决策函数"><a href="#1-2-线性SVM的拉格朗日对偶函数和决策函数" class="headerlink" title="1.2 线性SVM的拉格朗日对偶函数和决策函数"></a>1.2 线性SVM的拉格朗日对偶函数和决策函数</h2><p>损失函数分为两个部分：最要最小化的函数，以及参数求解后必须满足的约束条件</p>
<h3 id="1-2-1-将损失函数从最初形态转换为拉格朗日乘数形态"><a href="#1-2-1-将损失函数从最初形态转换为拉格朗日乘数形态" class="headerlink" title="1.2.1 将损失函数从最初形态转换为拉格朗日乘数形态"></a>1.2.1 将损失函数从最初形态转换为拉格朗日乘数形态</h3><p><strong>1.为什么要进行转换？</strong></p>
<p>我们的目标是求解让损失函数最小化的$w$，希望能够找出一种方式，能在满足条件$y_i(w*x_i+b)&gt;=1$，因此，一种业界认可的方式是使用拉格朗日乘数法(standard Lagrange multiplier method)</p>
<p><strong>2.为什么可以进行转换</strong></p>
<p>拉格朗日乘数法正好可以用来解决凸优化问题，使用拉格朗日乘数法将损失函数改写为考虑了约束条件的形式：<br>$$L(w,b,\alpha)=\frac{1}{2}||w||^2-\sum_{i=1}^N\alpha_i(y_i(w*x_i+b)-1) (\alpha_i&gt;=0)$$</p>
<p>其中，$\alpha_i$叫作拉格朗日乘数。</p>
<p><strong>3.怎样进行转换</strong></p>
<p>拉格朗日函数分为两个部分，第一部分是原始损失函数，第二部分是约束条件。我们希望，$L(w,b,\alpha)$在满足约束条件下，最小化损失函数。所以要先以$\alpha$为参数，求解$L(w,b,\alpha)$的最大值，在以$w,b$为参数，求解$L(w,b,\alpha)$的最小值。</p>
<p>因此，我们的目标可写作：</p>
<p>$$\min_{w,b}\max_{\alpha_i&gt;=0}L(w,b,\alpha) (\alpha_i&gt;=0)$$</p>
<p>首先，第一步执行max，即最大化$L(w,b,\alpha)$，有两种情况：</p>
<ul>
<li>当$y_i(w * x_i+b)&gt;1$，函数的第二部分$\sum_{i=1}^N\alpha_i(y_i(w*x_i+b)-1)$一定为正，式子$\frac{1}{2}||w||^2$就要减去一个正数，此时若需要最大化$L(w,b,\alpha)$,则$\alpha$必须取到0</li>
<li>当$y_i(w * x_i+b)&lt;1$，函数的第二部分$\sum_{i=1}^N\alpha_i(y_i(w*x_i+b)-1)$一定为负，式子$\frac{1}{2}||w||^2$就要减去一个负数，此时若需要最大化$L(w,b,\alpha)$,则$\alpha$必须取到正无穷</li>
</ul>
<p>因此，可以把函数的第二部分当做一个惩罚项，只有当$y_i(w*x_i+b)&gt;1$时函数没有受到惩罚，从而在求解最小值的时候让约束条件满足</p>
<p>现在，$L(w,b,\alpha)$是我们新的损失函数，目标要通过先最大化，再最小化求解$w，b$</p>
<h3 id="1-2-2-将拉格朗日函数转换为拉格朗日对偶函数"><a href="#1-2-2-将拉格朗日函数转换为拉格朗日对偶函数" class="headerlink" title="1.2.2 将拉格朗日函数转换为拉格朗日对偶函数"></a>1.2.2 将拉格朗日函数转换为拉格朗日对偶函数</h3><p><strong>1.为什么要进行转换？</strong><br>求极值，最简单的方法是对参数求导后让一阶导数为0，这里对参数$w,b$分别求偏导并使其为0</p>
<p>$$<br>\begin{equation}\begin{split}<br>L(w,b,\alpha)&amp;=\frac{1}{2}||w||^2-\sum_{i=1}^N\alpha_i(y_i(w * x_i+b)-1)\\<br>&amp;=\frac{1}{2}||w||^2-\sum_{i=1}^N(\alpha_iy_iw * x_i+\alpha_iy_ib-\alpha_i) \\<br>&amp; =\frac{1}{2}||w||^2-\sum_{i=1}^N(\alpha_iy_iw * x_i)-\sum_{i=1}^N\alpha_iy_ib+\sum_{i=1}^N\alpha_i\\<br>&amp;=\frac{1}{2}(w^Tw)^{\frac{1}{2}*2}-\sum_{i=1}^N(\alpha_iy_iw * x_i)-\sum_{i=1}^N\alpha_iy_ib+\sum_{i=1}^N\alpha_i<br>\end{split}\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}\begin{split}<br>\frac{\partial L(w,b,\alpha)}{\partial w}&amp;=\frac{1}{2}*2w-\sum_{i=1}^N\alpha_iy_ix_i \\<br>&amp;=w-\sum_{i=1}^N\alpha_iy_ix_i=0 \to w = \sum_{i=1}^N\alpha_iy_ix_i<br>\end{split}\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}\begin{split}<br>\frac{\partial L(w,b,\alpha)}{\partial b}&amp;=\sum_{i=1}^N\alpha_iy_i=0 \to \sum_{i=1}^N\alpha_iy_i=0 \\<br>\end{split}\end{equation}<br>$$</p>
<p>由于两个求偏导结果中都带有未知的拉格朗日乘数$\alpha_i$，因此需要有一种方法来求解拉格朗日乘数，而拉格朗日对偶函数，是只带有$alpha_i$而不带有$w,b$的形式，可以求解$\alpha_i$然后再代入（2）、（3）式中来求解参数$w,b$</p>
<p><strong>2.为什么能够进行转换</strong></p>
<p>对于任意一个拉格朗日函数$L(x,\alpha)=f(x)+\sum_{i=1}^q\alpha_ih_i(x)$，都存在一个与它对应的对偶函数$g(\alpha)$，只带有拉格朗日乘数$\alpha$作为唯一参数。如果$L(x,\alpha)$存在最优解并可以表示为$\min_xL(x,\alpha)$，并且对偶函数的最优解也存在并可以表示为$\max_\alpha g(\alpha)$，则可以定义对偶差异(dual gap)<br>$$\Delta = \min_{x}L(x,\alpha)-\max_\alpha g(\alpha)$$</p>
<p>如果$\Delta=0$,则称$L(x,\alpha)$与其对偶函数之间存在强对偶关系，此时可以通过求其对偶函数的最优解来代替原始函数。</p>
<p>强对偶关系存在需要满足KKT(Karush-Kuhn-Tucker)条件：<br>$$<br>\begin{equation}\begin{split}<br>\frac{\partial L}{\partial x_i}=0,\forall_i = 1,2,\dots,d \\<br>h_i(x)&lt;=0,\forall_i = 1,2,\dots,q \\<br>\alpha_i&gt;=0,\forall_i = 1,2,\dots,q \\<br>\alpha_ih_i(x)=0,\forall_i = 1,2,\dots,q \\<br>\end{split}\end{equation}<br>$$</p>
<p>如果我们可以让KKT条件全部成立，则可以求解出$L(w,b,\alpha)$的对偶函数来求解$\alpha$</p>
<p>之前求偏导时，得到<br>$$w = \sum_{i=1}^N\alpha_iy_ix_i$$<br>$$\sum_{i=1}^N\alpha_iy_i=0$$</p>
<p>并且满足：<br>$$-(y(w*x_i+b)-1)&lt;=0, \alpha_i&gt;=0$$</p>
<p>接下来，只需要满足：<br>$$\alpha_i(y_i(w*x_i+b)-1)=0$$</p>
<p>当这个条件满足时，能够让$y_i(w*x_i+b)-1=0$是在虚线的超平面上的样本点，即我们的支持向量，其余样本点必须满足$\alpha_i=0$。</p>
<p>现在KKT的五个条件都得到了满足，可以使用对偶函数求解。</p>
<p><strong>3.怎样进行转换</strong></p>
<p>首先将求导为0代入原始：<br>$$<br>\begin{equation}\begin{split}<br>L(w,b,\alpha)&amp;=\frac{1}{2}||w||^2-\sum_{i=1}^N\alpha_i(y_i(w * x_i+b)-1)\\<br>&amp;=\frac{1}{2}||w||^2-\sum_{i=1}^N(\alpha_iy_iw * x_i+\alpha_iy_ib-\alpha_i) \\<br>&amp; =\frac{1}{2}||w||^2-\sum_{i=1}^N(\alpha_iy_iw * x_i)-\sum_{i=1}^N\alpha_iy_ib+\sum_{i=1}^N\alpha_i\\<br>&amp;=\frac{1}{2}(w^Tw)^{\frac{1}{2}*2}-w\sum_{i=1}^N(\alpha_iy_i * x_i)-b\sum_{i=1}^N\alpha_iy_i+\sum_{i=1}^N\alpha_i \\<br>\end{split}\end{equation}</p>
<p>将（2）、（3）式代入则有<br>$$=\frac{1}{2}w^Tw-w^Tw+\sum_{i=1}^N\alpha_i $$</p>
<p>$$=-\frac{1}{2}w^Tw+\sum_{i=1}^N\alpha_i$$</p>
<p>将（2）式代入，则有：<br>$$=-\frac{1}{2}\sum_{i=1}^N\alpha_iy_ix_i^T * \sum_{i=1}^N\alpha_iy_ix_i+\sum_{i=1}^N\alpha_i$$</p>
<p>令这两个$w$源于不同的特征和标签：<br>$$=-\frac{1}{2}\sum_{i=1,j=1}^N\alpha_iy_ix_i^T\alpha_iy_ix_i+\sum_{i=1}^N\alpha_i$$</p>
<p>$$=\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1,j=1}^N\alpha_i\alpha_jy_iy_jx_i^Tx_j$$</p>
<p>将矩阵相乘转换为内积形式：<br>$$L_d = \sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1,j=1}^N\alpha_i\alpha_jy_iy_jx_i * x_j$$</p>
<p>函数$L_d$就是对偶函数，其对偶差异$L(w,b,\alpha)$和$L_d$，则有：<br>$$\Delta = \min_{w,b}\max_{\alpha_i&gt;=0}L(w,b,\alpha)-\max_{\alpha_i&gt;=0}L_d$$</p>
<p>又因为在推导$L_d$时，对$L(w,b,\alpha)$偏导为0，所以可以把公式写成：<br>$$\Delta = \min_{w,b}\max_{\alpha_i&gt;=0}L(w,b,\alpha)-\max_{\alpha_i&gt;=0}\min_{w,b}L(w,b,\alpha)$$</p>
<p>又因为所有KKT条件满足，所以：<br>$$ \min_{w,b}\max_{\alpha_i&gt;=0}L(w,b,\alpha)=\max_{\alpha_i&gt;=0}\min_{w,b}L(w,b,\alpha)$$</p>
<p>所以，我们只需要求解对偶函数的最大值就可以了，最终，目标函数变化为：<br>$$\max_{\alpha_i&gt;=0}(\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1,j=1}^N\alpha_i\alpha_jy_iy_jx_i * x_j)$$</p>
<h3 id="1-2-3-求解拉格朗日对偶函数极值及其后续过程"><a href="#1-2-3-求解拉格朗日对偶函数极值及其后续过程" class="headerlink" title="1.2.3 求解拉格朗日对偶函数极值及其后续过程"></a>1.2.3 求解拉格朗日对偶函数极值及其后续过程</h3><p>需要使用梯度下降、SMO或者二次规划(QP, quadratic programming)来求解，但是这一过程对数学要求的程度已经远远超出了需要的程度，因此不再深入了解。</p>
<p>只需要知道，一旦求到了$\alpha$值，就可以求得决策边界参数$w,b$</p>
<p>当求得参数后，就可以得到决策边界的表达式：<br>$$f(x_{test})=sign(w*x_{test}+b)$$</p>
<p>其中$x_{test}$是任意测试样本，$sign(h)$是符号函数。</p>
<p>至此，我们对SVM的原理已经有了一个比较深刻的理解。</p>
<h2 id="1-3-非线性SVM与核函数"><a href="#1-3-非线性SVM与核函数" class="headerlink" title="1.3 非线性SVM与核函数"></a>1.3 非线性SVM与核函数</h2><h3 id="1-3-1-SVC在非线性数据上的推广"><a href="#1-3-1-SVC在非线性数据上的推广" class="headerlink" title="1.3.1 SVC在非线性数据上的推广"></a>1.3.1 SVC在非线性数据上的推广</h3><p>为了找出非线性数据的线性决策边界，我们需要将数据从原始空间$x$，投射到新空间$\Phi(x)$中，$\Phi(x)$是一个映射函数，代表某种非线性变换。线性SVM的原理可以很容易推广到非线性情况下，推导过程和逻辑都与线性SVM一样，只是在定义决策边界之前，需要对数据升维，将原始的$x$，转换成$\Phi(x)$</p>
<p>因此，非线性SVM的损失函数初始形态为：<br>$$\min_{w,b}\frac{||w||^2}{2}$$<br>$$subject\  to\  y_i(w * \Phi(x)+b&gt;=1), i=1,2,\dots,N$$<br>拉格朗日和拉格朗日对偶函数也可得：<br>$$L(w,b,\alpha)=\frac{1}{2}||w||^2-\sum_{i=1}^N\alpha_i(y_i(w * \Phi(x)+b)-1)$$<br>$$L_d = \sum_{i=1}^N\alpha_i - \frac{1}{2}\sum_{i,j}\alpha_i\alpha_j y_i y_j\Phi(x_i)\Phi(x_j)$$</p>
<p>同理可以使用相同的推导方式让拉格朗日函数满足KKT条件，并且对每个参数求导，再使用梯度下降或SMO等方式求解，最终得到决策边界函数：<br>$$f(x_{test})=sign(w*\Phi(x_{test})+b)$$</p>
<h3 id="1-3-2-重要参数kernel"><a href="#1-3-2-重要参数kernel" class="headerlink" title="1.3.2 重要参数kernel"></a>1.3.2 重要参数kernel</h3><p>但是，我们不清楚什么样的数据应该使用什么类型的映射函数确保在变换空间中可以找出决策边界。</p>
<table>
<thead>
<tr>
<th align="left">关键概念：核函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">解决这个问题的数学方式，叫作“核技巧”(Kernel Trick)，是一种讷讷够使用数据原始空间中的向量计算表示生维后的空间中的点积结果的数学方式$K(u,v)=\Phi(u)*\Phi(v)$,而这个点积函数$K(u,v)$，就被叫作“核函数”(Kernel Funciton)</td>
</tr>
</tbody></table>
<p>选用不同的核函数，就可以解决不同数据分布下寻找超平面的问题。以下是“kernel”在Sklearn中的几种选项：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/0D76DD0804FD486EA95C591CDF1335C5?method=download&shareKey=c5e8aae3bd6137b2f4c315008302565b" alt></p>
<h3 id="1-3-3-核函数的优势和缺陷"><a href="#1-3-3-核函数的优势和缺陷" class="headerlink" title="1.3.3 核函数的优势和缺陷"></a>1.3.3 核函数的优势和缺陷</h3><ol>
<li>线性核，尤其是多项式核：在高次项计算非常缓慢</li>
<li>rbf和多项式核不擅长处理量纲不统一的数据集</li>
</ol>
<p><strong>因此，SVM执行之前，推荐先进行数据的无量纲化处理</strong></p>
<h3 id="1-3-4-核函数相关的参数：degree-amp-gamma-amp-coef0"><a href="#1-3-4-核函数相关的参数：degree-amp-gamma-amp-coef0" class="headerlink" title="1.3.4 核函数相关的参数：degree &amp; gamma &amp; coef0"></a>1.3.4 核函数相关的参数：degree &amp; gamma &amp; coef0</h3><ul>
<li>gamma是表达式中的$\gamma$</li>
<li>degree是多项式核函数的次数$d$</li>
<li>ceof0是常数项</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">degree</td>
<td align="left">整数，可不填，默认3</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">多项式核函数的次数（’poly’），如果核函数没有选择”poly”，这个参数会被忽略</td>
</tr>
<tr>
<td align="left">gamma</td>
<td align="left">浮点数，可不填，默认“auto”</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">核函数的系数，仅在参数Kernel的选项为”rbf”,”poly”和”sigmoid”的时候有效</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">输入“auto”，自动使用1/(n_features)作为gamma的取值</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">输入”scale”，则使用1/(n_features * X.std())作为gamma的取值</td>
</tr>
<tr>
<td align="left">ceof0</td>
<td align="left">浮点数，可不填，默认=0.0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">核函数中的常数项，它只在参数kernel为’poly’和’sigmoid’的时候有效。</td>
</tr>
</tbody></table>
<h2 id="1-4-硬间隔与软间隔：重要参数C"><a href="#1-4-硬间隔与软间隔：重要参数C" class="headerlink" title="1.4 硬间隔与软间隔：重要参数C"></a>1.4 硬间隔与软间隔：重要参数C</h2><h3 id="1-4-1-SVM在软间隔数据上的推广"><a href="#1-4-1-SVM在软间隔数据上的推广" class="headerlink" title="1.4.1 SVM在软间隔数据上的推广"></a>1.4.1 SVM在软间隔数据上的推广</h3><p>我们可以通过调整我们对决策边界的定义，将硬间隔时得出的数学结论推广到软间隔的情况上，让决策边界能够忍  受一小部分训练误差。这个时候，我们的决策边界就不是单纯地寻求最大边际了，因为对于软间隔地数据来说，边  际越大被分错的样本也就会越多，因此我们需要找出一个”最大边际“与”被分错的样本数量“之间的平衡<br>|关键概念：硬间隔与软间隔|<br>|:–|<br>|当两组数据是完全线性可分，我们可以找出一个决策边界使得训练集上的分类误差为0，这两种数据就被称为  是存在”硬间隔“的。当两组数据几乎是完全线性可分的，但决策边界在训练集上存在较小的训练误差，这两种数据就被称为是存在”软间隔“。|</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/C2FFA1AA25854902ACF46B5A0C5D3410?method=download&shareKey=95be7710c6d12317d6fbda16a8bd436e" alt></p>
<p>由上图可知，超平面无法让数据上的训练误差为0，因此需要放松判别函数的条件，引入松弛系数$\zeta$来帮助优化判别函数：<br>$$w<em>x_i +b&gt;=1-\zeta_i if\ y_i = 1$$<br>$$w</em>x_i +b&lt;=-1+\zeta_i if\ y_i = -1$$</p>
<p>其中$\zeta_i&gt;0$，在求解最大边际的损失函数中加上一个惩罚项，我们的拉格朗日函数，拉格朗日对偶函数也因此被松弛系数改变：<br>$$\min_{w,b,\zeta}\frac{||w||^2}{2}+C\sum_{i=1}^n\zeta_i$$<br>$$subject to y_i(w* \Phi(x_i)+b&gt;=1-\zeta_i)$$<br>$$\zeta_i&gt;=0,i=1,2,\dots,N$$</p>
<p>其中，$C$是用来控制惩罚力度的系数</p>
<p>拉格朗日函数为(其中$\mu$是第二个拉格朗日乘数)：<br>$$L(w,b,\alpha,\zeta)= \frac{1}{2}||w||^2+C\sum_{i=1}^N\zeta_i-\sum_{i=1}^N\alpha_i(y_i(w*\zeta(x_i)+b)-1+\zeta_i)-\sum_{i=1}^N\mu_i\zeta_i$$</p>
<p>需要满足的KKT条件为：<br>$$\frac{\partial L(w,b,\alpha,\zeta)}{\partial w}=\frac{\partial L(w,b,\alpha,\zeta)}{\partial b}=\frac{\partial L(w,b,\alpha,\zeta)}{\partial \zeta}=0$$</p>
<p>$$\zeta_i&gt;=0,\alpha_i&gt;=0,\mu_i&gt;=0$$<br>$$\alpha_i(y_i(w*\Phi(x_i)+b)-1+\zeta_i)=0$$<br>$$\mu_i\zeta_i=0$$</p>
<p>拉格朗日对偶函数为：<br>$$L_D = \sum_{i=1}^N\alpha_i - \frac{1}{2}\sum_{i,j}\alpha_i\alpha_jy_iy_j\Phi(x_i)\Phi(x_j)$$<br>$$subject\  to\  C &gt;=\alpha_i&gt;=0$$<br>公式中唯一出现的新变量，松弛系数惩罚力度$C$。由参数$C$来进行控制</p>
<h3 id="1-4-2-重要参数C"><a href="#1-4-2-重要参数C" class="headerlink" title="1.4.2 重要参数C"></a>1.4.2 重要参数C</h3><p>参数C用于权衡”训练样本的正确分类“与”决策函数的边际最大化“两个不可同时完成的目标，希望找出一个平衡点来让模型的效果最佳。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C</td>
<td align="left">浮点数，默认1，必须大于等于0，可不填</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">松弛系数的惩罚项系数。如果C值设定比较大，那SVC可能会选择边际较小的，能够更好地分类所有训练点的决策边界，不过模型的训练时间也会更长。如果C的设定值较小，那SVC会尽量最大化边界，决策功能会更简单，但代价是训练的准确度。换句话说，C在SVM中的影响就像正则化参数对逻辑回归的影响。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>行测笔记（一）：判断推理</title>
    <url>/2020/07/15/xingce/</url>
    <content><![CDATA[<h1 id="1-图形推理"><a href="#1-图形推理" class="headerlink" title="1 图形推理"></a>1 图形推理</h1><h2 id="图形推理的命题形式"><a href="#图形推理的命题形式" class="headerlink" title="图形推理的命题形式"></a>图形推理的命题形式</h2><ol>
<li>一组图：从左往右读题，找整体规律的共同点。或间隔跳跃观察</li>
<li>两组图：找第一组规律，应用于第二组</li>
<li>九宫格：横行（最多）、数列、对角线观察规律</li>
<li>分组分类：找寻每组统一规律</li>
<li>空间类：折纸盒，转化成平面思维（截面图、三视图、立体拼合）<a id="more"></a>

</li>
</ol>
<h2 id="图形推理考什么？（学习重点：识别图形特征）"><a href="#图形推理考什么？（学习重点：识别图形特征）" class="headerlink" title="图形推理考什么？（学习重点：识别图形特征）"></a>图形推理考什么？（学习重点：识别图形特征）</h2><ol>
<li>位置规律</li>
<li>样式规律</li>
<li>属性规律</li>
<li>特殊规律</li>
<li>数量规律</li>
<li>空间规律</li>
</ol>
<h2 id="一、位置规律"><a href="#一、位置规律" class="headerlink" title="一、位置规律"></a>一、位置规律</h2><h3 id="位置类识别特征（各图元素组成相同）"><a href="#位置类识别特征（各图元素组成相同）" class="headerlink" title="位置类识别特征（各图元素组成相同）"></a>位置类识别特征（各图元素组成相同）</h3><h3 id="（1）平移："><a href="#（1）平移：" class="headerlink" title="（1）平移："></a>（1）平移：</h3><ol>
<li>方向 ：直线（上下、左右、对角线）、绕圈（顺/逆时针）</li>
<li>步数 ：恒定、递增（等差）、周期（考的少）</li>
</ol>
<p><strong>技巧：1.多个元素分开看，边做边排除 2.位置规律——就近走原则</strong></p>
<h3 id="宫格型黑块平移"><a href="#宫格型黑块平移" class="headerlink" title="宫格型黑块平移"></a>宫格型黑块平移</h3><p><strong>1.个别黑块可重合</strong></p>
<ul>
<li>题干和选项大部分元素组成完全一致，个别一两幅图少黑块</li>
<li>题干第一幅图的黑块一般不会重合</li>
</ul>
<p><strong>2.黑块走到头后怎么办？</strong></p>
<ul>
<li>循环走：从头开始</li>
<li>折返走：直接弹回</li>
</ul>
<p><strong>3.“双胞胎”黑块们如何分辨</strong>：就近走原则</p>
<h3 id="多宫格方向判定"><a href="#多宫格方向判定" class="headerlink" title="多宫格方向判定"></a>多宫格方向判定</h3><p>题型特征：16宫格图形多个黑块平移</p>
<ol>
<li>绕圈走：中间颜色数量相同，优先考虑内外圈分开看</li>
<li>走直线：中间颜色数量不同，有限考虑走直线</li>
</ol>
<h3 id="（2）旋转："><a href="#（2）旋转：" class="headerlink" title="（2）旋转："></a>（2）旋转：</h3><ol>
<li>方向：顺时针、逆时针</li>
<li>常见角度：45、60、90、180度等</li>
</ol>
<p><strong>技巧：元素多，没思路？相邻比较走起来！</strong></p>
<p><strong>钟表类：外面一个框，中心一个点，绕了一圈线——常考旋转</strong></p>
<h3 id="（3）翻转"><a href="#（3）翻转" class="headerlink" title="（3）翻转"></a>（3）翻转</h3><ol>
<li>左右翻转：竖轴对称</li>
<li>上下翻转：横轴对称</li>
</ol>
<p><strong>元素组成相同优先看位置：对称通常是图形自身的规律，而不是两幅图之间的翻转</strong></p>
<p><strong>技巧：先看容易看懂的，旋转180度看不出来就转卷子！</strong></p>
<p><strong>如何区分旋转与翻转</strong><br>只有左右互换（上下不变）——左右翻<br>只有上下互换（左右不变）——上下翻<br>上下、左右都互换——旋转180度</p>
<p><strong>思维导图</strong><br><img src="https://note.youdao.com/yws/api/personal/file/CC02E070330340E8880E45623154A7F9?method=download&shareKey=ab0d5ad994f7c4d39f8370b641a8faa8" alt></p>
<h2 id="二、样式规律"><a href="#二、样式规律" class="headerlink" title="二、样式规律"></a>二、样式规律</h2><h3 id="样式类别识别特征：元素组成相似"><a href="#样式类别识别特征：元素组成相似" class="headerlink" title="样式类别识别特征：元素组成相似"></a>样式类别识别特征：元素组成相似</h3><h3 id="（1）加、减、同、异"><a href="#（1）加、减、同、异" class="headerlink" title="（1）加、减、同、异"></a>（1）加、减、同、异</h3><p><strong>识别特征：相同线条重复出现</strong></p>
<ol>
<li>相加、相减</li>
<li>求异（保留不同）</li>
<li>求同（保留相同）</li>
</ol>
<p><strong>技巧：对比选项，从特殊线条入手（横线、竖线、最长最短线）</strong></p>
<p><strong>位置+样式类题目，先转谁呢？  谁搞特殊，先转谁！</strong></p>
<ol>
<li>图1与图2有相同部分——先求同求异再转</li>
<li>图2与图3有相同部分——转图1</li>
<li>图1与图3有想吐部分——转图2</li>
</ol>
<h3 id="（2）黑白运算"><a href="#（2）黑白运算" class="headerlink" title="（2）黑白运算"></a>（2）黑白运算</h3><p><strong>识别特征：图形轮廓和分割区域相同，内部的颜色不同</strong><br><strong>方法：相同位置颜色做加法（注意顺序）</strong></p>
<p><strong>注意：</strong></p>
<ol>
<li>运算规则具体题目具体找</li>
<li>黑+白 不等于 白+黑，要具体题目具体验证</li>
<li>与黑块平移区分：黑块数量相同，优先平移；黑块数量不同，优先黑白运算</li>
</ol>
<p><strong>技巧：在确定可能考黑白运算后，从问好处着手解题更快，边找边验证</strong></p>
<p><strong>思维导图</strong><br><img src="https://note.youdao.com/yws/api/personal/file/96D9D2A1C7614181B52F461B9C1872E7?method=download&shareKey=bb4bd7eaf38467812c12098b8c66fbff" alt></p>
<h2 id="三、属性规律"><a href="#三、属性规律" class="headerlink" title="三、属性规律"></a>三、属性规律</h2><h3 id="属性类别识别特征-元素组成不相同、不相似——优先属性"><a href="#属性类别识别特征-元素组成不相同、不相似——优先属性" class="headerlink" title="属性类别识别特征: 元素组成不相同、不相似——优先属性"></a>属性类别识别特征: 元素组成不相同、不相似——优先属性</h3><h3 id="（1）对称性"><a href="#（1）对称性" class="headerlink" title="（1）对称性"></a>（1）对称性</h3><ol>
<li>轴对称：”等腰”元素出现</li>
<li>中心对称：平行四边形，N,Z,S变形图出现</li>
<li>轴对称+中心对称：图形存在相互垂直的对称轴</li>
<li>对称性的细化考法<ul>
<li>对称轴的方向与数量</li>
<li>对称轴与图形中线的位置关系：重合、垂直、交点</li>
<li>角度：平行、垂直、交叉某角度</li>
</ul>
</li>
</ol>
<p><strong>优先考虑对称轴时，先画出图形对称轴！</strong></p>
<p><strong>技巧：整体没有规律，分开看</strong></p>
<h3 id="（2）曲直性"><a href="#（2）曲直性" class="headerlink" title="（2）曲直性"></a>（2）曲直性</h3><ol>
<li>全直线图形</li>
<li>全曲线图形</li>
<li>曲+直图形</li>
</ol>
<p><strong>常见考法：三种情况均出现；与其他考点结合命题</strong></p>
<p><strong>所有图形均有外框——分开看</strong></p>
<h3 id="（3）开闭性"><a href="#（3）开闭性" class="headerlink" title="（3）开闭性"></a>（3）开闭性</h3><p><strong>题型特征：完整图的图形留了小开口，可以考虑开闭性</strong></p>
<ol>
<li>全封闭图形</li>
<li>全开放图形</li>
<li>半封闭图形</li>
</ol>
<p><strong>黑色粗线条，生活化元素/图形留有小开口——考虑开闭性</strong></p>
<p><strong>思维导图</strong><br><img src="https://note.youdao.com/yws/api/personal/file/F59E60D6989F4394BE9C6BDDDC9887CF?method=download&shareKey=649c8319245813b64168677ca4240c22" alt></p>
<h2 id="四、特殊规律"><a href="#四、特殊规律" class="headerlink" title="四、特殊规律"></a>四、特殊规律</h2><h3 id="（1）图形间关系"><a href="#（1）图形间关系" class="headerlink" title="（1）图形间关系"></a>（1）图形间关系</h3><p><strong>识别特征：两个或多个封闭图形连在一起</strong></p>
<ol>
<li>相离</li>
<li>相交<ul>
<li>相交于点</li>
<li>相交于边（数量、样式：边的长短、整体还是部分）</li>
<li>相较于面（形状）</li>
</ul>
</li>
</ol>
<p><strong>一根线牵出多个图形考虑相交于点，其他考虑相交于边或面</strong></p>
<h3 id="（2）功能元素"><a href="#（2）功能元素" class="headerlink" title="（2）功能元素"></a>（2）功能元素</h3><p><strong>识别特征：黑点、白点、箭头、小图形</strong></p>
<ol>
<li>标记位置（上、下、左、右、内、外）</li>
<li>标记图形<ul>
<li>点：交点</li>
<li>线：直线、曲线 / 最长边、最短边</li>
<li>角：直角、锐角、钝角 / 最大角、最小角</li>
<li>面：相交面 / 最大面、最小面 / 直线面、曲线面 / 特殊形状面</li>
</ul>
</li>
</ol>
<p><strong>思维导图</strong><br><img src="https://note.youdao.com/yws/api/personal/file/84A38B8255CA4301907F28ECCE456AEE?method=download&shareKey=b6b8b1a759af355f000b27566005c2c3" alt></p>
<h2 id="五、数量规律"><a href="#五、数量规律" class="headerlink" title="五、数量规律"></a>五、数量规律</h2><p><strong>识别特征：元素组成不同、不相似、且属性没规律，数量规律明显</strong></p>
<h3 id="（1）面数量"><a href="#（1）面数量" class="headerlink" title="（1）面数量"></a>（1）面数量</h3><p><strong>注意：只有封闭的白色区域才算面</strong><br><strong>识别特征</strong><br><strong>1.图形被分割，封闭面明显</strong><br><strong>2.生活化图形、粗线条图形中留空白区域</strong></p>
<p>面的细化考法：数面特征图，但整体数面无答案</p>
<ol>
<li>面的形状：三角形、四边形</li>
<li>相同面数量</li>
<li>特殊面的形状：最大面、最小面、相交面</li>
</ol>
<h3 id="（2）线数量"><a href="#（2）线数量" class="headerlink" title="（2）线数量"></a>（2）线数量</h3><p><strong>识别特征</strong><br><strong>1.直线数特征图：多边形、单一直线</strong><br><strong>2.曲线数特征图：曲线图形（圆、弧、单一曲线）</strong></p>
<p><strong>直线和曲线分开数</strong></p>
<p><strong>线的细化考法</strong></p>
<ol>
<li>线的位置：边框线条、框内线条</li>
<li>直线的细化：横线/竖线</li>
</ol>
<p><strong>大部分图形题中有曲线，优先考虑曲线规律</strong></p>
<p><strong>3.线的特殊考点：笔画问题</strong><br><strong>识别特征</strong><br><strong>1.五角星、圆相切/相交、“日”变形、“田”变形</strong><br><strong>2.多端点、出头端点、圆相交(近年热点)</strong></p>
<ol>
<li>可以一笔画<ul>
<li>线条之间连通</li>
<li>奇点数量为0或2（奇点：以一个点为中心，发射出奇数条线）</li>
</ul>
</li>
</ol>
<p><strong>端点都是奇点，别忘了数！</strong></p>
<ol start="2">
<li>多笔画<ul>
<li>笔画数 = 奇点数/2 (奇点数一定是偶数)</li>
</ul>
</li>
</ol>
<p><strong>不连通图直接数笔画</strong></p>
<h3 id="（3）点数量"><a href="#（3）点数量" class="headerlink" title="（3）点数量"></a>（3）点数量</h3><p><strong>识别特征</strong><br>1.线条交叉明显（大树杈）<br>2.乱糟糟一团线交叉<br>3.相切较多<br><strong>注意：线与线的交点数量</strong><br>1.顶点、切点是交点<br>2.端点不是交点</p>
<p><strong>点的细化考法：数点特征图，但整体点无规律</strong></p>
<ol>
<li><p>按线的属性细化：曲直交点</p>
<ul>
<li>特征：圆或弧多，且存在曲直相交</li>
</ul>
</li>
<li><p>按线的位置细化：内外交点</p>
<ul>
<li>特征：图形都有外框（内外分开看思维）</li>
</ul>
</li>
</ol>
<h3 id="（4）素数量"><a href="#（4）素数量" class="headerlink" title="（4）素数量"></a>（4）素数量</h3><p><strong>识别特征：独立的小图形</strong></p>
<ol>
<li>元素种类</li>
<li>元素个数</li>
</ol>
<p><strong>形状一致，大小不一致也看作一种元素</strong></p>
<ol start="3">
<li>部分数：连在一起的就是一部分</li>
</ol>
<p><strong>识别特征：生活化图形、黑色粗线条图形</strong></p>
<p><strong>数量规律特征图总汇(按考频排序)</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/56CAC826F4B14DAAB59B45411A39D32E?method=download&shareKey=1d6c6fbe4ab78574d6561879d6ab8f91" alt></p>
<p><strong>思维导图</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/99C081A3826E4102AC4C11414BEA5180?method=download&shareKey=e819a2b5c9eb4b8fa4c807d63b28184a" alt></p>
<h2 id="六、空间规律"><a href="#六、空间规律" class="headerlink" title="六、空间规律"></a>六、空间规律</h2><h3 id="（1）相对面"><a href="#（1）相对面" class="headerlink" title="（1）相对面"></a>（1）相对面</h3><p>应用：一组相对面同时出现的选项排除</p>
<ol>
<li>同行同列相隔一个面</li>
<li>Z字形紧邻中线的两端</li>
</ol>
<p><strong>出题可能会有无中生有的面</strong></p>
<h3 id="（2）相邻面——公共边"><a href="#（2）相邻面——公共边" class="headerlink" title="（2）相邻面——公共边"></a>（2）相邻面——公共边</h3><p><strong>方法1：折叠前后相邻关系保持不变</strong></p>
<ol>
<li>平面图直接相邻的两个面的公共边</li>
<li>平面图中构成直角的两个边是同一条边</li>
<li>一排4个面，两头的两条边是同一条边（1-4-1）</li>
</ol>
<p><strong>方法2：画边法</strong></p>
<ol>
<li>结合选项，找一个特殊面的唯一点<ul>
<li>特殊面：只出现一次，有可以区分的唯一点</li>
<li>唯一点：是指该面中唯一的，没有与其一样的点</li>
</ul>
</li>
<li>顺（逆）时针方向画边，并标出序号</li>
</ol>
<p><strong>注意：同一个面、同一个点、同方向</strong><br>3. 题干与选项对应：面不一致排除</p>
<p><strong>思维导图</strong><br><img src="https://note.youdao.com/yws/api/personal/file/0E167A466553402EB97E034F3FA658C2?method=download&shareKey=0071ee3ee90162d908695fcb5c0c9bc4" alt></p>
<h1 id="2-类比推理"><a href="#2-类比推理" class="headerlink" title="2 类比推理"></a>2 类比推理</h1><h2 id="一、语义关系"><a href="#一、语义关系" class="headerlink" title="一、语义关系"></a>一、语义关系</h2><h3 id="（1）近义关系、反义关系"><a href="#（1）近义关系、反义关系" class="headerlink" title="（1）近义关系、反义关系"></a>（1）近义关系、反义关系</h3><p>如果一级关系（近反义关系）选不出答案——进行二级辨析</p>
<p>常见的二级辨析：感情色彩（褒义、贬义、中性）</p>
<h3 id="（2）比喻义、象征义"><a href="#（2）比喻义、象征义" class="headerlink" title="（2）比喻义、象征义"></a>（2）比喻义、象征义</h3><h2 id="二、逻辑关系"><a href="#二、逻辑关系" class="headerlink" title="二、逻辑关系"></a>二、逻辑关系</h2><h3 id="（1）全同关系"><a href="#（1）全同关系" class="headerlink" title="（1）全同关系"></a>（1）全同关系</h3><h3 id="（2）并列关系"><a href="#（2）并列关系" class="headerlink" title="（2）并列关系"></a>（2）并列关系</h3><ol>
<li>矛盾关系（只有两者）</li>
<li>反对关系（有第三者）</li>
</ol>
<p><strong>并列的细分考点：并列关系+功能相同</strong></p>
<h3 id="（3）包容关系"><a href="#（3）包容关系" class="headerlink" title="（3）包容关系"></a>（3）包容关系</h3><ol>
<li>种属关系</li>
<li>组成关系</li>
</ol>
<p><strong>区分：能用“谁是谁”造句的就是种属关系</strong></p>
<h3 id="（4）交叉关系"><a href="#（4）交叉关系" class="headerlink" title="（4）交叉关系"></a>（4）交叉关系</h3><h3 id="（5）对应关系"><a href="#（5）对应关系" class="headerlink" title="（5）对应关系"></a>（5）对应关系</h3><ol>
<li>材料</li>
<li>工艺</li>
<li>属性</li>
<li>功能（二级辨析：主要功能、次要功能）</li>
<li>时间顺序：多个行为同时出现</li>
</ol>
<p><strong>当出现多个选项符合时间顺序时，考虑动作主体</strong><br>6. 因果关系（方式目的）</p>
<h2 id="三、语法关系"><a href="#三、语法关系" class="headerlink" title="三、语法关系"></a>三、语法关系</h2><h3 id="（1）主谓关系"><a href="#（1）主谓关系" class="headerlink" title="（1）主谓关系"></a>（1）主谓关系</h3><h3 id="（2）动宾关系"><a href="#（2）动宾关系" class="headerlink" title="（2）动宾关系"></a>（2）动宾关系</h3><h3 id="（3）主宾关系"><a href="#（3）主宾关系" class="headerlink" title="（3）主宾关系"></a>（3）主宾关系</h3><h2 id="四、词语拆分"><a href="#四、词语拆分" class="headerlink" title="四、词语拆分"></a>四、词语拆分</h2><h3 id="（1）单字拆分"><a href="#（1）单字拆分" class="headerlink" title="（1）单字拆分"></a>（1）单字拆分</h3><h3 id="（2）成语被拆分"><a href="#（2）成语被拆分" class="headerlink" title="（2）成语被拆分"></a>（2）成语被拆分</h3><h3 id="（3）两组词语之间没有明显逻辑关系"><a href="#（3）两组词语之间没有明显逻辑关系" class="headerlink" title="（3）两组词语之间没有明显逻辑关系"></a>（3）两组词语之间没有明显逻辑关系</h3><h1 id="3-定义判断"><a href="#3-定义判断" class="headerlink" title="3 定义判断"></a>3 定义判断</h1><h2 id="解题思维："><a href="#解题思维：" class="headerlink" title="解题思维："></a>解题思维：</h2><ol>
<li>看提问——看清“属于/符合”,“不属于/不符合”定义等</li>
<li>看题干——识别有效信息：找准关键词、关键句</li>
<li>看选项——纠结时选项对比择优<!-- more -->

</li>
</ol>
<h2 id="一、快速识别有效信息"><a href="#一、快速识别有效信息" class="headerlink" title="一、快速识别有效信息"></a>一、快速识别有效信息</h2><h3 id="（1）关键词——主体、客体"><a href="#（1）关键词——主体、客体" class="headerlink" title="（1）关键词——主体、客体"></a>（1）关键词——主体、客体</h3><ol>
<li>主体——行为、活动的出发者</li>
<li>客体——行为、活动作用的对象</li>
</ol>
<ul>
<li>不是每题一定都有主题和客体，但是出现了要重点看</li>
<li>主客体不符合的选项一定不符合定义</li>
<li>范围越小、越明确的主/客体，越容易成为考点</li>
</ul>
<p><strong>常考主客体：</strong></p>
<ol>
<li>行政机关</li>
<li>全力机关</li>
<li>司法机关</li>
<li>事业单位</li>
<li>社会组织 </li>
</ol>
<h3 id="（2）句式引导词——引导的内容重点看"><a href="#（2）句式引导词——引导的内容重点看" class="headerlink" title="（2）句式引导词——引导的内容重点看"></a>（2）句式引导词——引导的内容重点看</h3><ol>
<li>方式：通过/利用…</li>
<li>目的：以/以达到…</li>
<li>原因：因为/由于…</li>
<li>结果：导致/从而/使得…</li>
<li>时间：当…时/在…情况下</li>
</ol>
<h3 id="（3）优先看到定义所在的那句话的句号和补充说明"><a href="#（3）优先看到定义所在的那句话的句号和补充说明" class="headerlink" title="（3）优先看到定义所在的那句话的句号和补充说明"></a>（3）优先看到定义所在的那句话的句号和补充说明</h3><h3 id="（4）多定义：做题方法与单定义题目一致"><a href="#（4）多定义：做题方法与单定义题目一致" class="headerlink" title="（4）多定义：做题方法与单定义题目一致"></a>（4）多定义：做题方法与单定义题目一致</h3><ol>
<li>问啥看啥：看清题干问的是哪个定义，重点看目标定义</li>
<li>比较定义：纠结两个选项时，再与其他定义比较</li>
</ol>
<h2 id="二、小技巧"><a href="#二、小技巧" class="headerlink" title="二、小技巧"></a>二、小技巧</h2><h3 id="（1）拆词"><a href="#（1）拆词" class="headerlink" title="（1）拆词"></a>（1）拆词</h3><p>从定义本身找信息，如果定义名称有明确的限定语并简单易懂，可利用定义词快速破题</p>
<h3 id="（2）同构选项排除法"><a href="#（2）同构选项排除法" class="headerlink" title="（2）同构选项排除法"></a>（2）同构选项排除法</h3><p>意思相似、结构相似的选项排除</p>
<ol>
<li>题干或下选项能够读不懂</li>
<li>同构选项出现，可以一起排除</li>
<li>同构有风险，使用需谨慎…</li>
</ol>
<h1 id="4-逻辑判断"><a href="#4-逻辑判断" class="headerlink" title="4 逻辑判断"></a>4 逻辑判断</h1><h2 id="一、翻译推理"><a href="#一、翻译推理" class="headerlink" title="一、翻译推理"></a>一、翻译推理</h2><p><strong>题目特征</strong></p>
<ol>
<li>题干和选项中存在明显的逻辑关联词</li>
<li>提问方式为：可以推出/不能推出</li>
</ol>
<p><strong>解题思维</strong></p>
<ol>
<li>先翻译</li>
<li>再推理<!-- more -->

</li>
</ol>
<h3 id="（1）翻译规则之“前-rightarrow-后”"><a href="#（1）翻译规则之“前-rightarrow-后”" class="headerlink" title="（1）翻译规则之“前$\rightarrow$后”"></a>（1）翻译规则之“前$\rightarrow$后”</h3><ol>
<li>若…则</li>
<li>只要..就</li>
<li>所有…都</li>
<li>为了…一定</li>
<li>…是…的充分条件</li>
</ol>
<p>（出现如果/就/都/一定）</p>
<h3 id="（2）推理规则之“逆否等价”"><a href="#（2）推理规则之“逆否等价”" class="headerlink" title="（2）推理规则之“逆否等价”"></a>（2）推理规则之“逆否等价”</h3><p>符号表示：$A\rightarrow B = -B\rightarrow -A$</p>
<p>文字表示:肯前比肯后、否后必否前</p>
<p>否前、肯后无必然结论</p>
<h3 id="（3）翻译规则之“后推前”"><a href="#（3）翻译规则之“后推前”" class="headerlink" title="（3）翻译规则之“后推前”"></a>（3）翻译规则之“后推前”</h3><ol>
<li>只有…才…</li>
<li>不…不…</li>
<li>除非..否则不…</li>
<li>…是…的基础/假设/前提/关键</li>
<li>…是…的必要/必不可少条件</li>
</ol>
<p><strong>“否则不”是一个整体</strong><br>6. 基础/前提/关键;不可缺少/必不可少/必要条件</p>
<p><strong>谁必不可少，谁在箭头后</strong></p>
<p>都遵循递推原则：$A\rightarrow B，B\rightarrow C $可得$A\rightarrow B\rightarrow C$</p>
<h3 id="（4）翻译规则之“且、或”"><a href="#（4）翻译规则之“且、或”" class="headerlink" title="（4）翻译规则之“且、或”"></a>（4）翻译规则之“且、或”</h3><p>A且B：二者同时成立</p>
<ol>
<li>和</li>
<li>并且</li>
<li>即…又…</li>
<li>不仅…而且..</li>
<li>…但是…</li>
</ol>
<p>A或B：二者至少一个成立</p>
<ol>
<li>或者</li>
<li>或者…或者…</li>
<li>至少有一个</li>
</ol>
<h3 id="（5）推理规则之“否一推一”"><a href="#（5）推理规则之“否一推一”" class="headerlink" title="（5）推理规则之“否一推一”"></a>（5）推理规则之“否一推一”</h3><p>“或”的翻译：否1$\rightarrow$1</p>
<p>“或”关系为真，否定一项可以得到另一项</p>
<p>题干中有确定信息，可由确定信息出发，排除法做题</p>
<h3 id="（6）推理规则之“德-摩根定律”"><a href="#（6）推理规则之“德-摩根定律”" class="headerlink" title="（6）推理规则之“德*摩根定律”"></a>（6）推理规则之“德*摩根定律”</h3><ol>
<li>-(A且B) = -A或-B</li>
<li>-(A或B) = -A且-B</li>
</ol>
<p>“且”关系常考考点：缺一不可</p>
<p>A$\rightarrow$B且C，可以得到：-B$\rightarrow$-A/-C$\rightarrow$-A</p>
<h3 id="（7）推理方式"><a href="#（7）推理方式" class="headerlink" title="（7）推理方式"></a>（7）推理方式</h3><p>提问方式：</p>
<p>一下哪项中的推理方式/结构与题干中的推理方式/结构相同</p>
<p>重结构、轻内容——字母代入做题</p>
<p>不考虑推理是否正确，只考虑与题干是否一致</p>
<h2 id="二、组合排列"><a href="#二、组合排列" class="headerlink" title="二、组合排列"></a>二、组合排列</h2><ol>
<li>两组及以上对象</li>
<li>对象之间的关系</li>
</ol>
<h3 id="（1）排除法、代入法"><a href="#（1）排除法、代入法" class="headerlink" title="（1）排除法、代入法"></a>（1）排除法、代入法</h3><ol>
<li>排除法：读一句，排一句<ul>
<li>快速找到“谁”是“谁”</li>
<li>快速确定“谁”不是“谁”</li>
</ul>
</li>
</ol>
<p>组合排列常用思维——谁一定不是谁</p>
<ol start="2">
<li>代入法：假设选项正确，代入题干验证是否符合题意<ul>
<li>题干条件确定优先排除；题干条件不确定代入                                      </li>
<li>设问中有“可能”、“不可能”考虑代入<br>只猜中一半（一对一错）——混搭来破题</li>
</ul>
</li>
</ol>
<h3 id="（2）辅助技巧"><a href="#（2）辅助技巧" class="headerlink" title="（2）辅助技巧"></a>（2）辅助技巧</h3><ol>
<li>最大信息（题干条件中出现次数最多的信息）<br>以此作为推理起点</li>
<li>符号：”&gt;”、“&lt;”、“=”<br>往往涉及年龄、成绩、收入、身高等大小比较</li>
</ol>
<p>比较大小技巧——极值做排除</p>
<ol start="3">
<li>画表格（4个及以上信息）<br>先填入确定信息</li>
</ol>
<h3 id="3-特殊题型——材料题"><a href="#3-特殊题型——材料题" class="headerlink" title="(3) 特殊题型——材料题"></a>(3) 特殊题型——材料题</h3><ol>
<li>与非材料题解题方式一致——一则材料、多种技巧</li>
<li>通过材料直接推出来的结论可以直接应用于所有题目</li>
</ol>
<p>当且仅当表示充要条件，即A$\rightarrow$B，且B$\rightarrow$A</p>
<h2 id="三、逻辑论证"><a href="#三、逻辑论证" class="headerlink" title="三、逻辑论证"></a>三、逻辑论证</h2><h3 id="（1）削弱之否定论点"><a href="#（1）削弱之否定论点" class="headerlink" title="（1）削弱之否定论点"></a>（1）削弱之否定论点</h3><p>选题特征：与论点表述意思相反</p>
<p>文段特征：</p>
<ol>
<li>文段只有论点，无论据</li>
<li>文段的论点和论据话题一致</li>
</ol>
<h3 id="（2）削弱之拆桥"><a href="#（2）削弱之拆桥" class="headerlink" title="（2）削弱之拆桥"></a>（2）削弱之拆桥</h3><p>论点与论据之间没有必然联系</p>
<p>题型特质：</p>
<ol>
<li>论点和论据的话题不一致</li>
<li>提问方式为“削弱论证”</li>
<li>没有否论点的选项</li>
</ol>
<h3 id="（3）削弱之否定论据"><a href="#（3）削弱之否定论据" class="headerlink" title="（3）削弱之否定论据"></a>（3）削弱之否定论据</h3><p>题型特征：</p>
<ol>
<li>题干中支持方，反对方观点相反</li>
<li>题干中存在论点、论据，但无否论点和拆桥选项</li>
</ol>
<p>选项特征：与论据表述的意思相反</p>
<h3 id="（4）削弱之因果倒置和他因削弱"><a href="#（4）削弱之因果倒置和他因削弱" class="headerlink" title="（4）削弱之因果倒置和他因削弱"></a>（4）削弱之因果倒置和他因削弱</h3><p>题干特征：论点具有因果关系<br>选项特征：</p>
<ol>
<li>因果倒置：将论点中的因果关系顺序颠倒</li>
<li>他因削弱：在原来1的基础上，选项增加另一个同时存在的原因2也能导致相同的结果，削弱的是原来原因的重要性或唯一性</li>
</ol>
<h3 id="（5）加强之补充论据"><a href="#（5）加强之补充论据" class="headerlink" title="（5）加强之补充论据"></a>（5）加强之补充论据</h3><ol>
<li>解释原因：说明论点成立的原因</li>
<li>举例支持：证明论点成立的例子</li>
</ol>
<h3 id="（6）加强之搭桥"><a href="#（6）加强之搭桥" class="headerlink" title="（6）加强之搭桥"></a>（6）加强之搭桥</h3><p>题型特征：</p>
<ol>
<li>论点论据话题不一致</li>
<li>提问方式为前提、假设、必要条件、论证，优先考虑搭桥 </li>
</ol>
<h3 id="（7）加强之必要条件"><a href="#（7）加强之必要条件" class="headerlink" title="（7）加强之必要条件"></a>（7）加强之必要条件</h3><p>必要条件：选项为论点成立的必要条件</p>
]]></content>
      <categories>
        <category>行测笔试</category>
      </categories>
      <tags>
        <tag>行测笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>行测笔记（三）：资料分析与数量关系</title>
    <url>/2020/07/23/xingce3/</url>
    <content><![CDATA[<h1 id="1-资料分析"><a href="#1-资料分析" class="headerlink" title="1 资料分析"></a>1 资料分析</h1><h2 id="一、速算技巧"><a href="#一、速算技巧" class="headerlink" title="一、速算技巧"></a>一、速算技巧</h2><p>（1）截位直除</p>
<p>截位，看下一位，四舍五入</p>
<ul>
<li>一步除法，建议只截分母($\frac{36225}{81245}$)</li>
<li>多步除法，截分子，分母（$\frac{1421}{8041}*\frac{1521}{9023}$）<a id="more"></a>

</li>
</ul>
<p>一般情况下，截两位计算快，截三位计算准</p>
<p>看最接近选项差距</p>
<p>差距大，截两位</p>
<ol>
<li>首位都不同</li>
<li>首位有相同，第二位差值&gt;首位</li>
</ol>
<p>差距小，截三位</p>
<ol>
<li>首位有相同，第二位差值=首位</li>
<li>首位有相同，第二位差值&lt;首位</li>
</ol>
<p>若选项之间存在约10、100倍的关系时</p>
<ol>
<li>截两位</li>
<li>保留量级</li>
</ol>
<p>（2）分数比较</p>
<p>一大一小（$\frac{25}{8}$,$\frac{36}{5}$）分子大，分数大</p>
<p>同达同小（\frac{27}{8}，$\frac{9}{4}$）</p>
<p>纵向用直除，横向看倍数（谁大谁留下，小的看成1）</p>
<p>直除看首位</p>
<h2 id="二、阅读材料"><a href="#二、阅读材料" class="headerlink" title="二、阅读材料"></a>二、阅读材料</h2><p>（1）纯文字材料</p>
<p>特点：数据多，相近词多</p>
<p>方法：结构阅读</p>
<ol>
<li>总分结构</li>
<li>10秒内每段画出1-2个与众不同的关键词</li>
</ol>
<p>（2）图表材料</p>
<p>特点：类型多，有陷阱</p>
<p>方法：</p>
<ol>
<li>看表头三要素（时间、主体、单位）</li>
<li>有注释一定要看注释</li>
</ol>
<p>（3）综合材料</p>
<p>方法：</p>
<ol>
<li>个看个的</li>
<li>找文字与图表之间的区别</li>
</ol>
<h2 id="三、基期与现期"><a href="#三、基期与现期" class="headerlink" title="三、基期与现期"></a>三、基期与现期</h2><p>时间靠前的为基期，时间靠后的为现期</p>
<p>（1）$基期=现期-增长量$</p>
<p>精确加减计算，用尾数法，末一位相同，看末两位</p>
<p>（2）$基期=\frac{基期}{1+r}$</p>
<p>（3）同比与环比</p>
<p>同比看头，环比看尾</p>
<p>2020年（头）5月（尾），同比与2019年5月相比，环比2020年4月相比</p>
<p>（4）化除为乘</p>
<p>应用环境：求基期，差距小$|r|&lt;=5%$</p>
<p>$$\frac{A}{1+r}\approx A*(1-r)$$</p>
<p>$$\frac{A}{1-r}\approx A*(1+r)$$</p>
<p>操作：变号-去百分号-估算乘法</p>
<p>（5）基期差值</p>
<p>$$\frac{A}{1+a}-\frac{B}{1+b}分母同号，考计算或分析$$</p>
<p>$$\frac{A}{1+a}-\frac{B}{1-b}分母异号，考分析$$</p>
<ol>
<li>先计算现期坑，排除</li>
<li>再看大小关系，选择</li>
</ol>
<h2 id="四、一般增长率"><a href="#四、一般增长率" class="headerlink" title="四、一般增长率"></a>四、一般增长率</h2><p>（1）基本术语</p>
<ul>
<li>增长率与倍数</li>
</ul>
<p>倍数：指两数的直接比值</p>
<p>增长率：比基数多出的比率</p>
<p>两者联系：$是几倍=增长率+1$</p>
<ul>
<li>番数</li>
</ul>
<p>于番数，化倍数，翻$N$番，变为原来的$2^N$倍</p>
<p>（2）计算</p>
<ol>
<li>给百分点型，高减低加</li>
<li>给具体量型，套公式</li>
</ol>
<p>已知：现期、基期</p>
<ol>
<li>增长率：$r=\frac{增长量}{基期}$</li>
<li>多个年份增长率$&gt;10%$：$现期&gt;1.1基期$</li>
</ol>
<p>（3）增长率的比较</p>
<ol>
<li>按照公式</li>
<li>看现期和基期倍数关系是否明显</li>
</ol>
<p>当现期与基期的比值小于2，则用公式</p>
<p>如果现期与基期的比值大于2，则直接比现期与基期</p>
<h2 id="五、增长量"><a href="#五、增长量" class="headerlink" title="五、增长量"></a>五、增长量</h2><p>识别：增长+单位（绝对量）</p>
<p>（1）增长量的计算</p>
<ol>
<li>已知：现期、基期</li>
<li>年均增长量</li>
<li>已知：现期、增长率</li>
</ol>
<p>公式：$增长量=\frac{现期}{1+r}*r$</p>
<p>第一步：$|r|=1/N$</p>
<p>第二步：$增长量=现期/（N+1）$，$减少量=现期/（N-1）$</p>
<p>百分数转换常用分数：</p>
<ol>
<li>常用分数”1-5“</li>
<li>记住“7-12“，加和（整数部分+分母=20）</li>
<li>记住（16，6）和（14，7）互换的两对</li>
<li>（17，18，19）记住5.963</li>
<li>记住6.7%=$\frac{1}{15}$</li>
</ol>
<p>（2）增长量的比较</p>
<p>大大则大，一大一小白分化</p>
<h2 id="六、比重"><a href="#六、比重" class="headerlink" title="六、比重"></a>六、比重</h2><p>关键字：占</p>
<p>（1）现期比重</p>
<p>识别：现在+占</p>
<p>公式：</p>
<ol>
<li>比重=部分/总体</li>
<li>部分=总体*比重</li>
<li>总体=部分/比重</li>
</ol>
<p>特殊表示：</p>
<ol>
<li>利润率=利润/收入</li>
<li>增长贡献率=部分增长量/总体增长量</li>
</ol>
<p>饼状图：</p>
<ol>
<li>有总体：看比例</li>
<li>无总体：先看大小，再看比例</li>
</ol>
<p>（2）基期</p>
<p>识别：过去+占</p>
<p>公式：</p>
<p>基期比重=A/B * (1+b)/(1+a)</p>
<p>速算：截位值除A/B</p>
<p>根据后面分式与1的关系，结合选项判断</p>
<p>（3）两期</p>
<ul>
<li>比较，观察分子分母的增长率</li>
<li>计算，算判断升降再计算</li>
</ul>
<h2 id="七、平均数"><a href="#七、平均数" class="headerlink" title="七、平均数"></a>七、平均数</h2><p>（1）现期：</p>
<p>识别：现在+均/每/单位</p>
<p>（2）基期</p>
<p>识别：过去+均/每/单位</p>
<p>公式：</p>
<p>基期平均数=A/B * (1+b)/(1+a)</p>
<p>速算：截位值除A/B</p>
<p>根据后面分式与1的关系，结合选项判断</p>
<p>（3）两期</p>
<ul>
<li>比较，观察分子分母的增长率</li>
<li>计算，算判断升降再计算</li>
</ul>
<h2 id="八、倍数"><a href="#八、倍数" class="headerlink" title="八、倍数"></a>八、倍数</h2><p>（1）现期</p>
<p>（2）基期</p>
<h2 id="九、间隔增长率"><a href="#九、间隔增长率" class="headerlink" title="九、间隔增长率"></a>九、间隔增长率</h2><p>公式：和+积</p>
<p>速算：</p>
<p>第一步，先算加和（分析选项是否是唯一值）</p>
<p>第二步，再算乘积，若$r_1,r_2$均小于10%时，则乘积可以忽略</p>
]]></content>
      <categories>
        <category>行测笔试</category>
      </categories>
      <tags>
        <tag>行测笔试</tag>
      </tags>
  </entry>
</search>
