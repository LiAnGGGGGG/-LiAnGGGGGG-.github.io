<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiAnG&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liangggggg.github.io/"/>
  <updated>2020-09-04T07:42:21.782Z</updated>
  <id>https://liangggggg.github.io/</id>
  
  <author>
    <name>LiAnG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法学习笔记（一）递归</title>
    <link href="https://liangggggg.github.io/2020/09/03/algorithm/"/>
    <id>https://liangggggg.github.io/2020/09/03/algorithm/</id>
    <published>2020-09-03T01:47:42.000Z</published>
    <updated>2020-09-04T07:42:21.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-递归的概念"><a href="#1-递归的概念" class="headerlink" title="1 递归的概念"></a>1 递归的概念</h1><ul><li>一个函数调用其自身</li></ul><p><strong>求N！的递归函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int F(int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if (n&#x3D;&#x3D;0)</span><br><span class="line">return 1;</span><br><span class="line">else </span><br><span class="line">return n*F(n-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归和普通函数调用一样是通过栈实现的</p><a id="more"></a><h1 id="2-递归的作用"><a href="#2-递归的作用" class="headerlink" title="2 递归的作用"></a>2 递归的作用</h1><ol><li>替代多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解为更小规模子问题进行求解</li></ol><p><strong>汉诺塔问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Hanoi(n,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Hanoi(int n , char src, char mid, char dest)</span><br><span class="line">&#x2F;&#x2F;将src座上的n个盘子，以mid座为中转，移动到dest座</span><br><span class="line">&#123;</span><br><span class="line">if(n&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;只需要移动一个盘子</span><br><span class="line">cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dext&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;直接将盘子从src移动到dest即可</span><br><span class="line">return; &#x2F;&#x2F;递归终止</span><br><span class="line">&#125;</span><br><span class="line">Hanoi(n-1,src,dest,mid) &#x2F;&#x2F;先将n-1个盘子从src移动到mid</span><br><span class="line">cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;再将盘子从src移动到dest</span><br><span class="line">Hanoi(n-1,mid,src,dest);&#x2F;&#x2F;最后将N-1个盘子从Mid移动到dest</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>N皇后</strong></p><p>n皇后问题：输入整数n，要求n个国际象棋的皇后，摆在n*n的棋盘上，相互不能攻击，输出全部方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int N;</span><br><span class="line">int queenPos[100];</span><br><span class="line">&#x2F;&#x2F;用来存放算好的皇后位置，最左上角是（0，0）</span><br><span class="line">void NQueen(int k);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt;N;</span><br><span class="line">NQueen(0);&#x2F;&#x2F;从0行开始摆皇后</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NQueen(int k)&#123; &#x2F;&#x2F;在0~k-1行皇后已经摆好的情况下，摆第k行及其后的皇后</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">if(k&#x3D;&#x3D;N)&#123;&#x2F;&#x2F; N个皇后已经摆好</span><br><span class="line">for(i&#x3D;0; i&lt;N; i++)</span><br><span class="line">cout &lt;&lt; queenPos[i]+1 &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;0; i&lt;N; i++)&#123; &#x2F;&#x2F;逐尝试第k个皇后的位置</span><br><span class="line">int j;</span><br><span class="line">for(j&#x3D;0; j&lt;k ; j++)&#123;</span><br><span class="line">&#x2F;&#x2F;和已经摆好的k各皇后的位置比较，看是否冲突</span><br><span class="line">if(queenPos[j]&#x3D;&#x3D;i || abs(queenPos[j]-1)&#x3D;&#x3D; abs(k-j))&#123;</span><br><span class="line">break; &#x2F;&#x2F;冲突，则试下一个位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(j&#x3D;&#x3D;k)&#123;</span><br><span class="line">queenPos[k]&#x3D;i; &#x2F;&#x2F;将第k个皇后摆放在位置i</span><br><span class="line">NQueen(k+1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-递归的概念&quot;&gt;&lt;a href=&quot;#1-递归的概念&quot; class=&quot;headerlink&quot; title=&quot;1 递归的概念&quot;&gt;&lt;/a&gt;1 递归的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个函数调用其自身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;求N！的递归函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int F(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (n&amp;#x3D;&amp;#x3D;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return n*F(n-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;递归和普通函数调用一样是通过栈实现的&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://liangggggg.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://liangggggg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库与SQL知识总结</title>
    <link href="https://liangggggg.github.io/2020/08/29/DB/"/>
    <id>https://liangggggg.github.io/2020/08/29/DB/</id>
    <published>2020-08-29T02:20:59.000Z</published>
    <updated>2020-08-29T10:28:41.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常见问题总结"><a href="#1-常见问题总结" class="headerlink" title="1 常见问题总结"></a>1 常见问题总结</h2><h2 id="1-1-什么是MySQL"><a href="#1-1-什么是MySQL" class="headerlink" title="1.1 什么是MySQL"></a>1.1 什么是MySQL</h2><p>MySQL是一种关系型数据库，默认端口号是33006，默认的存储引擎是InnoDB，只有InnoDB是事务性存储引擎</p><p><strong>MyISAM和InnoDB区别</strong></p><p>MyISAM是MySQL的默认数据引擎（5.5版之前）虽然性能极佳，但是不支持事务和行级锁，却最大的缺陷就是崩溃后无法安全恢复，在5.5版之后，MySQL就引入了InnoDB(事务性数据库引擎)</p><a id="more"></a><p><strong>两者对比</strong></p><ol><li>是否支持行级锁</li><li>是否支持事务和崩溃后的安全恢复</li><li>是否支持外键</li><li>是否支持MVCC</li></ol><p><strong>字符集和校对规则</strong></p><p>字符集指的是一种从二进制编码到某类字符符号的映射，校对规则是指某种字符集下的排序规则</p><p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承</p><p><strong>索引</strong></p><p>MySQL索引使用的数据结构主要有BTree索引和哈希索引，对哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单挑记录查询的时候，可以选择哈希索引，查询性能最快，其余大部分场景，建议选择BTree索引</p><p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的</p><ul><li>MyISAM：B+树叶结点的data域存放的是数据记录地址，在检索索引的时候，先按照B+树搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，被称为非聚簇索引</li><li>InnoDB：其数据本身就是索引文件，索引文件和数据文件是分离的，其表数据文件本身就是按B+树组织的一个索引结构，树的叶结点data域保存了完整的数据记录，这个索引key时数据表的主键，因此InonoDB表数据文件本身就是主索引。这被称为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。</li></ul><p>在根据主索引搜索时，直到找到key所在的结点即取出数据，在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引，因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非常单调的字段作为主键，这样会造成主索引频繁分裂</p><h2 id="1-2-什么是事务？"><a href="#1-2-什么是事务？" class="headerlink" title="1.2 什么是事务？"></a>1.2 什么是事务？</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><p>事务的四大特性（ACID）</p><ol><li>原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li><li>一致性（Consistency）：执行事务前后，数据保持一致，多个事务对统一数据读取的结果是相同的</li><li>隔离性（IsoIation）：并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库时独立的</li><li>持久性（Durability）：一个事务被提交之后。对数据库中数据的改变是永久的，即使数据库发送故障也不应该对齐有任何影响</li></ol><p><strong>并发事务带来哪些问题？</strong></p><ul><li>脏度（Dirty read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到这个数据是“脏数据”，依据“脏”数据所做的操作可能是不正确的</li><li>丢失修改（Lost to modify）：指一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失</li><li>不可重复读（Unrepeatableread）：指一个事务内多次读同一个数据，这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，就发生了在一个事务内两次读到的数据是不一样的情况</li><li>幻读（Phantom read）：幻读与不可重复读类似，它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录</li></ul><p><strong>不可重复读和幻读的区别</strong></p><p>不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，比如多读取一条记录发现记录增多或减少了</p><p><strong>事务隔离级别有哪些？MySQL的默认隔离级别是？</strong></p><p>SQL标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED（读取未提交）：最低的隔离界别，允许读取尚未提交的数据，可能会导致脏度，幻读，不可重复读</li><li>READ-COMMITTED（读取已提交）：允许读取并发事务已提交的数据，可以阻止脏度，但是幻读和不可重复读还是有可能发生</li><li>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据被本身事务自己所修改，可以阻止脏度和不可重复读，但幻读仍有可能发生</li><li>SERIALIZABLE（可串行化）：最高的隔离级别，完全俯冲ACID的隔离级别，所有事务依次逐个执行</li></ul><p>注意：与SQL标准不同的地方在于InnoDB存储引擎在<strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的Next-key Lock锁算法，因此可以避免幻读的产生。已经可以完全保证了事务的隔离性要求</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别</p><p><strong>锁机制与InnoDB锁算法</strong></p><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁</li><li>InnoDB支持行级锁和表级锁，默认为行级锁</li></ul><p><strong>表级锁和行级锁对比：</strong></p><ul><li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗较少，不会出现死锁，但出发锁冲突的概率最高，并发度最低</li><li>行级锁：MySQL中粒度最小的一种锁，只针对当前的行进行加锁，行级锁能大大减少数据库操作的冲突，其并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><p><strong>大表优化</strong></p><p>当MySQL单表记录过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li>限定数据的范围</li><li>读/写分离</li><li>垂直分区：根据数据库里数据表的相关性进行拆分，把一张列比较多的表拆分为多张表</li><li>水平分区：数据表行的拆分</li></ol><p><strong>池化设计思想，什么是数据库连接池？为什么需要数据库连接池？</strong></p><p>数据库连接本质是一个socket连接，数据库服务端还要维护一些缓存和用户权限信息之类的，可以把数据库连接池看作是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，即昂贵又浪费资源。在连接池中，创建链接后，将其放置池中，并再次使用它，因此不必建立新的连接，如果使用了所有连接，则建立一个新连接并将其添加到池中。</p><h1 id="2-MySQL与SQL常用操作命令"><a href="#2-MySQL与SQL常用操作命令" class="headerlink" title="2 MySQL与SQL常用操作命令"></a>2 MySQL与SQL常用操作命令</h1><h2 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Windows服务 *&#x2F;</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath&#x3D; mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">&#x2F;* 连接与断开服务器 *&#x2F;</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure><h2 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据库操作 *&#x2F; ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure><h2 id="2-3-表的操作"><a href="#2-3-表的操作" class="headerlink" title="2.3 表的操作"></a>2.3 表的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET &#x3D; charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE &#x3D; engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory&#x2F;Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    AUTO_INCREMENT &#x3D; 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT &#x3D; &#39;string&#39;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &#39;pattern&#39;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表结构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 &#x2F; DESCRIBE 表名 &#x2F; EXPLAIN 表名 &#x2F; SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE&#x3D;MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="2-4-数据操作"><a href="#2-4-数据操作" class="headerlink" title="2.4 数据操作"></a>2.4 数据操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据操作 *&#x2F; ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名&#x3D;值[, 字段名&#x3D;值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名&#x3D;新值[, 字段名&#x3D;新值] [更新条件]</span><br></pre></td></tr></table></figure><h2 id="2-5-字符集编码"><a href="#2-5-字符集编码" class="headerlink" title="2.5 字符集编码"></a>2.5 字符集编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 字符集编码 *&#x2F; ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 &#x3D; 变量值</span><br><span class="line">    SET character_set_client &#x3D; gbk;</span><br><span class="line">    SET character_set_results &#x3D; gbk;</span><br><span class="line">    SET character_set_connection &#x3D; gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]&#x2F;SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure><h2 id="2-6-数据类型（列类型）"><a href="#2-6-数据类型（列类型）" class="headerlink" title="2.6 数据类型（列类型）"></a>2.6 数据类型（列类型）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据类型（列类型） *&#x2F; ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2&#x3D;65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset&#x3D;utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)&#x2F;3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );</span><br><span class="line">    insert into tab values (&#39;男, 女&#39;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure><h2 id="2-7-列属性（列约束）"><a href="#2-7-列属性（列约束）" class="headerlink" title="2.7 列属性（列约束）"></a>2.7 列属性（列约束）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 列属性（列约束） *&#x2F; ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &#39;val&#39;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment &#x3D; x进行设置，或 alter table tbl auto_increment &#x3D; x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &#39;注释内容&#39;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint &#96;t1_t2_fk&#96; foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure><h2 id="2-8-建表规范"><a href="#2-8-建表规范" class="headerlink" title="2.8 建表规范"></a>2.8 建表规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 建表规范 *&#x2F; ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure><h2 id="2-9-SELECT"><a href="#2-9-SELECT" class="headerlink" title="2.9 SELECT"></a>2.9 SELECT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SELECT *&#x2F; ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            &#x3D;, &lt;&#x3D;&gt;, &lt;&gt;, !&#x3D;, &lt;&#x3D;, &lt;, &gt;&#x3D;, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is&#x2F;is not 加上ture&#x2F;false&#x2F;unknown，检验某个值的真假</span><br><span class="line">            &lt;&#x3D;&gt;与&lt;&gt;功能相同，&lt;&#x3D;&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段&#x2F;别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段&#x2F;别名 排序方式 [,排序字段&#x2F;别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure><h2 id="2-10-UNION"><a href="#2-10-UNION" class="headerlink" title="2.10 UNION"></a>2.10 UNION</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* UNION *&#x2F; ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure><h2 id="2-11-子查询"><a href="#2-11-子查询" class="headerlink" title="2.11 子查询"></a>2.11 子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 子查询 *&#x2F; ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money &#x3D; (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    !&#x3D; all()    相当于 not in</span><br><span class="line">    &#x3D; some()    相当于 in。any 是 some 的别名</span><br><span class="line">    !&#x3D; some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure><h2 id="2-12-连接查询-join"><a href="#2-12-连接查询-join" class="headerlink" title="2.12 连接查询(join)"></a>2.12 连接查询(join)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 连接查询(join) *&#x2F; ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num &#x3D; extra_info.stu_id;</span><br></pre></td></tr></table></figure><h2 id="2-13-TRUNCATE"><a href="#2-13-TRUNCATE" class="headerlink" title="2.13 TRUNCATE"></a>2.13 TRUNCATE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* TRUNCATE *&#x2F; ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure><h2 id="2-14-备份与还原"><a href="#2-14-备份与还原" class="headerlink" title="2.14 备份与还原"></a>2.14 备份与还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 备份与还原 *&#x2F; ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure><h2 id="2-15-视图"><a href="#2-15-视图" class="headerlink" title="2.15 视图"></a>2.15 视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure><h2 id="2-16-事务"><a href="#2-16-事务" class="headerlink" title="2.16 事务"></a>2.16 事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据完整性方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit &#x3D; 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure><h2 id="2-17-锁表"><a href="#2-17-锁表" class="headerlink" title="2.17 锁表"></a>2.17 锁表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 锁表 *&#x2F;</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure><h2 id="2-18-触发器"><a href="#2-18-触发器" class="headerlink" title="2.18 触发器"></a>2.18 触发器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 触发器 *&#x2F; ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure><h2 id="2-19-SQL编程"><a href="#2-19-SQL编程" class="headerlink" title="2.19 SQL编程"></a>2.19 SQL编程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SQL编程 *&#x2F; ------------------</span><br><span class="line">--&#x2F;&#x2F; 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--&#x2F;&#x2F; 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var &#x3D; value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免&#x3D;被当作关系运算符看待，使用:&#x3D;代替。（set语句可以使用&#x3D; 和 :&#x3D;）。</span><br><span class="line">select @var:&#x3D;20;</span><br><span class="line">select @v1:&#x3D;id, @v2&#x3D;name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:&#x3D;30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var&#x3D;10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--&#x2F;&#x2F; 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--&#x2F;&#x2F; 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) &#x3D; 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) &#x3D; 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) &#x3D; 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) &#x3D; 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3&#x3D;1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分</span><br><span class="line">time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分</span><br><span class="line">date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--&#x2F;&#x2F; 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &#39;partten&#39;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--&#x2F;&#x2F; 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure><h2 id="2-10-存储过程"><a href="#2-10-存储过程" class="headerlink" title="2.10 存储过程"></a>2.10 存储过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 存储过程 *&#x2F; ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="2-11-用户和权限管理"><a href="#2-11-用户和权限管理" class="headerlink" title="2.11 用户和权限管理"></a>2.11 用户和权限管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用户和权限管理 *&#x2F; ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE &#96;user&#96; SET PASSWORD&#x3D;PASSWORD(&quot;密码&quot;) WHERE &#96;user&#96; &#x3D; &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 &#x3D; PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限&#x2F;添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON &#96;pms&#96;.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure><h2 id="2-12-表维护"><a href="#2-12-表维护" class="headerlink" title="2.12 表维护"></a>2.12 表维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 表维护 *&#x2F;</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="2-13-杂项"><a href="#2-13-杂项" class="headerlink" title="2.13 杂项"></a>2.13 杂项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 杂项 *&#x2F; ------------------</span><br><span class="line">1. 可用反引号（&#96;）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 &#x2F;* 注释内容 *&#x2F;</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#39;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-常见问题总结&quot;&gt;&lt;a href=&quot;#1-常见问题总结&quot; class=&quot;headerlink&quot; title=&quot;1 常见问题总结&quot;&gt;&lt;/a&gt;1 常见问题总结&lt;/h2&gt;&lt;h2 id=&quot;1-1-什么是MySQL&quot;&gt;&lt;a href=&quot;#1-1-什么是MySQL&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是MySQL&quot;&gt;&lt;/a&gt;1.1 什么是MySQL&lt;/h2&gt;&lt;p&gt;MySQL是一种关系型数据库，默认端口号是33006，默认的存储引擎是InnoDB，只有InnoDB是事务性存储引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM和InnoDB区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM是MySQL的默认数据引擎（5.5版之前）虽然性能极佳，但是不支持事务和行级锁，却最大的缺陷就是崩溃后无法安全恢复，在5.5版之后，MySQL就引入了InnoDB(事务性数据库引擎)&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux知识点总结</title>
    <link href="https://liangggggg.github.io/2020/08/29/linux/"/>
    <id>https://liangggggg.github.io/2020/08/29/linux/</id>
    <published>2020-08-29T00:20:59.000Z</published>
    <updated>2020-08-29T01:16:00.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux文件类型"><a href="#1-Linux文件类型" class="headerlink" title="1 Linux文件类型"></a>1 Linux文件类型</h1><p>Linux支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字等</p><ul><li>普通文件</li><li>目录文件(d, directory file)</li><li>符号链接文件(l, symbolic link)：保留了指向文件的地址而不是文件本身</li><li>字符设备(c, char)：用来访问字符设备比如硬盘</li><li>设备文件(b,block)：用来访问设备比如硬盘、软盘</li><li>管道文件(p,pipe)：用于进程之间的通信</li><li>套接字(s,socket)：进程间网络通信，也可以用于本机之间的非网络通信<a id="more"></a></li></ul><h1 id="2-Linux目录树"><a href="#2-Linux目录树" class="headerlink" title="2 Linux目录树"></a>2 Linux目录树</h1><p>Linux的目录结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/0C7AA0164FE549559D468081C86A2731?method=download&shareKey=f44a7c3f8e85e2be6d1b8beeb0d25216" alt></p><p>常用目录说明：</p><ul><li><code>/bin</code>：存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里</li><li><code>/etc</code>：存放系统管理和配置文件</li><li><code>/home</code>：存放所有用户文件的根目录，是用户目录的基点</li><li><code>/usr</code>：用于存放系统应用程序</li><li><code>/opt</code>：额外安装的可选应用程序包所放置的位置</li><li><code>/proc</code>：虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息</li><li><code>/root</code>：超级用户（系统管理员）的主目录</li><li><code>/sbin</code>：存放二进制可执行文件，只有root才能访问，系统级别的管理命令和程序</li><li><code>/dev</code>：用于存放设备文件</li><li><code>/mnt</code>：系统管理员安装临时文件系统的安装点</li><li><code>/boot</code>：存放用于系统引导时使用的各种文件</li><li><code>/lib</code>：存放着和系统运行相关的库文件</li><li><code>/tmp</code>：用于存放各种临时文件</li><li><code>/var</code>：用于存放运行时需要改变数据的文件，比如各服务的日志文件</li><li><code>/lost+found</code>：系统非正常关机而留下的文件</li></ul><h1 id="3-Linux基本命令"><a href="#3-Linux基本命令" class="headerlink" title="3 Linux基本命令"></a>3 Linux基本命令</h1><p>Linux 命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h2 id="3-1-目录切换命令"><a href="#3-1-目录切换命令" class="headerlink" title="3.1 目录切换命令"></a>3.1 目录切换命令</h2><ul><li><code>cd usr</code>：切换到该目录下的usr目录</li><li><code>cd ..</code>：切换到上一层目录</li><li><code>cd /</code>：切换到系统根目录</li><li><code>cd ~</code>：切换到用户主目录</li><li><code>cd -</code>：切换到上一个操作所在目录</li></ul><h2 id="3-2-目录的操作命令（增删改查）"><a href="#3-2-目录的操作命令（增删改查）" class="headerlink" title="3.2 目录的操作命令（增删改查）"></a>3.2 目录的操作命令（增删改查）</h2><ul><li><code>mkdir</code> 目录名称：增加目录</li><li><code>ls/ll（ll是 ls -l的别名，可以查看该目录下的所有目录文件的详细信息）</code>：查看目录信息</li><li><code>find 目录 参数</code>：找到目录</li><li><code>mv 目录：新目录名称</code>：修改目录的名称</li><li><code>mu 目录名称 新目录名称</code>：修改目录的位置（剪切）</li><li><code>cp -r 目录名称 目录拷贝的目标位置</code>：拷贝目录</li><li><code>rm [-rf] 目录</code>：目录删除</li></ul><h2 id="3-3-文件的操作命令"><a href="#3-3-文件的操作命令" class="headerlink" title="3.3 文件的操作命令"></a>3.3 文件的操作命令</h2><ul><li><code>touch 文件名称</code>：文件的创建</li><li><code>cat/more/less/tail 文件名称</code>：文件的查看</li><li><code>vim 文件</code>：修改文件的内容</li><li><code>rm -rf 文件</code>：删除文件</li></ul><h2 id="3-4-压缩文件的操作命令"><a href="#3-4-压缩文件的操作命令" class="headerlink" title="3.4 压缩文件的操作命令"></a>3.4 压缩文件的操作命令</h2><p>1）打开并压缩文件</p><p>Linux中的打包和压缩是一起进行的，打包并压缩文件的后缀名一般为<code>.tar.gz</code></p><ul><li><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></li></ul><p>其中：</p><ul><li>z：调用gzip压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>2）解压压缩包：</p><ul><li><code>tar [-xvf] 压缩文件</code></li></ul><p>其中：</p><ul><li>x：代表解压</li></ul><h2 id="3-5-Linux的权限命令"><a href="#3-5-Linux的权限命令" class="headerlink" title="3.5 Linux的权限命令"></a>3.5 Linux的权限命令</h2><p>linux中权限一般分为读(readable)、写(writable)、执行(excutable)三组。分别对应文件的属主(owner)、属组(group)和其他用户(other)</p><p>通过<code>ls -l</code>命令</p><p><img src="https://note.youdao.com/yws/api/personal/file/E17C3D4A7E5B4CD3B7097099277E7B70?method=download&shareKey=1d7ba2648463666978de2b54a718b3b0" alt></p><p>第一列的内容信息解释如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/3608EE6D1AAD49ABB8C7DB547871DEE1?method=download&shareKey=b86faced23e0328c128443cf66255de1" alt></p><p>文件的类型：</p><ul><li>d：目录</li><li>-：文件</li><li>l：软连接</li></ul><p>Linux中权限分为以下几种：</p><ul><li>r：可读</li><li>w：可写</li><li>x：可执行</li></ul><p>文件和目录权限的区别：</p><p>对文件和目录而言，读写执行表示不同的意义</p><p>对于文件：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以使用cat查看文件内容</td></tr><tr><td align="left">w</td><td align="right">可以修改文件内容</td></tr><tr><td align="left">x</td><td align="right">可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以查看目录下列表</td></tr><tr><td align="left">w</td><td align="right">可以创建和删除目录下文件</td></tr><tr><td align="left">x</td><td align="right">可以使用cd进入目录</td></tr></tbody></table><p>超级用户可以无视普通用户的权限</p><p>在Linux中的每一个用户必须属于一个组，不能独立于组外，在Linux中每个文件有所有者、所在组、其它组的概念</p><ul><li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的称为该文件的所有者</li><li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</li><li>其他组(o)：除开文件的所有者和所在组用户外，系统的其他用户都是文件的其他组</li></ul><p>修改文件/目录的权限命令</p><ul><li>chmod</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/D0D5A242004E4058AB3D4D0AF2795B10?method=download&shareKey=84cd39dd258f0930b7bb7fdb91ddfea3" alt></p><h2 id="3-6-Linux用户管理"><a href="#3-6-Linux用户管理" class="headerlink" title="3.6 Linux用户管理"></a>3.6 Linux用户管理</h2><ul><li><code>useradd 选项 用户名</code>：添加用户账号</li><li><code>userdel 选项 用户名</code>：删除用户账号 </li><li><code>usermod 选项 用户名</code>：修改账号</li><li><code>passwd 用户名</code>：更改或创建用户的密码</li><li><code>passwd -S 用户名</code>：显示用户账号密码信息</li><li><code>passwd -d 用户名</code>：清除用户密码</li></ul><h2 id="3-7-系统用户组的管理"><a href="#3-7-系统用户组的管理" class="headerlink" title="3.7 系统用户组的管理"></a>3.7 系统用户组的管理</h2><ul><li><code>groupadd 选项 用户组</code>：添加一个新的用户组</li><li><code>groupedl 用户组</code>：要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code>：修改用户组的属性</li></ul><h2 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8 其他常用命令"></a>4.8 其他常用命令</h2><ul><li><code>pwd</code>：显示当前所在位置</li><li><code>sudo + 其他命令</code> ： 以系统管理者的身份执行命令</li><li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令， –color代表高亮显示</li><li><code>ps -ef/ps -aux</code>：查看当前系统正在运行进程</li><li><code>kill -9 进程的Pid</code>：杀死进程</li><li><code>shutdown</code>：关机</li><li><code>reboot</code>：重启</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Linux文件类型&quot;&gt;&lt;a href=&quot;#1-Linux文件类型&quot; class=&quot;headerlink&quot; title=&quot;1 Linux文件类型&quot;&gt;&lt;/a&gt;1 Linux文件类型&lt;/h1&gt;&lt;p&gt;Linux支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通文件&lt;/li&gt;
&lt;li&gt;目录文件(d, directory file)&lt;/li&gt;
&lt;li&gt;符号链接文件(l, symbolic link)：保留了指向文件的地址而不是文件本身&lt;/li&gt;
&lt;li&gt;字符设备(c, char)：用来访问字符设备比如硬盘&lt;/li&gt;
&lt;li&gt;设备文件(b,block)：用来访问设备比如硬盘、软盘&lt;/li&gt;
&lt;li&gt;管道文件(p,pipe)：用于进程之间的通信&lt;/li&gt;
&lt;li&gt;套接字(s,socket)：进程间网络通信，也可以用于本机之间的非网络通信&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://liangggggg.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://liangggggg.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（五）：输入输出管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os5/"/>
    <id>https://liangggggg.github.io/2020/08/28/os5/</id>
    <published>2020-08-28T15:12:59.000Z</published>
    <updated>2020-08-28T12:10:27.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO管理概述"><a href="#1-IO管理概述" class="headerlink" title="1 IO管理概述"></a>1 IO管理概述</h1><h2 id="1-1-IO设备"><a href="#1-1-IO设备" class="headerlink" title="1.1 IO设备"></a>1.1 IO设备</h2><p>IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。</p><a id="more"></a><p>计算机系统中的IO设备按使用特性可以分为一下类型：</p><ol><li><p>人机交互类外部设备，又称慢速IO设备，用于桶计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。</p></li><li><p>存储设备，用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。</p></li><li><p>网络通信设备，用于与远程设备通信的设备，如各种网络接口、调制解调器等。其数据交换速度介于外部设备与存储设备之间。网络通信设备在使用和管理上与前两者设备有很大的不同。</p></li></ol><h2 id="1-2-IO管理目标"><a href="#1-2-IO管理目标" class="headerlink" title="1.2 IO管理目标"></a>1.2 IO管理目标</h2><p>IO设备管理的主要目标有以下三个方面。</p><p>方便使用：方便用户使用外部设备，控制设备工作完成用户的输入输出要求。</p><p>提高效率：提高系统的并行工作能力，提高设备的使用效率。</p><p>方便控制：提高外围设备和系统的可靠性和安全性，以使系统能正常工作。</p><h2 id="1-3-IO管理功能"><a href="#1-3-IO管理功能" class="headerlink" title="1.3 IO管理功能"></a>1.3 IO管理功能</h2><p>IO设备管理的功能是按照输入输出子系统的结构和设备类型制定分配和使用设备的策略，主要包括：</p><p>设备的分配和回收。</p><p>外围设备的启动。</p><p>对磁盘的驱动调度。</p><p>外部设备中断处理。</p><p>虚拟设备的实现。</p><h2 id="1-4-IO应用接口"><a href="#1-4-IO应用接口" class="headerlink" title="1.4 IO应用接口"></a>1.4 IO应用接口</h2><p>划分IO设备所属的通用类型的依据：</p><ul><li><p>字符设备还是块设备。</p></li><li><p>顺序访问还是随机访问。</p></li><li><p>IO传输是同步还是异步。</p></li><li><p>共享设备还是独占设备。</p></li><li><p>操作速度的高低。</p></li><li><p>访问模式是读写、只读还是只写。</p></li></ul><h2 id="1-5-设备控制器"><a href="#1-5-设备控制器" class="headerlink" title="1.5 设备控制器"></a>1.5 设备控制器</h2><p>设备控制器的主要功能为：</p><ul><li><p>接收和识别CPU或通道发来的命令，如磁盘控制器能就收读、写、查找、搜索等命令。</p></li><li><p>实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。</p></li><li><p>发现和记录设备及自身的状态信息，供CPU处理使用。</p></li><li><p>设备地址识别。</p></li></ul><h2 id="1-6-IO控制方式"><a href="#1-6-IO控制方式" class="headerlink" title="1.6 IO控制方式"></a>1.6 IO控制方式</h2><p>中断驱动方式中，CPU仍然需要主动处理在存储器和IO设备之间的数据传送，所以速度还是受限，而直接内存存取（DMA）方式的基本思想是在外围设备和内存之间开辟直接的数据交换通路，彻底解放CPU。该方式的特点是：</p><ul><li><p>基本单位是数据块。</p></li><li><p>所传诵的数据，是从设备直接送入内存的，或者相反。</p></li><li><p>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p></li></ul><p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p><ul><li><p>命令/状态寄存器（CR）。用于接收从CPU发来的IO命令或有关控制信息，或设备的状态。</p></li><li><p>内存地址寄存器（MAR）。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</p></li><li><p>数据寄存器（DR）。用于暂存从设备到内存或从内存到设备的数据。</p></li><li><p>数据计数器（DC）。存放本次CPU要读或写的字节数。</p></li></ul><p>DMA的工作过程是：CPU读写数据时，他给IO控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把这个操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此，只有在传送开始和结束时才需要CPU的参与。</p><h1 id="2-IO核心子系统"><a href="#2-IO核心子系统" class="headerlink" title="2 IO核心子系统"></a>2 IO核心子系统</h1><h2 id="2-1-IO层次结构"><a href="#2-1-IO层次结构" class="headerlink" title="2.1 IO层次结构"></a>2.1 IO层次结构</h2><p>一个比较合理的层次划分为四个层次的系统结构，各层次及其功能如下：</p><ol><li><p>用户层IO软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与IO操作有关的库函数，对设备进行操作。</p></li><li><p>设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p></li><li><p>设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。</p></li><li><p>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并回复被中断进程的现场后，返回到被中断进程。</p></li></ol><h2 id="2-2-IO调度概念"><a href="#2-2-IO调度概念" class="headerlink" title="2.2 IO调度概念"></a>2.2 IO调度概念</h2><p>调度一组IO请求就是确定确定一个好的顺序来执行这些请求。应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要调度来改善系统整体性能，是进程之间公平的共享设备访问，减少IO完成所需要的平均等待时间。</p><p>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞IO系统调用时，该请求就加到相应设备的队列上。IO调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。</p><p>IO子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等。</p><h2 id="2-3-高速缓存与缓冲区"><a href="#2-3-高速缓存与缓冲区" class="headerlink" title="2.3 高速缓存与缓冲区"></a>2.3 高速缓存与缓冲区</h2><p>在设备管理子系统中，引入缓冲区的目的有：</p><ol><li><p>缓和CPU与IO 设备间速度不匹配的矛盾。</p></li><li><p>减少对CPU的中断频率，放宽对CPU 中断响应时间的限制。</p></li><li><p>解决基本数据单元大小不匹配的问题。</p></li><li><p>提高CPU和IO设备之间的并行性。</p></li></ol><h2 id="2-4-设备的分配与回收"><a href="#2-4-设备的分配与回收" class="headerlink" title="2.4 设备的分配与回收"></a>2.4 设备的分配与回收</h2><p>设备分配的基本任务是根据用户的IO请求，为他们分配所需的设备。设备分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类。</p><h2 id="2-5-假脱机技术"><a href="#2-5-假脱机技术" class="headerlink" title="2.5 假脱机技术"></a>2.5 假脱机技术</h2><p>为了缓和CPU的高速型与IO设备低速性之间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速IO设备上的数据传送到高速磁盘上；或者相反。SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO管理概述&quot;&gt;&lt;a href=&quot;#1-IO管理概述&quot; class=&quot;headerlink&quot; title=&quot;1 IO管理概述&quot;&gt;&lt;/a&gt;1 IO管理概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-IO设备&quot;&gt;&lt;a href=&quot;#1-1-IO设备&quot; class=&quot;headerlink&quot; title=&quot;1.1 IO设备&quot;&gt;&lt;/a&gt;1.1 IO设备&lt;/h2&gt;&lt;p&gt;IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（四）：文件系统</title>
    <link href="https://liangggggg.github.io/2020/08/28/os4/"/>
    <id>https://liangggggg.github.io/2020/08/28/os4/</id>
    <published>2020-08-28T14:12:59.000Z</published>
    <updated>2020-08-28T12:10:16.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件系统基础"><a href="#1-文件系统基础" class="headerlink" title="1 文件系统基础"></a>1 文件系统基础</h1><h2 id="1-1-文件的概念"><a href="#1-1-文件的概念" class="headerlink" title="1.1 文件的概念"></a>1.1 文件的概念</h2><p>文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。</p><a id="more"></a><p>用户通过文件系统建立文件，提供应用程序的输入输出，对资源进行管理。首先了解文件的结构，我们通过自底向上的方式来定义。</p><ol><li>数据项：数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：基本数据项和组合数据项</li><li>记录：记录是一组相关的数据项集合，用于描述一个对象在某方面的属性</li><li>文件：文件是指由穿件这所定义的一组相关信息的集合，可分为有结构文件和无结构文件两种。</li></ol><p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：</p><ul><li>名称</li><li>标识符</li><li>类型</li><li>位置</li><li>大小</li><li>保护</li><li>时间、日期和用户标识</li></ul><p>文件属于抽象数据类型。为了恰当的定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，他对文件进行创建、写、读、定位和截断。</p><p>每个打开文件都有如下关联信息：</p><ul><li>文件指针</li><li>文件打开计数</li><li>文件磁盘位置</li><li>访问权限</li></ul><h2 id="1-2-文件的逻辑结构"><a href="#1-2-文件的逻辑结构" class="headerlink" title="1.2 文件的逻辑结构"></a>1.2 文件的逻辑结构</h2><p>按逻辑结构，文件有无结构文件和有结构文件两种类型：</p><ol><li>顺序文件</li><li>索引文件</li><li>索引顺序表</li><li>直接文件或散列文件</li></ol><h1 id="1-3-目录结构"><a href="#1-3-目录结构" class="headerlink" title="1.3 目录结构"></a>1.3 目录结构</h1><p>与文件管理系统和文件集合相关联的是文件目录，它包含有文件的信息，包括属性、位置和所有权等，这些信息都由操作系统进行管理。首先我们来看目录管理的基本要求 ：从用户的角度看，目录在用户所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在共享系统中，目录还需要提供用于控制访问文件的信息。此外，文件允许重名也是用户的合理和必然要求，目录管理通过树形结构来解决和实现。</p><h1 id="1-4-文件共享"><a href="#1-4-文件共享" class="headerlink" title="1.4 文件共享"></a>1.4 文件共享</h1><p>文件共享十多个用户进程共享同一份文件，系统中只需保留该文件的一份副本。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。</p><p>随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过c/s模型共享网络中的服务器文件。</p><h1 id="1-5-文件保护"><a href="#1-5-文件保护" class="headerlink" title="1.5 文件保护"></a>1.5 文件保护</h1><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p><p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了方式用户文件被他人存取或盗取，而访问控制则用于控制用户对文件的访问方式。</p><p>对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：</p><ul><li><p>读：从文件中读。</p></li><li><p>写：向文件中写。</p></li><li><p>执行：将文件装入内存并执行。</p></li><li><p>添加：将信息添加到文件结尾部分。</p></li><li><p>删除：删除文件，释放空间。</p></li><li><p>列表清单：列出文件名和文件属性。</p></li></ul><h1 id="2-文件系统实现"><a href="#2-文件系统实现" class="headerlink" title="2 文件系统实现"></a>2 文件系统实现</h1><h2 id="2-1-文件系统层次结构"><a href="#2-1-文件系统层次结构" class="headerlink" title="2.1 文件系统层次结构"></a>2.1 文件系统层次结构</h2><p>现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。</p><p>文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。</p><h2 id="2-2-目录实现"><a href="#2-2-目录实现" class="headerlink" title="2.2 目录实现"></a>2.2 目录实现</h2><p>在读文件前，必须先打开文件。打开文件时，操作系统利用路径名吵到相应目录项，目录项中提供了查找文件磁盘块所需要的信息，目录实现的基本方法有线性列表和哈希表两种方法。</p><h2 id="2-3-文件实现"><a href="#2-3-文件实现" class="headerlink" title="2.3 文件实现"></a>2.3 文件实现</h2><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方式有三种：连续分配、链接分配和索引分配。有的系统对三种方式都支持，但是更普遍的是一个系统只提供一种方法支持。</p><h1 id="3-磁盘组织与管理"><a href="#3-磁盘组织与管理" class="headerlink" title="3 磁盘组织与管理"></a>3 磁盘组织与管理</h1><h2 id="3-1-磁盘的结构"><a href="#3-1-磁盘的结构" class="headerlink" title="3.1 磁盘的结构"></a>3.1 磁盘的结构</h2><p>磁盘是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称谓磁头的到体系安全从磁盘中存取数据。在读写操作期间，磁头固定，磁盘在下面高速旋转。</p><h2 id="3-2-磁盘调度算法"><a href="#3-2-磁盘调度算法" class="headerlink" title="3.2 磁盘调度算法"></a>3.2 磁盘调度算法</h2><p>1、先来先服务（FCFS）算法</p><p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度处理，这是一种最简单的调度算法。这种算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则会达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往低于随即调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。</p><p>2、最短寻找时间优先（SSTF）算法</p><p>SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，一是每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能。这种算法会产生饥饿现象</p><p>3、扫描（SCAN）算法</p><p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最扫描过的区域不公平，因此，他在访问局部性方面不如FCFS算法和SSTF算法好。</p><p>4、循环扫描算法（C-SCAN）</p><p>在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p><h2 id="3-3-磁盘的管理"><a href="#3-3-磁盘的管理" class="headerlink" title="3.3 磁盘的管理"></a>3.3 磁盘的管理</h2><p>了使用磁盘存储文件。操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为一个或多个柱面组成分区；低而不对物理分区进行逻辑格式化，操作系统将出师的文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-文件系统基础&quot;&gt;&lt;a href=&quot;#1-文件系统基础&quot; class=&quot;headerlink&quot; title=&quot;1 文件系统基础&quot;&gt;&lt;/a&gt;1 文件系统基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-文件的概念&quot;&gt;&lt;a href=&quot;#1-1-文件的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件的概念&quot;&gt;&lt;/a&gt;1.1 文件的概念&lt;/h2&gt;&lt;p&gt;文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（三）：内存管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os3/"/>
    <id>https://liangggggg.github.io/2020/08/28/os3/</id>
    <published>2020-08-28T12:12:59.000Z</published>
    <updated>2020-08-31T05:24:16.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-内存管理基础"><a href="#1-内存管理基础" class="headerlink" title="1 内存管理基础"></a>1 内存管理基础</h1><h2 id="1-1-内存管理的概念"><a href="#1-1-内存管理的概念" class="headerlink" title="1.1 内存管理的概念"></a>1.1 内存管理的概念</h2><p>内存管理是操作系统设计中最重要和最复杂的内容之一，内存管理的功能有：</p><ol><li>内存空间的分配与回收，包括分配与共享</li><li>地址转换，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存</li><li>内存保护，保证各道作业在各自存储空间内运行，互不干扰</li></ol><a id="more"></a><p>创建进程首先要将程序和数据装入内存，将用户原程序编程可在内存中执行的程序，通常需要以下几个步骤</p><ol><li>编译，由编译程序将用户源代码编译成若干个目标模块</li><li>链接，由链接程序将编译后形成一组目标模块</li><li>装入，由装入程序将装入模块装入内存</li></ol><p>程序的连接有以下三种方式</p><ol><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完成的可执行程序，以后不再拆开</li><li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，再装入内存时，采用边装入边链接方式</li><li>运行时动态链接：对某些目标模块的连接，是在程序执行中需要该目标模块时，才进行链接，其优点是便于修改和更新</li></ol><p>装入内存时，同样有以下三种方式：</p><ol><li>绝对装入：在编译时，产生绝对地址的目标代码</li><li>可重定位装入：在多道程序环境下，多个目标目标的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的</li><li>动态运行时装入：程序在内存中发生移动，需要采用动态装入方式，地址转换推迟到程序真正要执行时才进行，装入内存后的所有地址都仍是相对地址</li></ol><h2 id="1-2-覆盖与交换"><a href="#1-2-覆盖与交换" class="headerlink" title="1.2 覆盖与交换"></a>1.2 覆盖与交换</h2><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法</p><p>覆盖的基本思想：</p><p>由于程序运行时并非任何时候都要访问程序和数据的各个部分，因此可以把用户控件分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定区，其余部分按照调用关系分段</p><p>交换的基本思想：</p><p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的进程从内存移到辅存，把内存空间腾出来，把准备好竞争CPU运行的进程从辅存移到内存</p><p>有关交换需要注意以下问题：</p><ul><li>交换需要备份存储</li><li>为了有效使用CPU，需要每个进程的执行时间比交换时间长</li><li>如果换出进程，必须确保该进程是完全处于空闲状态</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常有许多进程运行且内存空间吃紧的时候开始启动</li><li>普通的交换使用不多，但交换策略的某些变种在许多系统中仍发挥作用</li></ul><h2 id="1-3-连续分配管理方式"><a href="#1-3-连续分配管理方式" class="headerlink" title="1.3 连续分配管理方式"></a>1.3 连续分配管理方式</h2><p>连续分配，是指为一个用户程序分配一个连续的内存空间，主要包括单一连续分配、固定分区分配和动态分区分配</p><p>内存在此方式下分为系统区和用户区</p><p>固定分区分配是最简单的一种多道程序储存管理方式，将内存划分为若干个固定大小的区域，每个分区只装入一道作业</p><p>固定分区分配在划分分区时，有两种不同的方法</p><ol><li>分区大小相等</li><li>分区大小不等</li></ol><p>固定分区不能实现多进程共享一个主存区，空间利用率低</p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好合适进程的需要，但是随着时间的推移，内存中会产生越来越多的碎片</p><p>动态分区的分配策略，可以考虑以下几种算法：</p><ol><li>首次适应算法：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区</li><li>最佳适应算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区</li><li>最坏适应算法：空闲分区以容量递减次序链接，找到第一个能满足要求的空闲分区</li><li>临近适应算法：由首次适应算法演变而成，不同之处是分配内存时从查找结束的位置开始继续查找</li></ol><p>首次适应被认为最好、最快，其次是循环，最佳最差（每次分配后剩下小碎片，难再分）</p><p>可重定位分区分配：允许在主存中移动，将小内存拼接在一起</p><h2 id="1-4-非连续分配管理方式"><a href="#1-4-非连续分配管理方式" class="headerlink" title="1.4 非连续分配管理方式"></a>1.4 非连续分配管理方式</h2><p>非连续分配允许一个程序分散的装入不相邻的内存分区中，根据分区的大小是否固定为分页存储管理方式和分段存储管理方式</p><p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本页存储管理和请求页存储管理方式</p><p>1、分页存储的几个基本概念</p><ul><li>页面和页面大小：进程中的块称为页，内存中的块称为页框。外存也以同样单位划分，直接称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</li><li>地址变换机构：分页存储管理的地质结构包含两部分：前一部分为页号，后一部分为页内偏移量</li><li>页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</li><li>分页：把用户程序按逻辑页划分成大小相等的部分，称为页或虚页。从0开始编制页号，页内地址是相对于0编址</li><li>主存分配：把用户程序的任一页，可以分配到内存中的任一物理块，从而实现非连续内存分配</li></ul><p>2、基本地址变换机构</p><p>实现从逻辑地址到物理地址的转换，将逻辑地址中页号转换为内存中的物理块号，通过页表是实现，页表大多贮存在内存中</p><p>当进程要访问某个进程的逻辑地中的数据时，分为页号和页内地址两部分，如果超过页表长度则发生越界中断</p><p>3、具有快表的地址变换机构</p><p>命中率，是指使用块表并在其中成功查找到所需页面的表项的比率</p><p>4、两级和多级页表</p><p>将页表分页，并离散地将各个页面分别存放在不同的物理块中，同样要为离散分配的页表再建立一张页表，称为外层页表</p><p>对于32位机器，采用两级页表是合适的，但对于64位机器必须采用多级页表，将外层页再进行分页，也是将各分页离散地装入到不相接的物理地址中</p><h1 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2 虚拟内存"></a>2 虚拟内存</h1><h2 id="2-1-虚拟内存的基本概念"><a href="#2-1-虚拟内存的基本概念" class="headerlink" title="2.1 虚拟内存的基本概念"></a>2.1 虚拟内存的基本概念</h2><p>内存管理策略有两个共同特质：</p><ol><li>一次性：作业必须一次全部装入内存后，方可运行</li><li>驻留性：作业被装入内存后，就一直驻留在内存中</li></ol><p>局部性原理表现在以下两个方面：</p><ol><li><p>时间局部性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p></li><li><p>空间局部性。一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p></li></ol><p>时间局部性是通过将进来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。</p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行，这样，计算机好像为用户提供了一个比实际内存大得多的储存器，称为虚拟储存器，主要有以下三个主要特征：</p><ol><li>多次性：无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性：无需作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出</li><li>虚拟性：逻辑上扩充内存的容量</li></ol><p>虚拟存储器具有请求调入功能和置换功能，逻辑容量由内存容量和外存容量之和决定</p><p>虚拟内存建立在离散分配的内存管理方式的基础上，有以下三种方式</p><ol><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ol><p>不管哪种方式，都需要有一定的硬件支持</p><ol><li>一定的内存和外存</li><li>页表机制或段表机制</li><li>中断机构</li><li>地址变换机构</li></ol><h2 id="2-2-请求分页管理方式"><a href="#2-2-请求分页管理方式" class="headerlink" title="2.2 请求分页管理方式"></a>2.2 请求分页管理方式</h2><p>请求分页系统建立在基本分页系统基础上，为了支持寻你存储器功能而增肌阿勒请求分页功能和页面置换功能</p><h2 id="2-3-页面置换算法"><a href="#2-3-页面置换算法" class="headerlink" title="2.3 页面置换算法"></a>2.3 页面置换算法</h2><p>进程运行时，若访问的页面不在内存，需要将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘兑换区，常见的置换算法有以下四种：</p><ol><li>最佳置换算法</li><li>先进先出页面置换算法</li><li>最近最久未使用置换算法</li><li>最少使用置换算法</li></ol><h2 id="2-4-页面分配策略"><a href="#2-4-页面分配策略" class="headerlink" title="2.4 页面分配策略"></a>2.4 页面分配策略</h2><p>给特定的进程分配多大的主存空间，需要考虑以下几点：</p><ol><li>分配给一个进程的存储量越小，在任何时候驻留在主存的进程数越多，可以提高处理器的时间利用率</li><li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高</li><li>如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</li></ol><p>基于这些因素，现代操作系统通常采用三种策略：</p><ol><li>固定分配局部置换：它为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发现缺页，则只能从该进程在内存的页面中选出一个换出，然后再调入需要的页面。</li><li>可变分配全局置换：这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数量的物理块，操作系统自身也保持一个空闲物理块队列。当某进程发现缺页时，系统从空闲物理块队列中取出物理块分配给该进程，并将于调入的页装入其中。</li><li>可变分配局部置换：它为每个进程分配一定数目的物理块，当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁的换页，系统需再为该进程分配若干附加物理块，直至该进程缺页率趋于适当程度为止；反之，若一个进程在运行过程中缺页率特别低，则此时可适当减少该进程的物理块。</li></ol><p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：</p><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页可能比一次调入一页更高效。但如果调入的一批页面中大厦多数都未被访问，则又是低效的。所以就需要采用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。股这种策略主要用于进程的首次调入时，有程序员指出应该先调入哪些页。</li><li>请求调页策略：进程在运行中需要访问的页面不在内存而提出的请求，由系统将所需页面调入内存。这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。它的缺点在于每次调入一页，会花费过多的IO开销。</li><li>从何处调入页面。请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘IO速度比文件区高。这里从何处调入页面有三种情况</li></ol><h2 id="2-5-抖动和工作集"><a href="#2-5-抖动和工作集" class="headerlink" title="2.5 抖动和工作集"></a>2.5 抖动和工作集</h2><p>在进程的页面置换过程中，频繁的页面调度行为成为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>使用虚拟内存技术，操作系统中进程通常只有一部分块位于主存中，从而可以在内存中保留更多的进程以提高系统效率。此外，由于未用到的块不需要换入换出内存，因为节省了时间。但是系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被禁成块占据，处理器和操作系统可以直接访问到尽可能多的进程。但如果管理不当，系统发生抖动现象，处理器的大部分时间都将用于交换快，及请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。前面讲解的页面置换算法就是是讨论这里的分配方案，尽量避免抖动现象。</p><p>另外，为了防止出现抖动现象，需要选择合适的驻留集大小。驻留集（或工作集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。驻留集模型使用较为简单：操作系统跟踪每个进程的驻留集，并为进程分配大于驻留集的的空间。如果还有空闲，那么可启动另一个进程。如果所有驻留集之和增加一直超过了可用物理块啊的总数，那么系统会怎听一个进程，将其页面调出并且将其物理块分配给其他进程。</p><p>正确选择驻留集的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。</p><h2 id="2-6-请求分段管理方式"><a href="#2-6-请求分段管理方式" class="headerlink" title="2.6 请求分段管理方式"></a>2.6 请求分段管理方式</h2><p>请求分段存储管理系统已基本短时存储管理为基础，为用户提供一个比主存容量更大的虚拟存储器。作业的若干分段别放入内存，就可以开始作业运行，作业的其他部分被放在外存中，等到需要的时候才被调入内存。</p><ul><li>分段：作业的地址空间被分成若干个段，每个段定义了一组逻辑信息</li><li>段表：每个进程建立一张映射表，每个段表中占一个表项，其中记录了该段内存地址信息</li></ul><p>分页和分段的主要区分</p><ol><li>页式信息的物理单位，段是信息的逻辑单位</li><li>页的大小固定且由系统决定，段的长度不固定取决于用户编程</li><li>分页的作业地址空间是一维的，分段的作业地址空间是二维的</li></ol><h2 id="2-7-请求段页式管理方式"><a href="#2-7-请求段页式管理方式" class="headerlink" title="2.7 请求段页式管理方式"></a>2.7 请求段页式管理方式</h2><p>请求段页式管理方式只要求将作业若干页或段装入内存就可以开始运行作业，作业的其他部分别放在外存中，等待运行需要的时候才被调入内存，</p><p>请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</p><h1 id="3-常见面试题总结"><a href="#3-常见面试题总结" class="headerlink" title="3 常见面试题总结"></a>3 常见面试题总结</h1><h2 id="3-1-内存管理介绍"><a href="#3-1-内存管理介绍" class="headerlink" title="3.1 内存管理介绍"></a>3.1 内存管理介绍</h2><p>操作系统的内存管理主要负责内存的分配与回收，另外地址转换也就是将逻辑地址转换成相应的物理地址等功能</p><h2 id="3-2-操作系统的内存管理机制"><a href="#3-2-操作系统的内存管理机制" class="headerlink" title="3.2 操作系统的内存管理机制"></a>3.2 操作系统的内存管理机制</h2><p>简单分配连续分配管理方式和非连续管理分配方式，连续分配管理方式是指为了一个用户程序分配一个连续的内存空间，常见的块管理，非连续分配管理方式允许一个程序使用的内存分布在离散或不相邻的内存中，常见的页式管理和段式管理</p><ol><li>块管理：远古时代的计算机操作系统的内存管理方式，将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间称为碎片</li><li>页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对比较于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表和对应逻辑地址和物理地址</li><li>段式管理：每一段定义了一组逻辑信息，通过管理段表对应逻辑地址和物理地址。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。</li></ol><h2 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h2><p>分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快</li><li>解决页表占用空间大</li></ol><p><strong>快表</strong></p><p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础上引入了快表来加速虚拟地址到物理地址的转换，我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容，作为页表的Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时CPU要访问两次主存，有了快表，有时只要访问一次告诉缓冲存储器，一次主存，这样可加快查找速度并提高指令速度</p><p>使用快表之后的地址转换流程是这样的:</p><ol><li>根据虚拟地址中的页号查找表</li><li>如果该页在快表中，直接从快表中读取相应的物理地址</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射添加到快表中</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页</li></ol><p><strong>多级页表</strong></p><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p><h2 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="3.4 分页机制和分段机制的共同点和区别"></a>3.4 分页机制和分段机制的共同点和区别</h2><p>1.共同点</p><ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式，但是每个页和段中的内存时连续的</li></ul><p>2.区别：</p><ul><li>页的大小是固定的，有操作系统决定；段的大小不是固定的，取决于我们当前运行的程序</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能更好满足用户的需求</li></ul><h2 id="3-5-虚拟地址和物理地址"><a href="#3-5-虚拟地址和物理地址" class="headerlink" title="3.5 虚拟地址和物理地址"></a>3.5 虚拟地址和物理地址</h2><p>逻辑地址由操作系统决定，物理地址是指内存地址寄存器的地址，是内存单元真正的地址</p><h2 id="3-6-CPU寻址与虚拟地址空间"><a href="#3-6-CPU寻址与虚拟地址空间" class="headerlink" title="3.6 CPU寻址与虚拟地址空间"></a>3.6 CPU寻址与虚拟地址空间</h2><p>现在处理器使用的一种称为虚拟寻址的寻址方式，使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址的硬件CPU中含有一个被称为内存管理单元的硬件</p><p>为什么要有虚拟地址空间？</p><p>如果没有虚拟地址空间，程序都是直接访问和操作物理内存，容易造成以下问题：</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样很容易破坏操作系统，造成操作系统崩溃</li><li>想要同时运行多个程序特别苦难</li></ol><p>通过虚拟地址访问内存有以下几个优势：</p><ol><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘。</li><li>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存</li></ol><h2 id="3-7-局部性原理"><a href="#3-7-局部性原理" class="headerlink" title="3.7 局部性原理"></a>3.7 局部性原理</h2><p>局部性原理主要表现在以下两个方面：</p><ol><li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因是由于程序中存在着大量的循环操作</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间锁访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组等形式存储的</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h2 id="3-8-虚拟存储器"><a href="#3-8-虚拟存储器" class="headerlink" title="3.8 虚拟存储器"></a>3.8 虚拟存储器</h2><p>基于局部性原理，在程序装入时，可将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行，由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上可以比计算机实际的内存大。在程序执行过程中，当访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放要将调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器————虚拟存储器</p><p>实际上是一种时间换空间的策略</p><h2 id="3-9-虚拟内存的技术实现"><a href="#3-9-虚拟内存的技术实现" class="headerlink" title="3.9 虚拟内存的技术实现"></a>3.9 虚拟内存的技术实现</h2><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</p><ol><li>请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。加入在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不同的页面置换到外存中</li><li>请求分段存储管理：建立在分段存储管理之上，增加了请求掉段功能，分段置换功能。请求分段存储管理方式就如同请求分页存储管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断状态装入要访问但又不在内存的程序段，当内存空间已满，又要装入新的段时，根据置换功能调出某个段，以便腾出空间而装入新的段</li><li>请求段页式存储管理：请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</li></ol><p><strong>请求分页与分页存储管理的区别</strong></p><p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h2 id="3-10-页面置换算法"><a href="#3-10-页面置换算法" class="headerlink" title="3.10 页面置换算法"></a>3.10 页面置换算法</h2><ul><li>OPT页面置换算法（最佳页面置换算法）：最佳置换算法所选择的被淘汰页面将式以后永不使用的，或者是在最长时间内部再被访问的页面，但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间不再被访问的，因而该算法无法实现</li><li>FIFO页面置换算法（先进先出页面置换算法）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰</li><li>LRU（最近最久未使用页面置换算法）：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当必须淘汰一个页面时，选择T值最大的，即最近最久未使用的页面予以淘汰</li><li>LFU（最少使用页面置换算法）：使用之前使用最少的页面最为淘汰页面</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-内存管理基础&quot;&gt;&lt;a href=&quot;#1-内存管理基础&quot; class=&quot;headerlink&quot; title=&quot;1 内存管理基础&quot;&gt;&lt;/a&gt;1 内存管理基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-内存管理的概念&quot;&gt;&lt;a href=&quot;#1-1-内存管理的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 内存管理的概念&quot;&gt;&lt;/a&gt;1.1 内存管理的概念&lt;/h2&gt;&lt;p&gt;内存管理是操作系统设计中最重要和最复杂的内容之一，内存管理的功能有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存空间的分配与回收，包括分配与共享&lt;/li&gt;
&lt;li&gt;地址转换，把逻辑地址转换成相应的物理地址&lt;/li&gt;
&lt;li&gt;内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存&lt;/li&gt;
&lt;li&gt;内存保护，保证各道作业在各自存储空间内运行，互不干扰&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（二）：进程管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os2/"/>
    <id>https://liangggggg.github.io/2020/08/28/os2/</id>
    <published>2020-08-28T11:12:59.000Z</published>
    <updated>2020-08-30T14:18:26.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h1><h2 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h2><p>（1）进程的概念</p><p>从不同的角度，进程可以由不同的定义：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理器上顺序执行时发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</li></ol><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><a id="more"></a><p>（2）进程的特征</p><ol><li>动态性：他有着创建、活动、暂停、终止过程</li><li>并发性：多个进程实体，同存于内存中，能在一段时间内同时运行</li><li>独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li><li>异步性：由于进程的相互制约，是进程具有执行的间断性</li><li>结构性：进程实体是由程序段、数据段和进程控制段三部分组成</li></ol><h2 id="1-2-进程的状态和转换"><a href="#1-2-进程的状态和转换" class="headerlink" title="1.2 进程的状态和转换"></a>1.2 进程的状态和转换</h2><ol><li>运行状态</li><li>就绪状态：准备运行的状态</li><li>阻塞状态：等待状态，等待某一时间而暂停运行</li><li>创建状态：进程正在被创建，尚未转到就绪状态</li><li>结束状态</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/6D5D188BA55446DFB84D2D1071280B51?method=download&shareKey=c78907ea956c694fbab1ef69a75a8d42" alt></p><h2 id="1-3-进程控制"><a href="#1-3-进程控制" class="headerlink" title="1.3 进程控制"></a>1.3 进程控制</h2><p>在操作系统中，一般把进程控制用的程序段称为原语:由若干条指令构成的院子操作，作为一个整体不可分割，要么全都做，要么全部做</p><p>允许一个进程创建另一个进程</p><p>创建一个新进程的过程如下</p><ol><li>为新进程分配一个唯一进程标示号，申请一个空白PCB</li><li>为进程分配资源</li><li>初始化PCB，主要包括初始化标识信息，初始化处理器状态信息和初始化处理器控制信息</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行</li></ol><p>终止进程的过程如下：</p><ol><li>根据终止进程标识符，检索PCB，从中读出该进程的状态</li><li>若被终止进程处于执行状态，立即终止进程的执行，将处理器资源分配给其他进程</li><li>若该进程还有子进程，则应将其所有子进程终止</li><li>将该进程拥有所有资源返还给操作系统</li><li>将该PCB从所在队列中删除</li></ol><p>进程的阻塞如下：</p><ol><li>找到将要被阻塞的标示号对应PCB，如果该进程为运行状态，则保护线程，将其状态改为阻塞状态，停止运行</li><li>若为就绪状态，则将其状态改为阻塞状态，把它溢出就绪队列，插入等待队列</li></ol><p><strong>进程的阻塞是进程自身的一种主动行为</strong></p><p>进程唤醒如下：</p><ol><li>在改时间的等待队列中找到相应进程的PCB，然后把该PCB插入到就绪队列中，等待调度程序调度</li></ol><p>进程切换过程如下：</p><ol><li>保存处理器上下文</li><li>更新PCB信息</li><li>把PCB移入相应队列</li><li>选择另一个进程执行</li><li>恢复处理器上下文</li></ol><h1 id="1-4-进程的组织"><a href="#1-4-进程的组织" class="headerlink" title="1.4 进程的组织"></a>1.4 进程的组织</h1><p>PCB主要包括：进程描述信息、进程控制和管理信息、资源分配清淡和处理器相关信息等</p><p>放了方便进程调度和管理，需要将各进程的PCB用适当的方法组织起来，目前常用的组织方式有连接方式和索引方式两种。连接方式将同一状态的PCB连接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项只想相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p><h1 id="1-5-进程的通信"><a href="#1-5-进程的通信" class="headerlink" title="1.5 进程的通信"></a>1.5 进程的通信</h1><p>（1）共享存储</p><p>在通信的进程之间存在着一款可以直接访问的共享空间，通过对这块共享空间的读写操作时间进程之间的信息交换。</p><p>（2）消息传递</p><p>进程之间的数据交换，是以格式化的消息为单位，在计算机网络中，又称为报文</p><p>（3）管道通信</p><p>管道是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件</p><ul><li>互斥，即当一个进程执行读写操作，其它进程必须等待</li><li>同步</li></ul><h1 id="1-6-线程概念和多线程模型"><a href="#1-6-线程概念和多线程模型" class="headerlink" title="1.6 线程概念和多线程模型"></a>1.6 线程概念和多线程模型</h1><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单元，线程是进程中的一个实体，是被系统独立调度和分配的基本单位</p><p>（1）线程和进程的比较</p><ol><li>调度：线程是独立调度的基本单位，进程是资源拥有的基本单位</li><li>拥有资源：进程是拥有资源的基本单位，而线程只拥有必不可少的资源</li><li>并发性：进程和线程都有并发性，一个进程间的多个线程可并发</li><li>系统开销：线程的开销极小</li><li>地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程共享进程的资源</li><li>通信方面：进程需要保证数据的一致性，而线程可以直接读写进程数据段来进行通信</li></ol><p>（2）线程的属性</p><ol><li>线程是一个轻型实体，只拥有必不可少的资源</li><li>不同的线程可以执行相同的程序</li><li>同一进程中的各个线程共享该进程所有用的系统资源</li><li>线程是处理器的独立调度单位，多个线程是可以并发执行的</li><li>一个线程创建后开始了声明周期，直至终止，会经历等待态、就绪态和运行态</li></ol><p>（3）线程的实现方法</p><p>线程的实现可分为两类：用户级线程和内核级线程</p><ul><li>用户级线程速度快，不用调用核心，但若核心阻塞进程，则进程中所有线程都被阻塞，同一进程中的两个线程不能同时运行于两个处理器上</li></ul><p>（4）多线程模型</p><ol><li>多对一模型：多个用户级线程映射到一个内核级线程</li><li>一对一模型</li><li>多对多模型</li></ol><h1 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2 线程的调度"></a>2 线程的调度</h1><h2 id="2-1-调度的概念"><a href="#2-1-调度的概念" class="headerlink" title="2.1 调度的概念"></a>2.1 调度的概念</h2><p>作业时用户在一次解题或事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据命令等</p><p>一个作业从提交开始直到完成，要经历以下三级调度</p><p>1、作业调度</p><p>作业调度又称高级调度，按照一定原则挑选一个或多个作业，分配内存、输入输出设备等必要资源，并建立相应的进程</p><p>2、中级调度</p><p>又称为内存调度，为了提高内存利用率和系统吞吐率</p><p>3、进程调度</p><p>又称为低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理器分配给它</p><h2 id="2-2-调度的时机、切换与过程"><a href="#2-2-调度的时机、切换与过程" class="headerlink" title="2.2 调度的时机、切换与过程"></a>2.2 调度的时机、切换与过程</h2><p>不能进行进程的调度与切换的情况有以下几种</p><p>1、处理中断过程中：中断处理是系统工作的一部分，逻辑上不属于某一进程</p><p>2、进程在操作系统内存程序临界区中</p><p>3、其他需要完全屏蔽中断的院子操作过程：如加锁、解锁、中断现场保护、恢复等</p><p>如果在上述过程中引发了调度的条件，并不能马上进行调度和切换，系统请求调度标志，上述过程结束后才能进行相应的调度</p><p>应当进行进程调度与切换的情况有</p><p>1、当发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换</p><p>2、当中断处理结束后或自陷处理结束后</p><p>进程切换往往在调度完成后立即发生</p><h2 id="2-3-进程调度方式"><a href="#2-3-进程调度方式" class="headerlink" title="2.3 进程调度方式"></a>2.3 进程调度方式</h2><p>1、非剥夺调度方式</p><p>非剥夺调度方式又称为非抢占式调度，指一个进程正在处理器上执行，有某个更为重要的进程进入就绪状态，仍然让正在执行进程继续执行，直到该进程完成或发生某种事件进入阻塞状态，才把处理器分配给更为重要的进程</p><p>2、剥夺调度方式</p><p>又称为抢占方式，若有某个更为重要的进程需要使用处理器，立即暂停正在执行的进程，将处理器分配给这个更为重要或紧迫的进程</p><h2 id="2-4-调度的基本原则"><a href="#2-4-调度的基本原则" class="headerlink" title="2.4 调度的基本原则"></a>2.4 调度的基本原则</h2><p>1、CPU利用率</p><p>应尽可能使CPU保持在忙状态</p><p>2、系统吞吐量</p><p>表示单位时间内CPU完成作业的数量</p><p>3、周转时间</p><p>4、等待时间</p><p>5、响应时间</p><p>6、具有公平性</p><h2 id="2-5-经典的调度算法"><a href="#2-5-经典的调度算法" class="headerlink" title="2.5 经典的调度算法"></a>2.5 经典的调度算法</h2><p>1、FIFS先来先服务/先进先出（FIFO）调度算法：可用于作业调度，也可以用于进程调度</p><ul><li>有利于长作业，而不利于短作业</li><li>有利于CPU繁忙，不利于IO繁忙</li><li>适用于批处理</li></ul><p>2、SJF短作业优先调度算法</p><p>选择估计运行时间最短的作业先运行  </p><p>3、优先级调度算法</p><ul><li>静态优先权：默认优先数<ul><li>进程的类型</li><li>进程对资源的要求</li><li>用户要求</li></ul></li><li>动态优先权<ul><li>岁等待时间的增加而改变</li></ul></li></ul><p>4、高响应比优先调度算法</p><p>是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</p><p>优先权=（等待时间+要求服务时间）/ 要求服务时间</p><p>对短作业、等待时间越长越有利</p><p>5、时间轮片调度算法</p><p>6、多级反馈队列调度算法</p><h1 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3 进程同步"></a>3 进程同步</h1><h2 id="3-1-进程同步的基本概念"><a href="#3-1-进程同步的基本概念" class="headerlink" title="3.1 进程同步的基本概念"></a>3.1 进程同步的基本概念</h2><p>进程是并发进行的，不同进程存在不同的相互制约关系，为了避免进程之间的冲突，引入进程同步的概念</p><p>1、临界资源</p><p>一次只允许一个进程使用的资源称为邻接资源，对邻接资源的访问，必须互斥的进行</p><p>把临界资源的访问过程分为四个部分</p><ol><li>进入区</li><li>临界区</li><li>退出区</li><li>剩余区</li></ol><p>2、同步</p><p>为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置协调他们的工作次序而等待，传递信息所产生的制约关系，进程间的直接制约关系就是他们之间的相互合作</p><p>遵循的原则：</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待：对要求访问临界资源的进程，应保证在有限时间内进入自己的临界区，防止“死等”</li><li>让权等待：进程不能进入自己临界区时，应立即释放处理机制，防止“忙等”</li></ul><p>3、互斥</p><p>互斥称为间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待</p><h2 id="3-2-实现临界区互斥的基本方法"><a href="#3-2-实现临界区互斥的基本方法" class="headerlink" title="3.2 实现临界区互斥的基本方法"></a>3.2 实现临界区互斥的基本方法</h2><p>1、硬件实现方法</p><ol><li><p>中断屏蔽法</p></li><li><p>硬件指令法（TS）</p></li></ol><h2 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h2><p>1、整型信号量</p><p>被定义为一个用于表示资源个数的整型量</p><p>2、记录型号量</p><p>P(S)和V(S)操作可描述为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(semaphore S)&#123;</span><br><span class="line">S.value&#x3D;S.vauel-1; ##请求一个资源</span><br><span class="line">if(S.value&lt;0) Block(S.L) # 自我阻塞，插入到信号链表S.L中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore S)&#123;</span><br><span class="line">S.value +&#x3D;1</span><br><span class="line">if(S.value&lt;&#x3D;0) wakeup(S.L); # 有进程被阻塞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、利用信号量实现同步</p><p>4、利用信号量实现互斥</p><p>5、利用信号量实现前驱关系</p><h2 id="3-4-管程"><a href="#3-4-管程" class="headerlink" title="3.4 管程"></a>3.4 管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据</p><p>管程由三部分组成：</p><ul><li>局部于管程的共享变量说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部管程的数据设置初始值语句</li><li>管程还必须有一个名字</li></ul><p>在实现管程，必须考虑</p><ol><li>互斥：通常编译程序对每个管程自动产生一个互斥信号量，每次只准许一个进程进入管程，其他调用管程者必须等待</li><li>同步：当某进程通过管程请求临界资源而不能满足时，管程便调用wait原语使用该进程等待，并将它排在等待队列上</li></ol><h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4 死锁"></a>4 死锁</h1><h2 id="4-1-死锁的概念"><a href="#4-1-死锁的概念" class="headerlink" title="4.1 死锁的概念"></a>4.1 死锁的概念</h2><p>多个进程因竞争资源造成的一种僵局，若无外力作用，这些进程都将无法向前推进</p><p>1、系统资源的竞争</p><p>2、进程推进顺序非法</p><p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁</p><p>3、死锁产生的必要条件</p><ol><li><p>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程占用</p></li><li><p>不剥夺条件：进程所获得的资源在未使用完毕前，不能被其它进程强行夺走</p></li><li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p></li><li><p>循环等待条件：存在一种进程循环等待链</p></li></ol><ul><li>参与死锁的进程最少是两个</li><li>至少有两个已经占有资源</li><li>死锁所有进程都在等待资源</li><li>参与死锁的进程是当前系统中所有进程的子集</li></ul><h2 id="4-2-死锁处理策略"><a href="#4-2-死锁处理策略" class="headerlink" title="4.2 死锁处理策略"></a>4.2 死锁处理策略</h2><p>1、破坏死锁的四个必要条件之一</p><p>2、用某种方式防止系统进入不安全状态</p><p>3、允许进程在运行过程中发生死锁，通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁</p><p><strong>死锁预防</strong></p><ul><li>摒弃请求和保持条件：所有进程必须一次性的申请整个运行过程所需的全部资源</li><li>摒弃不可剥夺条件：进程逐个申请所需资源，但是申请新资源不能得到满足时，必须放弃自己所保持的资源</li><li>摒弃环路等待：将资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序</li></ul><p><strong>死锁避免</strong></p><p>在避免死锁的方法，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性</p><p>所谓安全状态，是指系统能按某种进程顺序来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，如果系统无法找到这样一个安全序列，则称系统处于不安全状态</p><p>可以用银行家算法检测安全状态</p><p><strong>死锁检测</strong></p><ul><li>死锁定理：某一时刻系统状态S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全化简的，此充分条件称为死锁定理</li></ul><p><strong>死锁解除</strong></p><p>死锁解除的主要方法有</p><ol><li>资源剥夺法：挂起某些死锁进程，抢占其资源，将这些资源分配给其他死锁进程</li><li>进程撤销法：强制撤销一个或一部分进程并剥夺这些进程的资源</li><li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺</li></ol><hr><h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-进程和线程的区别"><a href="#5-1-进程和线程的区别" class="headerlink" title="5.1 进程和线程的区别"></a>5.1 进程和线程的区别</h2><p>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，而进程正相反</p><h2 id="5-2-进程有哪几种状态"><a href="#5-2-进程有哪几种状态" class="headerlink" title="5.2 进程有哪几种状态"></a>5.2 进程有哪几种状态</h2><ul><li>创建状态：进程正在被创建，尚未到就绪状态</li><li>就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行</li><li>运行状态：进程正在处理器上运行（单核CPU下任意时刻只有一个进程处于运行状态）</li><li>阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成，即使处理器空闲，该进程也不能运行</li><li>结束状态：进程正在从系统中消失，可能是进程正常结束或其他原因中断退出运行</li></ul><h2 id="5-3-进程间的通信方式"><a href="#5-3-进程间的通信方式" class="headerlink" title="5.3 进程间的通信方式"></a>5.3 进程间的通信方式</h2><ol><li>管道/匿名管道：用于具有亲缘关系的父子进程或兄弟进程之间的通信</li><li>有名管道：有名管道严格遵循先进先出，以磁盘文件的方式存在，可以实现本机任意两个进程通信</li><li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列克服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>信号量：信号量是一个计数器，用于多线程对共享数据的访问，信号量的意图在于进程间同步，这种通信方式主要用于解决与同步相关的问题并避免竞争条件</li><li>共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量，可以说是最有用的进程间通信方式</li><li>套接字：此方法主要用于客户端和服务器之间的网络通信</li></ol><h2 id="5-4-线程间的同步方式"><a href="#5-4-线程间的同步方式" class="headerlink" title="5.4 线程间的同步方式"></a>5.4 线程间的同步方式</h2><p>线程同步是两个或多个共享关键资源的线程的并发执行，同步线程以避免关键资源使用冲突</p><ol><li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限</li><li>信号量：允许统一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>时间：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先极的比较</li></ol><h2 id="5-5-进程的调度算法"><a href="#5-5-进程的调度算法" class="headerlink" title="5.5 进程的调度算法"></a>5.5 进程的调度算法</h2><ul><li>先到先服务：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某时间而被阻塞放弃占用CPU时再重新调度</li><li>短作业优先调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源</li><li>时间片轮转调度算法：每个进程被分配一段时间</li><li>优先极调度：为每个流程分配优先级</li><li>高响应比优先调度算法：是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</li><li>多级反馈队列调度算法：即能使高优先级的作业得到响应，又能使短作业迅速完成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1 进程与线程&quot;&gt;&lt;/a&gt;1 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;1-1-进程的概念和特征&quot;&gt;&lt;a href=&quot;#1-1-进程的概念和特征&quot; class=&quot;headerlink&quot; title=&quot;1.1 进程的概念和特征&quot;&gt;&lt;/a&gt;1.1 进程的概念和特征&lt;/h2&gt;&lt;p&gt;（1）进程的概念&lt;/p&gt;
&lt;p&gt;从不同的角度，进程可以由不同的定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程是程序的一次执行过程&lt;/li&gt;
&lt;li&gt;进程是一个程序及其数据在处理器上顺序执行时发生的活动&lt;/li&gt;
&lt;li&gt;进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（一）：操作系统概述</title>
    <link href="https://liangggggg.github.io/2020/08/27/os/"/>
    <id>https://liangggggg.github.io/2020/08/27/os/</id>
    <published>2020-08-27T01:12:59.000Z</published>
    <updated>2020-08-30T03:51:00.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统的概念、特征、功能和提供的服务"><a href="#1-操作系统的概念、特征、功能和提供的服务" class="headerlink" title="1 操作系统的概念、特征、功能和提供的服务"></a>1 操作系统的概念、特征、功能和提供的服务</h1><h2 id="1-1-操作系统的概念"><a href="#1-1-操作系统的概念" class="headerlink" title="1.1 操作系统的概念"></a>1.1 操作系统的概念</h2><p>操作系统的目标</p><ol><li>方便性</li><li>有效性</li><li>可扩充性</li><li>开放性</li></ol><a id="more"></a><h2 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h2><p>（1）并发</p><p>并行性和并发性是即详细又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个时间在同一时间间隔内发生</p><p>在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的实施程序能并发执行。</p><p>（2）共享</p><p>指系统中的可供内存中多个并发执行的进程（线程）共同使用</p><p>1、互斥共享方式</p><p>系统中的某些资源，如打印机、磁带机，虽然他们可以提供给多个进程使用，但为使所打印的内容不致造成混淆，应规定在同一段时间内只允许一个进程方位该资源。</p><p>2、同时访问方式</p><p>系统中还有一种资源，允许在一段时间内由多个进程“同时”对它进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问即“分时共享”。典型的可供多个进程同时访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p><p>（3）虚报</p><p>通过某种技术把一个物理实体变为若干个逻辑上的对应物，物理实体是实的，后者是虚的，用于实现虚拟的技术称为虚拟技术，利用时分复用和控分复用技术实现</p><p>（4）异步</p><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h2 id="1-3-操作系统的功能"><a href="#1-3-操作系统的功能" class="headerlink" title="1.3 操作系统的功能"></a>1.3 操作系统的功能</h2><p>（1）处理机管理功能</p><ol><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>调度<ul><li>作业调度</li><li>进程调度</li></ul></li></ol><p>（2）存储器管理功能</p><ol><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ol><p>（3）设备管理功能</p><ol><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ol><p>（4）文件管理功能</p><ol><li>文件存储空间的管理</li><li>目录管理</li><li>文件读/写管理和保护</li></ol><h2 id="1-4-操作系统所能提供的服务"><a href="#1-4-操作系统所能提供的服务" class="headerlink" title="1.4 操作系统所能提供的服务"></a>1.4 操作系统所能提供的服务</h2><p>（1）OS作为用户与计算机硬件系统之间的接口</p><p>（2）OS作为计算机系统资源的管理者</p><p>硬件和软件资源分为四类：处理机、存储器、I/O设备和文件，OS的主要功能是对这类资源进行有效的管理</p><p>（3）实现了对计算机资源的抽象</p><h1 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2 操作系统的发展与分类"></a>2 操作系统的发展与分类</h1><h2 id="2-1-操作系统的发展"><a href="#2-1-操作系统的发展" class="headerlink" title="2.1 操作系统的发展"></a>2.1 操作系统的发展</h2><p>（1）未配置操作系统的计算机系统</p><p>（2）单道批处理系统</p><p>（3）多道批处理系统</p><p>（4）分时系统</p><p>（5）实时系统</p><h1 id="3-操作系统的运行环境"><a href="#3-操作系统的运行环境" class="headerlink" title="3 操作系统的运行环境"></a>3 操作系统的运行环境</h1><h2 id="3-1-内核态与用户态"><a href="#3-1-内核态与用户态" class="headerlink" title="3.1 内核态与用户态"></a>3.1 内核态与用户态</h2><p>特权指令：有少数指令是为编制系统管理程序专门设置的，只有操作系统才能使用</p><ol><li>有关I/0的指令</li><li>访问程序状态字寄存器的指令</li><li>存取特殊寄存器指令</li><li>其他访问系统状态和直接访问系统资源的指令</li></ol><p>多数系统将处理器工作状态划分为内核态和用户态，前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为特权太、系统太或管态；后者一般指用户程序运行时的状态，具有较低的特权级别，又称普通态、目态</p><p>目态：程序执行时不可使用特权指令</p><p>管态：可以使用特权指令</p><h2 id="3-2-中断、异常"><a href="#3-2-中断、异常" class="headerlink" title="3.2 中断、异常"></a>3.2 中断、异常</h2><p>中断是由与现指令无关的中断信号触发的，且中断的发生与CPU处在用户模型或内核模式无关，在两条机器指令之间才可相应中断</p><p>异常处理程序提供的服务是为当前进程所用的</p><h2 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h2><p>当系统调用发生时，处理器通过一种特殊的机制，通常是中断或者异常处理，把控制流程序转移到监控程序内的一些特定的位置。</p><h1 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4 操作系统体系结构"></a>4 操作系统体系结构</h1><ol><li>无结构操作系统</li><li>模块化结构OS</li><li>分层式结构OS</li><li>微内核OS结构</li></ol><hr><h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-什么是操作系统？"><a href="#5-1-什么是操作系统？" class="headerlink" title="5.1 什么是操作系统？"></a>5.1 什么是操作系统？</h2><ol><li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石</li><li>操作系统本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源</li><li>操作系统存在屏蔽了硬件的复杂性</li><li>操作系统的内核是操作系统的核心部分，它负责内存管理，硬件设备的管理，文件管理以及应用程序的管理</li></ol><h2 id="5-2-系统调用"><a href="#5-2-系统调用" class="headerlink" title="5.2 系统调用"></a>5.2 系统调用</h2><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态：用户态运行的进程或可以直接读取用户程序的数据</li><li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</li></ol><p>在运行用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等）都必须经过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p><p>按系统调用功能大致可以分为如下几类：</p><ol><li>设备管理：完成设备请求或释放，以及设备启动等功能</li><li>文件管理：完成文件的读、写、创建以及删除等功能</li><li>进程控制：完成进程的创建、撤销、阻塞、唤醒等功能</li><li>进程通信：完成进程之间的消息传递或信号传递等功能</li><li>内存管理：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-操作系统的概念、特征、功能和提供的服务&quot;&gt;&lt;a href=&quot;#1-操作系统的概念、特征、功能和提供的服务&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统的概念、特征、功能和提供的服务&quot;&gt;&lt;/a&gt;1 操作系统的概念、特征、功能和提供的服务&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统的概念&quot;&gt;&lt;a href=&quot;#1-1-操作系统的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 操作系统的概念&quot;&gt;&lt;/a&gt;1.1 操作系统的概念&lt;/h2&gt;&lt;p&gt;操作系统的目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方便性&lt;/li&gt;
&lt;li&gt;有效性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;开放性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（六）：排序</title>
    <link href="https://liangggggg.github.io/2020/08/18/Data6/"/>
    <id>https://liangggggg.github.io/2020/08/18/Data6/</id>
    <published>2020-08-18T01:12:59.000Z</published>
    <updated>2020-08-28T02:44:02.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>逐个向有序表中进行插入操作</p><p>初始关键字序列：  [7]    4    -2    19    13    6    ；<br>第一趟排序后：    [4    7]    -2    19    13    6    ；<br>第二趟排序后：    [-2    4    7]    19    13    6    ；<br>第三趟排序后：    [-2    4    7    19]    13    6    ；<br>第四趟排序后：    [-2    4    7    13    19]    6    ；<br>第五趟排序后：    [-2    4    6    7    13    19]    ；</p><a id="more"></a><p><img src="https://note.youdao.com/yws/api/personal/file/FF99682334F14D6C8BDC28A7D301BB17?method=download&shareKey=18c14c8e31ea2e76032d125fea69224f" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def insertionSort(arr): </span><br><span class="line">  </span><br><span class="line">    for i in range(1, len(arr)): </span><br><span class="line">  </span><br><span class="line">        key &#x3D; arr[i] </span><br><span class="line">  </span><br><span class="line">        j &#x3D; i-1</span><br><span class="line">        while j &gt;&#x3D;0 and key &lt; arr[j] : </span><br><span class="line">                arr[j+1] &#x3D; arr[j] </span><br><span class="line">                j -&#x3D; 1</span><br><span class="line">        arr[j+1] &#x3D; key </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6] </span><br><span class="line">insertionSort(arr) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(len(arr)): </span><br><span class="line">    print (&quot;%d&quot; %arr[i])</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：仅用了一个辅助单元，空间复杂度为$O(1)$</p><p>（2）时间效率：向有序表逐个插入记录操作，进行了$n-1$趟，每趟操作分为比较关键码和移动记录，直接插入最好情况为$O(n)$，平均时间复杂度$O(n^2)$</p><p>（3）稳定性：稳定</p><h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>折半插入排序是利用折半查找实现在有序表$R[1,i-1]$中查找$R[i]$的插入位置</p><p>对下列序列进行排序：{30，13，70，85，39，42，6，20}，并写出排序的过程。<br>对排序表：30，13，70，85，39，42，6，20 进行划分<br>设初始状态：</p><p>第一趟排序：    (30) 13    70    85    39    42    6 20<br>第二趟排序：    (13    30)    70    85    39    42    6 20<br>第三趟排序：    (13    30    70)    85    39    42    6 20<br>第七趟排序：    (6    13    30    39    42    70    85)    20<br>第八趟排序：    (6    13    30    39    42    70    85)    20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def binaryInsert(a):</span><br><span class="line"># 折半插入排序: 小-&gt;大</span><br><span class="line"># 在直接插入排序的基础上使用了折半查找的方法 </span><br><span class="line">    for i in xrange(1, len(a)):</span><br><span class="line">        index &#x3D; a[i]</span><br><span class="line">        low &#x3D; 0</span><br><span class="line">        hight &#x3D; i - 1</span><br><span class="line">        while low &lt;&#x3D; hight:</span><br><span class="line">            mid &#x3D; (low + hight) &#x2F; 2</span><br><span class="line">            if index &gt; a[mid]:</span><br><span class="line">                low &#x3D; mid + 1</span><br><span class="line">            else:</span><br><span class="line">                hight &#x3D; mid - 1</span><br><span class="line">        # 跳出循环后 low, mid 都是一样的, hight &#x3D; low - 1</span><br><span class="line">        for j in xrange(i, low, -1):</span><br><span class="line">            a[j] &#x3D; a[j - 1]</span><br><span class="line">        a[low] &#x3D; index</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h2><p>交换排序是通过两两比较待排序记录的关键码，若发生排序要求相逆，则交换之</p><p>对下列序列排序{23，38，22，45，23，67，31，15，41}写出冒泡排序的过程。</p><p>初始关键字序列：  23    38    22    45    23    67    31    15    41；<br>第一趟排序后：    23    22    38    33    45    31    15    41    61；<br>第二趟排序后：    22    23    23    38    31    15    41    45    67；<br>第三趟排序后：    22    23    23    31    15    38    41    45    67；<br>第四趟排序后：    22    23    23    15    31    38    41    45    67；<br>第五趟排序后：    22    23    15    23    31    38    41    45    67；<br>第六趟排序后：    22    15    23    23    31    38    41    45    67；<br>第七趟排序后：    15    22    23    23    31    38    41    45    67；</p><p><img src="https://note.youdao.com/yws/api/personal/file/7761644612D44FC58115EF304F360F80?method=download&shareKey=16637b3bb70a29545e6cd6dcae641d40" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(arr):</span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line"> </span><br><span class="line">    # 遍历所有数组元素</span><br><span class="line">    for i in range(n):</span><br><span class="line"> </span><br><span class="line">        # Last i elements are already in place</span><br><span class="line">        for j in range(0, n-i-1):</span><br><span class="line"> </span><br><span class="line">            if arr[j] &gt; arr[j+1] :</span><br><span class="line">                arr[j], arr[j+1] &#x3D; arr[j+1], arr[j]</span><br><span class="line"> </span><br><span class="line">arr &#x3D; [64, 34, 25, 12, 22, 11, 90]</span><br><span class="line"> </span><br><span class="line">bubbleSort(arr)</span><br><span class="line"> </span><br><span class="line">print (&quot;排序后的数组:&quot;)</span><br><span class="line">for i in range(len(arr)):</span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：最好情况$O(n)$，平均时间复杂度为$O(n^2)$</p><p>（3）稳定性：稳定</p><h1 id="3-简单选择排序"><a href="#3-简单选择排序" class="headerlink" title="3 简单选择排序"></a>3 简单选择排序</h1><p>从无序序列$R[i..n]$的$n-i+1$记录中选出关键字最小的记录加入有序序列</p><p>对下列序列排序{49，14，38，74，96，65，49，8，55，27}；</p><p>第 1 趟之后：8    14    38    74    96    65    49    49    55    27<br>第 2 趟之后：8    14    38    74    96    65    49    49    55    27<br>（在本位就不用交换）<br>第 3 趟之后：8    14    27    74    96    65    49    49    55    38<br>第 4 趟之后：8    14    27    49    96    65    74    49    55    38</p><p><img src="https://note.youdao.com/yws/api/personal/file/6A3A3EAE3343434E8E6699BAA353F38F?method=download&shareKey=58632ab023763519c4fb1b6d1bbd7abf" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import sys </span><br><span class="line">A &#x3D; [64, 25, 12, 22, 11] </span><br><span class="line">  </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line">    min_idx &#x3D; i </span><br><span class="line">    for j in range(i+1, len(A)): </span><br><span class="line">        if A[min_idx] &gt; A[j]: </span><br><span class="line">            min_idx &#x3D; j </span><br><span class="line">                </span><br><span class="line">    A[i], A[min_idx] &#x3D; A[min_idx], A[i] </span><br><span class="line">  </span><br><span class="line">print (&quot;排序后的数组：&quot;) </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">    print(&quot;%d&quot; %A[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：最好和平均时间复杂度均为$O(n^2)$</p><p>（3）稳定性：从前往后比较稳定，从后往前比较不稳定</p><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h1><p>直接插入排序的改进版本，希尔排序把序列按一定间隔分组，对每组使用直接插入排序；随着间隔减小，一直到1，使得整个序列有序</p><p><img src="https://note.youdao.com/yws/api/personal/file/7A971CDA8CA34300AE79B58854A8067B?method=download&shareKey=a6c84b288f98376985ad2214b2179a2f" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(arr): </span><br><span class="line">  </span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line">    gap &#x3D; int(n&#x2F;2)</span><br><span class="line">  </span><br><span class="line">    while gap &gt; 0: </span><br><span class="line">  </span><br><span class="line">        for i in range(gap,n): </span><br><span class="line">  </span><br><span class="line">            temp &#x3D; arr[i] </span><br><span class="line">            j &#x3D; i </span><br><span class="line">            while  j &gt;&#x3D; gap and arr[j-gap] &gt;temp: </span><br><span class="line">                arr[j] &#x3D; arr[j-gap] </span><br><span class="line">                j -&#x3D; gap </span><br><span class="line">            arr[j] &#x3D; temp </span><br><span class="line">        gap &#x3D; int(gap&#x2F;2)</span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 34, 54, 2, 3] </span><br><span class="line">  </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序前:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]), </span><br><span class="line">  </span><br><span class="line">shellSort(arr) </span><br><span class="line">  </span><br><span class="line">print (&quot;\n排序后:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：依赖于步长的选取</p><p>（3）稳定性：不稳定</p><h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h1><p>以某个记录为界（该点称为支点）,将待排序列分成两部分。其中，一部分所有记录的关键码大于等于支点记录的关键码，另一部分所有记录的关键码小于支点记录的关键码，将此过程称为一次划分，对各部分不断划分，直到整个序列按关键码有序</p><p>设置指针low,high，初始值为第一个和最后一个记录的位置，设两个变量$i,j$，令$i=low，j=high$，以$R[low].key$作为基准（将$R[low]保存在R[0]$）</p><ol><li><p>从$j$所指位置向前搜索：将$R[0].key$与$R[j].key$进行比较</p><ul><li>若$R[0].key&lt;=R[j].key$：令$j=j-1$，然后继续进行比较，直到$i=j$或$R[0].key&gt;=R[j].key$为止；</li><li>若$R[0].key&gt;R[j].key$：$R[j]=R[i]$，腾出$R[j]$的位置，且令$i=i+1$;</li></ul></li><li><p>从$i$所指位置起向后搜索：将$R[0].key$与$R[i].key$进行比较：</p><ul><li>若$R[0].key&gt;=R[i].key$:令$i=i+1$，然后进行比较，直到$i=j$或$R[0].key&lt;R[i].key$为止；</li><li>若$R[0].key&lt;R[i].key$:令$R[i]=R[j]$，腾出$R[i]$的位置，且令$j=j-1$;</li></ul></li><li><p>重复1，2直至$i=j$为止，$i$就是$R[0]$所应放置的位置</p></li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/519327C530694B5594AF6E9DFE3077DF?method=download&shareKey=7556ec6121cdbc1262ee7d150e0de45e" alt></p><p>当进行一趟快速排序后，采用相同方法分别对两个子序列快速排序，直至子序列记录个为1为止<br><img src="https://note.youdao.com/yws/api/personal/file/4A0267871158449CBE0A83CCA16D8393?method=download&shareKey=da100567e02c7e17747e6d32b1edba56" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def partition(arr,low,high): </span><br><span class="line">    i &#x3D; ( low-1 )         # 最小元素索引</span><br><span class="line">    pivot &#x3D; arr[high]     </span><br><span class="line">  </span><br><span class="line">    for j in range(low , high): </span><br><span class="line">  </span><br><span class="line">        # 当前元素小于或等于 pivot </span><br><span class="line">        if   arr[j] &lt;&#x3D; pivot: </span><br><span class="line">          </span><br><span class="line">            i &#x3D; i+1 </span><br><span class="line">            arr[i],arr[j] &#x3D; arr[j],arr[i] </span><br><span class="line">  </span><br><span class="line">    arr[i+1],arr[high] &#x3D; arr[high],arr[i+1] </span><br><span class="line">    return ( i+1 ) </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"># arr[] --&gt; 排序数组</span><br><span class="line"># low  --&gt; 起始索引</span><br><span class="line"># high  --&gt; 结束索引</span><br><span class="line">  </span><br><span class="line"># 快速排序函数</span><br><span class="line">def quickSort(arr,low,high): </span><br><span class="line">    if low &lt; high: </span><br><span class="line">  </span><br><span class="line">        pi &#x3D; partition(arr,low,high) </span><br><span class="line">  </span><br><span class="line">        quickSort(arr, low, pi-1) </span><br><span class="line">        quickSort(arr, pi+1, high) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [10, 7, 8, 9, 1, 5] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">quickSort(arr,0,n-1) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(nlog_2n)$</p><p>（2）时间效率：最好$O(nlog_2n)$，最坏$O(n^2)$</p><p>（3）稳定性：不稳定</p><h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h1><h2 id="6-1-堆的性质"><a href="#6-1-堆的性质" class="headerlink" title="6.1 堆的性质"></a>6.1 堆的性质</h2><ol><li>堆是一棵采用顺序存储结构的完全二叉树，$k_1$是根结点</li><li>根结点是关键字序列中最小（或最大）值，分别称为小（或大）根堆</li><li>从根结点到每一叶子结点路径上的元素组成的序列都是按元素值非递减（或非递增）</li><li>堆中的任一子树也是堆</li></ol><p>利用堆顶记录的关键字最小（或最大）性质，从当前待排序的记录中依次选取关键字最小（或最大）的记录，实现对数据记录的排序，称为堆排序</p><h2 id="6-2-堆排序思想"><a href="#6-2-堆排序思想" class="headerlink" title="6.2 堆排序思想"></a>6.2 堆排序思想</h2><ol><li>对一组待排序的记录，按堆定义建堆</li><li>将堆顶记录和最后一个记录交换位置，则前$n-1$个记录是无序的，最后一个记录有序的</li><li>堆顶记录被交换后，前$n-1$个记录不再是堆，需要重新调整为一个堆，重复2操作，直到全部记录排好序</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/548842621E8D4AACAB1CD7FD7DC5DD5A?method=download&shareKey=b859872f37b596a5ded5f420bf786943" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def heapify(arr, n, i): </span><br><span class="line">    largest &#x3D; i  </span><br><span class="line">    l &#x3D; 2 * i + 1     # left &#x3D; 2*i + 1 </span><br><span class="line">    r &#x3D; 2 * i + 2     # right &#x3D; 2*i + 2 </span><br><span class="line">  </span><br><span class="line">    if l &lt; n and arr[i] &lt; arr[l]: </span><br><span class="line">        largest &#x3D; l </span><br><span class="line">  </span><br><span class="line">    if r &lt; n and arr[largest] &lt; arr[r]: </span><br><span class="line">        largest &#x3D; r </span><br><span class="line">  </span><br><span class="line">    if largest !&#x3D; i: </span><br><span class="line">        arr[i],arr[largest] &#x3D; arr[largest],arr[i]  # 交换</span><br><span class="line">  </span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">  </span><br><span class="line">def heapSort(arr): </span><br><span class="line">    n &#x3D; len(arr) </span><br><span class="line">  </span><br><span class="line">    # Build a maxheap. </span><br><span class="line">    for i in range(n, -1, -1): </span><br><span class="line">        heapify(arr, n, i) </span><br><span class="line">  </span><br><span class="line">    # 一个个交换元素</span><br><span class="line">    for i in range(n-1, 0, -1): </span><br><span class="line">        arr[i], arr[0] &#x3D; arr[0], arr[i]   # 交换</span><br><span class="line">        heapify(arr, i, 0) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 11, 13, 5, 6, 7] </span><br><span class="line">heapSort(arr) </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序后&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：$O(nlog_2n)$</p><p>（3）稳定性：不稳定</p><h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h1><ol><li>将序列划分成$n$个待排的长度为1的子序列</li><li>对所有子序列进行两两归并，得到$n/2$个长度为2或1的有序子序列</li><li>重复2，直到得到长度为n的有序序列为止</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/550329FAA2224DA1909CCE2C53C7C862?method=download&shareKey=75cb313577311fe8a6540ffb19003dd3" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">def merge(arr, l, m, r): </span><br><span class="line">    n1 &#x3D; m - l + 1</span><br><span class="line">    n2 &#x3D; r- m </span><br><span class="line">  </span><br><span class="line">    # 创建临时数组</span><br><span class="line">    L &#x3D; [0] * (n1)</span><br><span class="line">    R &#x3D; [0] * (n2)</span><br><span class="line">  </span><br><span class="line">    # 拷贝数据到临时数组 arrays L[] 和 R[] </span><br><span class="line">    for i in range(0 , n1): </span><br><span class="line">        L[i] &#x3D; arr[l + i] </span><br><span class="line">  </span><br><span class="line">    for j in range(0 , n2): </span><br><span class="line">        R[j] &#x3D; arr[m + 1 + j] </span><br><span class="line">  </span><br><span class="line">    # 归并临时数组到 arr[l..r] </span><br><span class="line">    i &#x3D; 0     # 初始化第一个子数组的索引</span><br><span class="line">    j &#x3D; 0     # 初始化第二个子数组的索引</span><br><span class="line">    k &#x3D; l     # 初始归并子数组的索引</span><br><span class="line">  </span><br><span class="line">    while i &lt; n1 and j &lt; n2 : </span><br><span class="line">        if L[i] &lt;&#x3D; R[j]: </span><br><span class="line">            arr[k] &#x3D; L[i] </span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else: </span><br><span class="line">            arr[k] &#x3D; R[j] </span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 L[] 的保留元素</span><br><span class="line">    while i &lt; n1: </span><br><span class="line">        arr[k] &#x3D; L[i] </span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 R[] 的保留元素</span><br><span class="line">    while j &lt; n2: </span><br><span class="line">        arr[k] &#x3D; R[j] </span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">def mergeSort(arr,l,r): </span><br><span class="line">    if l &lt; r: </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        m &#x3D; int((l+(r-1))&#x2F;2)</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+1, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6, 7] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;给定的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]), </span><br><span class="line">  </span><br><span class="line">mergeSort(arr,0,n-1) </span><br><span class="line">print (&quot;\n\n排序后的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：<br>（1）空间复杂度：$O(n)$</p><p>（2）时间复杂度：$O(nlog_2n)$</p><p>（3）稳定性：稳定</p><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h1><ol><li>待排序记录以指针相链，构成一个链表</li><li>分配时，按当前关键字所取值，将记录分配到不同的链队列中，每个队列中记录的关键字相同</li><li>收集时，按当前关键字位取值从小到大将各队列首尾相链成一个链表</li><li>对每个关键字位均重复2，3</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/E9DF1FF414E54E1286F6D076F1E31085?method=download&shareKey=9810a1638a78b374beff7ec84f5f424b" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def countSort(arr): </span><br><span class="line">  </span><br><span class="line">    output &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    count &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    ans &#x3D; [&quot;&quot; for _ in arr] </span><br><span class="line">  </span><br><span class="line">    for i in arr: </span><br><span class="line">        count[ord(i)] +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(256): </span><br><span class="line">        count[i] +&#x3D; count[i-1] </span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        output[count[ord(arr[i])]-1] &#x3D; arr[i] </span><br><span class="line">        count[ord(arr[i])] -&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        ans[i] &#x3D; output[i] </span><br><span class="line">    return ans  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; &quot;wwwrunoobcom&quot;</span><br><span class="line">ans &#x3D; countSort(arr) </span><br><span class="line">print ( &quot;字符数组排序 %s&quot;  %(&quot;&quot;.join(ans)) )</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(rd)$</p><p>（2）时间效率：$O(d(n+rd))$</p><p>（3）稳定性：稳定</p><h1 id="9-各排序算法性能总结"><a href="#9-各排序算法性能总结" class="headerlink" title="9 各排序算法性能总结"></a>9 各排序算法性能总结</h1><table><thead><tr><th align="center">排序方法</th><th align="center">平均时间性能</th><th align="center">最好时间性能</th><th align="center">最坏性能</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">直接插入</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">简单选择</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">$O(nlog_2n)-O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(nlog_2n)-O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(nlog_2n)$</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+rd))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(n+rd)$</td><td align="center">稳定</td></tr></tbody></table><p>基数排序中，$r$代表关键字的基数，$d$代表长度，$n$代表关键字的个数</p><p>关于时间复杂度：</p><ol><li>平方阶（$O(n^2)$）排序，各类简单排序：直接插入、直接选择、冒泡排序</li><li>线性对数阶（$O(nlog2n)$）排序：快速排序，堆排序和归并排序</li><li>$O(n1+\epsilon)$：希尔排序</li><li>线性阶$O(n)$：计数排序</li></ol><p>关于稳定性：</p><ol><li>稳定：冒泡、插入、归并、计数</li><li>不稳定：选择、快速、希尔、堆排序</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1 插入排序&quot;&gt;&lt;/a&gt;1 插入排序&lt;/h1&gt;&lt;h2 id=&quot;1-1-直接插入排序&quot;&gt;&lt;a href=&quot;#1-1-直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.1 直接插入排序&quot;&gt;&lt;/a&gt;1.1 直接插入排序&lt;/h2&gt;&lt;p&gt;逐个向有序表中进行插入操作&lt;/p&gt;
&lt;p&gt;初始关键字序列：  [7]    4    -2    19    13    6    ；&lt;br&gt;第一趟排序后：    [4    7]    -2    19    13    6    ；&lt;br&gt;第二趟排序后：    [-2    4    7]    19    13    6    ；&lt;br&gt;第三趟排序后：    [-2    4    7    19]    13    6    ；&lt;br&gt;第四趟排序后：    [-2    4    7    13    19]    6    ；&lt;br&gt;第五趟排序后：    [-2    4    6    7    13    19]    ；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（六）：应用层</title>
    <link href="https://liangggggg.github.io/2020/08/17/network6/"/>
    <id>https://liangggggg.github.io/2020/08/17/network6/</id>
    <published>2020-08-17T01:47:42.000Z</published>
    <updated>2020-08-30T03:26:59.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络应用模型"><a href="#1-网络应用模型" class="headerlink" title="1 网络应用模型"></a>1 网络应用模型</h1><h2 id="1-1-客户-服务器模型"><a href="#1-1-客户-服务器模型" class="headerlink" title="1.1 客户/服务器模型"></a>1.1 客户/服务器模型</h2><p>分为客户和服务器</p><h2 id="1-2-P2P模型"><a href="#1-2-P2P模型" class="headerlink" title="1.2 P2P模型"></a>1.2 P2P模型</h2><p>两台主机通信不区分哪一个是服务请求那有个是服务器提供方，进行平等，对等连接通信</p><a id="more"></a><h1 id="2-DNS系统"><a href="#2-DNS系统" class="headerlink" title="2 DNS系统"></a>2 DNS系统</h1><p>DNS基于UDP协议实现</p><p>采用层次树桩结构的命名方式</p><p>（1）根域名服务器</p><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器</p><p>（2）顶级域名服务器</p><p>负责管理在该顶级域名服务器注册的所有二级域名</p><p>（3）权限域名服务器</p><p>（4）本地域名服务器</p><p>本地域名服务器采用迭代查询</p><h1 id="3-FTP"><a href="#3-FTP" class="headerlink" title="3 FTP"></a>3 FTP</h1><p>使用TCP可靠的传输服务，主进程工作步骤如下</p><p>（1）打开熟知端口，使客户进程能够连接上</p><p>（2）等待客户进程发出连接请求</p><p>（3）启动从属进程处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程</p><p>（4）回到等待状态，继续接受其他客户进程发来的请求</p><h1 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h1><p>（1）MIME</p><p>SMTP有以下缺点</p><ol><li>不能传送可执行文件或其他二进制对象</li><li>限于传送7位ASCII码</li><li>SMTP服务器会拒绝超过一定长度的邮件</li><li>某些SMTP的实现并没有完全按照SMTP互联网标准</li></ol><p>于是提出了互联网邮件扩充MIME</p><p>（2）SMTP协议</p><p>规定了两个相互通信的SMTP进程之间如何交换信息</p><p>（3）POP</p><p>邮局协议POP是一个非常简单、但功能有限的邮件读取协议</p><h1 id="5-WWW"><a href="#5-WWW" class="headerlink" title="5 WWW"></a>5 WWW</h1><p>并非某种特殊的计算机网络，是一个大规模的、联机式的信息储藏所，能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息，这种访问方式称为链接</p><h1 id="6-HTTP协议"><a href="#6-HTTP协议" class="headerlink" title="6 HTTP协议"></a>6 HTTP协议</h1><p>HTTP是面向事务的应用层协议</p><p><img src="https://note.youdao.com/yws/api/personal/file/A52B3CB112F24C5E9369903B8FEB75A7?method=download&shareKey=811633ce773f37161ee8950040f2b30c" alt></p><p>用户点击鼠标后所发生的时间</p><ol><li>浏览器分析超链接所指向页面的URL</li><li>浏览器想DNS请求<a href="http://www.tsinghua.edu.cn的IP地址" target="_blank" rel="noopener">www.tsinghua.edu.cn的IP地址</a></li><li>域名系统DNS解析出清华大学服务器IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器给出相应，把文件发给浏览器</li><li>TCP连接释放</li><li>浏览器显示文本文件内容</li></ol><p>HTTP两类报文：</p><p>（1）请求报文————从客户想服务器发送请求报文</p><p>（2）响应报文————从服务器到客户的回答</p><hr><h1 id="7-常见面试问题总结"><a href="#7-常见面试问题总结" class="headerlink" title="7 常见面试问题总结"></a>7 常见面试问题总结</h1><h2 id="7-1-在浏览器输入url地址，显示主页的过程"><a href="#7-1-在浏览器输入url地址，显示主页的过程" class="headerlink" title="7.1 在浏览器输入url地址，显示主页的过程"></a>7.1 在浏览器输入url地址，显示主页的过程</h2><p>总体来说分为以下几个过程</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理并换回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/73A4BC32978B40C59BA640BB36EC3F56?method=download&shareKey=f38ebfffcb05bc48176deed0c0ed2c7a" alt></p><h2 id="7-2-状态码"><a href="#7-2-状态码" class="headerlink" title="7.2 状态码"></a>7.2 状态码</h2><p><img src="https://note.youdao.com/yws/api/personal/file/3BEA8247A061405F821B87E697558037?method=download&shareKey=8281ad343ddc80a635d32d1eff1f3216" alt></p><h2 id="7-3-各种协议与HTTP协议之间的关系"><a href="#7-3-各种协议与HTTP协议之间的关系" class="headerlink" title="7.3 各种协议与HTTP协议之间的关系"></a>7.3 各种协议与HTTP协议之间的关系</h2><p><img src="https://note.youdao.com/yws/api/personal/file/DC3E01C9A25B4DCE99F6018F5A51636F?method=download&shareKey=5017d608dee88ba4252fd3c868f7d7c2" alt></p><h2 id="7-4-HTTP长连接，短连接"><a href="#7-4-HTTP长连接，短连接" class="headerlink" title="7.4 HTTP长连接，短连接"></a>7.4 HTTP长连接，短连接</h2><p>在HTTP/1.0中默认使用短连接，也就是说，客户端和服务端每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>从HTTP/1.1起，默认使用长连接，用以保持连接特性，在当一个网页打开完成后，客户端和服务器之间用于传输HTTP的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用一条已经建立的连接</p><h2 id="7-5-HTTP是不保存状态的协议，如何保存用户状态"><a href="#7-5-HTTP是不保存状态的协议，如何保存用户状态" class="headerlink" title="7.5 HTTP是不保存状态的协议，如何保存用户状态"></a>7.5 HTTP是不保存状态的协议，如何保存用户状态</h2><p>HTTP协议自身不对请求和相应之间的通信状态进行保存，Session机制的存在可以通过服务端记录用户的状态</p><p>在服务端保存Session的方法，最常用的就是内存和数据库，通过Cookie中附加一个Session ID来跟踪</p><p>Cookie被禁用怎么办？</p><p>最常用的就是利用URL重写把Session ID直接附加在URL路径的后面</p><h2 id="7-6-Cookie的作用是什么？和Session有什么区别？"><a href="#7-6-Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="7.6 Cookie的作用是什么？和Session有什么区别？"></a>7.6 Cookie的作用是什么？和Session有什么区别？</h2><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样</p><p>Cookie一般用来保存用户信息</p><p>Session主要作用就是通过服务端记录用户的状态</p><h2 id="7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？"><a href="#7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？" class="headerlink" title="7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？"></a>7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？</h2><ol><li>长连接</li><li>错误状态响应码</li><li>缓存处理</li><li>带宽优化及网络连接的使用</li></ol><h2 id="7-8-URI和URL的区别是什么？"><a href="#7-8-URI和URL的区别是什么？" class="headerlink" title="7.8 URI和URL的区别是什么？"></a>7.8 URI和URL的区别是什么？</h2><ul><li>URI是统一资源标志符，可以唯一标志一个资源</li><li>URL是统一资源定位符，可以提供该资源的路径</li></ul><h2 id="7-9-HTTP和HTTPS的区别"><a href="#7-9-HTTP和HTTPS的区别" class="headerlink" title="7.9 HTTP和HTTPS的区别"></a>7.9 HTTP和HTTPS的区别</h2><ol><li>端口：HTTP默认端口为80，而HTTPS默认端口443</li><li>安全性和资源消耗：HTTP协议运行在TCP纸上。所有传输的内容都是明文，客户端和服务器都无法验证对方的身份，HTTPS运行在SSL/TLS纸上的HTTP协议，所有传输内容都经过加密，加密采用对称加密，但密钥用服务器的证书使用非对称加密<ul><li>对称加密：密钥只有一个，加密解密为同一密码，典型的对称加密算法有：DES、AES等</li><li>非对称加密：密钥成对出现，加密解密使用不同密钥</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-网络应用模型&quot;&gt;&lt;a href=&quot;#1-网络应用模型&quot; class=&quot;headerlink&quot; title=&quot;1 网络应用模型&quot;&gt;&lt;/a&gt;1 网络应用模型&lt;/h1&gt;&lt;h2 id=&quot;1-1-客户-服务器模型&quot;&gt;&lt;a href=&quot;#1-1-客户-服务器模型&quot; class=&quot;headerlink&quot; title=&quot;1.1 客户/服务器模型&quot;&gt;&lt;/a&gt;1.1 客户/服务器模型&lt;/h2&gt;&lt;p&gt;分为客户和服务器&lt;/p&gt;
&lt;h2 id=&quot;1-2-P2P模型&quot;&gt;&lt;a href=&quot;#1-2-P2P模型&quot; class=&quot;headerlink&quot; title=&quot;1.2 P2P模型&quot;&gt;&lt;/a&gt;1.2 P2P模型&lt;/h2&gt;&lt;p&gt;两台主机通信不区分哪一个是服务请求那有个是服务器提供方，进行平等，对等连接通信&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（五）：查找</title>
    <link href="https://liangggggg.github.io/2020/08/17/Data5/"/>
    <id>https://liangggggg.github.io/2020/08/17/Data5/</id>
    <published>2020-08-17T00:12:59.000Z</published>
    <updated>2020-08-27T03:28:25.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1 查找的基本概念"></a>1 查找的基本概念</h1><p>查找有两种基本形态：静态查找和动态查找</p><ul><li>静态查找：在查找时只对数据元素进行查询或检索，查找表称为静态查找表</li><li>动态查找：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录</li></ul><p>根据存储结构的不同，查找方法分为三大类：</p><ol><li>顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较，找到要查找的记录</li><li>散列表的查找：根据给定的K值直接访问查找表，从而找到要查找的记录</li><li>索引查找表的查找：首先根据索引确定待查找记录所在的块，然后再从块中找到要查找的记录</li></ol><a id="more"></a><p>平均查找长度</p><p>为确定数据元素在列表中的位置，需给定值进行比较的关键字个数的期望值</p><p>$$ASL = \sum_{i=1}^n p_i * C_i, \  \sum_{i=1}^n p_i = 1$$</p><p>$p_i$：查找第$i$个记录的概率<br>$C_i$：查找第$i$个记录需要进行比较的次数</p><h1 id="2-顺序查找法"><a href="#2-顺序查找法" class="headerlink" title="2. 顺序查找法"></a>2. 顺序查找法</h1><p>将查找表作为一个线性表，可以是顺序表，也可以使链表，依次进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_SIZE 100</span><br><span class="line">typedef struct SSTable</span><br><span class="line">&#123;</span><br><span class="line">RecType elem[MAX_SIZE]</span><br><span class="line">int length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line">int Seq_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">int p;</span><br><span class="line">ST.elem[0].key&#x3D;key; # 设置监视哨兵，失败返回0</span><br><span class="line">for(p&#x3D;ST.length; ST.elem[p].key!&#x3D;key;p--) return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设查找每个记录的概率相等，即$P_i = 1/n$，查找第$i$个元素成功的比较次数$C_i  = n-i+1$</p><p>查找成功时：<br>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$$</p><p>查找不成功时：比较次数为$n+1$，概率为$P_1 = 1/(2n)$</p><p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{2n}\sum_{i=1}^n(n-i+1)+\frac{n+1}{2}=\frac{3(n+1)}{4}$$</p><h1 id="3-分块查找法"><a href="#3-分块查找法" class="headerlink" title="3 分块查找法"></a>3 分块查找法</h1><p>分块查找的基本思想是：将表分成n块，每一块中的关键字不一定有序，但前一块中最大关键字必须小于后一块的最小关键字，即要求表示“分块有序的”。首先查找索引表，因为索引表是有序表，确定待查结点是在哪一块，然后再已确定的块中进行顺序查找</p><p>线性表中共有$n$个结点，分成大小相等的$b$块，每块有$s=n/b$个结点，假定对索引表也采用顺序查找，值考虑查找成功的情况，并假定对每个结点的查找概率是相等的</p><p>$$E_b = \sum_{i=1}^b(i* \frac{1}{b})=\frac{b+1}{2}$$</p><p>$$E_w = \sum_{i=1}^s(i*\frac{1}{s})=\frac{s+1}{2}$$</p><p>所以：</p><p>$$E(n)=E_b+E_w = \frac{b+1}{2}+\frac{s+1}{2}=\frac{n+s^2}{2s}+1$$</p><p>当$s=\sqrt{n}，E(n)取最小值$</p><p>$$E(n)=\sqrt{n}+1\approx \sqrt{n}$$</p><h1 id="4-折半查找法"><a href="#4-折半查找法" class="headerlink" title="4 折半查找法"></a>4 折半查找法</h1><p>折半查找要求查找表顺序存储结构且各数据元素按关键字有序排序，也就是说折半查找只适用于对有序顺序表进行查找</p><p>（1）查找思想<br>用Low、High和Mid表示待查找区间的下界、上届和中间位置指针，初值为Low=1,High=n</p><p>取中间位置$Mid: Mid = floor[(Low+High)/2]$</p><p>比较中间位置记录的关键字与给定的K值</p><ol><li>相等:查找成功</li><li>大于：待查找记录在区间的前半段，修改上界指针：High = Mid -1,转1</li><li>小于：待查记录在区间的后半段，修改下界指针：Low = Mid +1，转1</li></ol><p>直到越界(Low&gt;High)，查找失败 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Bin_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">int Low&#x3D;1, High&#x3D;ST.length, Mid;</span><br><span class="line">while(Low&lt;&#x3D;High)</span><br><span class="line">&#123;</span><br><span class="line">if(ST.elem[Mid].key&#x3D;&#x3D;key) return Mid;</span><br><span class="line">else if(ST.elem[Mid].key&lt;key) Low&#x3D;Mid+1;</span><br><span class="line">else High&#x3D;Mid-1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）算法分析<br>经过每一次查找，查找范围就缩小一半，该过程可用一颗二叉树表示，所得到的二叉树为判定书</p><p><img src="https://note.youdao.com/yws/api/personal/file/D88D43B8E643426EAB6B2364BFF63C6F?method=download&shareKey=3fa93bd5fbe81e5e524c115bc248e942" alt></p><p>ASL成功 = $(1+2 * 2+4 * 3+4 * 4)/11$</p><p>ASL不成功 = $(4 * 3 +8 * 4)/12$</p><p>将二叉判定书的第$\lfloor log_2 n \rfloor+1$层上的结点补齐就称为一颗满二叉树，深度不变，$h=\lfloor log_2(n+1) \rfloor$</p><p>由满二叉树性质知，第$i$层上的结点数为$2i-1(i&lt;=h)$，设表中每个记录的查找概率相等，即$P_1 = \frac{1}{n}$，查找成功时的平均查找长度ASL：</p><p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{j=1}^h j* 2^{j-1}=\frac{n+1}{n}log_2(n+1)-1$$</p><p>当$n$很大$(n&gt;50)$，$ASL\approx log_2(n+1)-1$</p><h1 id="5-B树及其基本操作、B-树的基本概念"><a href="#5-B树及其基本操作、B-树的基本概念" class="headerlink" title="5 B树及其基本操作、B+树的基本概念"></a>5 B树及其基本操作、B+树的基本概念</h1><p>一颗度m的B树称为m阶的B树，是一颗平衡（平衡因子为0）的查找树（排序树）</p><h2 id="5-1-B树"><a href="#5-1-B树" class="headerlink" title="5.1 B树"></a>5.1 B树</h2><p>（1）B树的定义</p><p>一棵m阶的B树，或者为空树，或为满足下列特性的m叉树：</p><ol><li>分枝的数量$\lceil m/2 \rceil&lt;=n&lt;=m$</li><li>关键码的数量$\lceil m/2 \rceil-1&lt;=n&lt;=m-1$</li></ol><p>（2）B树的查找</p><p>类似二叉排序树的查找，所不同的是B树每个节点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，按照对应的指针信息指向的子树中查找，当到达叶子节点时，则说明树中没有对应的关键码，查找失败</p><p>（3）B树的插入</p><ol><li>在B树中查找关键字$K$，若找到，表明关键字已存在，返回，否则$K$的查找操作失败于某个叶子结点，转2</li><li>将$K$插入到该叶子结点中，插入时，若：<ul><li>叶子节点的关键字数$&lt;m-1$:直接插入；</li><li>叶子节点的关键字数$=m-1$：将结点“分裂”</li></ul></li></ol><p>分裂的方法：</p><p>设待“分裂”结点包含信息为：<br>$(m,A_0,K_1,A_1,K_2,A_2,\dots,K_m,A_m)$，从其中间位置分为两个结点：</p><p>$$(\lceil m/2 \rceil -1,A_0,K_1,A_1,\dots,K_{\lceil m/2 \rceil-1},A_{\lceil m/2 \rceil-1})$$<br>$$(m-\lceil m/2 \rceil,A_{\lceil m/2 \rceil},K_{\lceil m/2 \rceil+1},A_{\lceil m/2 \rceil+1},\dots,K_{m},A_{m})$$</p><p>并将中间关键字$K_{\lceil m/2 \rceil}$插入到父节点中，以分裂后的两个结点作为其子结点</p><p><img src="https://note.youdao.com/yws/api/personal/file/E743781A41C048FBACF19AEA3B46CDE3?method=download&shareKey=fff65bef129a9f6c2e47f8fb66bd770a" alt></p><p>（4）B树的删除</p><p>在$B$树上删除一个关键字$K$，首先找到关键字所在的结点$N$，然后再$N$中进行关键字$K$的删除操作。</p><p>若$N$b不是叶子结点，设$K$是$N$的第$i$个关键字，将指针$A_{i-1}$所指子树中的最大关键字（或最小关键字）$K^{‘}$放在$(k)$的位置，然后删除$K^{‘}$，而$K^{‘}$一定在叶子结点上</p><p>从叶子结点中删除一个关键字的情况是：<br>（兄弟可借）</p><ol><li>若结点$N$中的关键字个数$&gt;\lceil m/2 \rceil-1$，在结点直接删除关键字K</li><li>若结点$N$中的关键字个数$=\lceil m/2 \rceil-1$，若结点$N$的左（右）兄弟结点中的关键字个数$&gt;\lceil m/2 \rceil-1$，则将节点$N$的左（或右）兄弟结点中的最大（或最小）关键字移到其父结点中，而父结点中大于（或小于）且紧靠上移关键字的关键字下移到结点$N$</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/2C8523525D4F45C494DF2BDD9E038DD6?method=download&shareKey=bb0f372b7208953b8ef2e463e228d3ac" alt></p><p>（兄弟不可借——合并结点）<br>3. 若结点$N$和其兄弟结点中的关键字$=\lceil m/2 \rceil-1$：删除结点$N$中的关键字，再将结点$N$中的关键字、指针域其兄弟结点以及分割二者的父结点的某个关键字$K_i$，合并为一个结点，若因此使父结点中的关键个数$&lt;=\lceil m/2 \rceil-1$，则以此类推<br>4. 若所删关键字为非终端结点中的$k_i$，则可以指针$A_i$所指子树中最小关键字$Y$替代$K_i$，然后再相应的结点中删去$Y$</p><p><img src="https://note.youdao.com/yws/api/personal/file/97818282DD604A05B09196BEAD6539F0?method=download&shareKey=c6f362679dd80a67908a2d6ca93ef7a4" alt></p><h2 id="5-2-B-树"><a href="#5-2-B-树" class="headerlink" title="5.2 $B+$树"></a>5.2 $B+$树</h2><p>$B+$树是文件系统所需要的一种$B$树的变形树，一棵$m$阶的$B+,B$树主要差异在于：</p><ol><li>有$n$棵子树的结点中含有$n$个关键码；</li><li>所有叶子结点中包含了全部关键码的信息，以及指向含有这些关键码记录的指针，且叶子结点本身依赖关键码的大小自小而大的顺序链接</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/1814D7A4B1B64A8F8C2DE97653835F25?method=download&shareKey=5296f5cd12ff30a14d50fb00a0eaa204" alt></p><h1 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6 哈希表"></a>6 哈希表</h1><h2 id="6-1-常用的哈希函数"><a href="#6-1-常用的哈希函数" class="headerlink" title="6.1 常用的哈希函数"></a>6.1 常用的哈希函数</h2><p>哈希函数“好坏”的主要评价因素有：散列函数的构造简单；能“均匀”地将散列表中的关键字映射到地址空间（发生冲突的可能性最少）</p><p>（1）直接定址法</p><p>$$H(key)=key, \ H(key)=a*key+b$$</p><p>此方法仅适用于：地址集合的大小等于关键字集合的大小</p><p>（2）数字分析法<br>假设关键字集合的每个关键字都是由$s$位数字组成$(k_1,k_2,\dots,k_n)$，分析关键字集中的全体，并从中提取分布均匀的若干位或他们的组合作为地址</p><p>（3）平方取中法</p><p>若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以扩大差别</p><p>（4）折叠法</p><p>若关键字的位数特别多，则可将其分割成几部分，然后取他们的叠加和为散列地址</p><ol><li>位移法：将各部分的最后一位对齐相加</li><li>间界叠加法：从一端向另一端沿各个部分分界来回折叠后，最后一位对齐相加</li></ol><p>适用于关键字的数字位数特别多</p><p>（5）除留余数法（重点）</p><p>$$H(key)=key\  MOD\  p\ (p&lt;=m)$$</p><p>选取适合的$p$很重要，一般选取质数</p><p>（6）随机数法</p><p>$$H(key)= Random(key)$$</p><h2 id="6-2-处理冲突的方法"><a href="#6-2-处理冲突的方法" class="headerlink" title="6.2 处理冲突的方法"></a>6.2 处理冲突的方法</h2><p>（1）开放定址法</p><p>一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p><ol><li>线性探测法</li></ol><p>$$H_i = (Hash(key)+d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p><p>这种方法的特点是：发生冲突，顺序表看表中下一单元，直接找出一个空单元或查遍全表。因此，可能出现很多元素在相邻的散列地址上“堆积”起来，大大降低了查找效率。为此，可采用二次探测法改善</p><ol start="2"><li>二次探测法</li></ol><p>$$H_i = (Hash(key)\pm d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p><p>其中：$Hash(key)$为散列函数，$m$为散列表长度，$m$要求是某个$4k+3$的质数，$d_i$为增量序列$1^2,-1^2,2^2,-2^2,\dots,q^2,-q^2,\ q&lt;=m/2$</p><ol start="3"><li>拉链法</li></ol><p>将所有散列表地址为$i$的元素构成一个同义词链的单链表，并将单链表的头指针存在散列表的第$i$个单元中</p><ol start="4"><li>建立公共溢出区</li></ol><p>建立一个溢出表保存与基本表中记录冲突的所有记录</p><h2 id="6-3-散列表的查找"><a href="#6-3-散列表的查找" class="headerlink" title="6.3 散列表的查找"></a>6.3 散列表的查找</h2><p>查找过程与造表一致，假设采用开放定址处理冲突，则查找过程：</p><ol><li>对给定值$K$，计算散列地址$i=H(K)$</li><li>若$r[i]=NULL$，则查找不成功</li><li>若$r[i].key=k$，则查找成功</li><li>否则求下一地址$H_i$，直至$r[H_i]=NULL$（查找不成功），或$r[H_i].key=k$（查找成功）</li></ol><p>哈希表的填满因子<br>$$\alpha=\frac{表中填入的记录数}{哈希表长度}$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-查找的基本概念&quot;&gt;&lt;a href=&quot;#1-查找的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1 查找的基本概念&quot;&gt;&lt;/a&gt;1 查找的基本概念&lt;/h1&gt;&lt;p&gt;查找有两种基本形态：静态查找和动态查找&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态查找：在查找时只对数据元素进行查询或检索，查找表称为静态查找表&lt;/li&gt;
&lt;li&gt;动态查找：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据存储结构的不同，查找方法分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较，找到要查找的记录&lt;/li&gt;
&lt;li&gt;散列表的查找：根据给定的K值直接访问查找表，从而找到要查找的记录&lt;/li&gt;
&lt;li&gt;索引查找表的查找：首先根据索引确定待查找记录所在的块，然后再从块中找到要查找的记录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（五）：传输层</title>
    <link href="https://liangggggg.github.io/2020/08/16/network5/"/>
    <id>https://liangggggg.github.io/2020/08/16/network5/</id>
    <published>2020-08-16T01:47:42.000Z</published>
    <updated>2020-08-30T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-传输层提供的服务"><a href="#1-传输层提供的服务" class="headerlink" title="1 传输层提供的服务"></a>1 传输层提供的服务</h1><h2 id="1-1-传输层的功能"><a href="#1-1-传输层的功能" class="headerlink" title="1.1 传输层的功能"></a>1.1 传输层的功能</h2><ul><li>传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务</li><li>传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网在技术、设计上的差异和服务质量的不足，想高层提供一个标准的完善的通信服务</li><li>从通信和信息处理的角度看，应用层是面向信息处理的，而传输层是为应用层提供通信服务的</li><li>对收到的报文进行差错校验</li><li>面向连接的TCP和无连接的UDP</li></ul><a id="more"></a><h2 id="1-2-传输层寻址与端口"><a href="#1-2-传输层寻址与端口" class="headerlink" title="1.2 传输层寻址与端口"></a>1.2 传输层寻址与端口</h2><p>TCP/IP传输层端口</p><ul><li>用16位端口</li><li>只具有本地含义</li><li>不同计算机的相同端口号没有联系</li></ul><p>两个计算机中的进程要相互通信，不仅要知道对方的IP地址，还要知道对方的端口号</p><p>两大类端口</p><p>（1）服务器</p><ul><li>熟知端口，一般0-1023</li><li>登记端口号，一般为1024-49151</li></ul><p>（2）客户端</p><ul><li>短暂端口号，留给客户进程使用，一般为49152-65535</li><li>端口为动态的</li></ul><h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2 UDP协议"></a>2 UDP协议</h1><p>（1）UPD无连接的</p><p>（2）使用尽最大努力交付，不保证可靠交付</p><p>（3）UPD是面向报文的</p><p>（4）UPD没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低</p><p>（5）UPD支持一对一、一对多、多对一和多对多的交互通信</p><p>（6）UPD的首部开销小，只有8个字节，比TCP的20字节小</p><h2 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h2><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8字节，由四个字段组成，每个字段长度都是两个字节</p><p>（1）源端口</p><p>（2）目的端口</p><p>（3）长度UPD用户数据报的长度</p><p>（4）检验和检测UDP用户数据报在传输中是否有错</p><p>UDP校验是伪首部和尾部一起校验</p><h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3 TCP协议"></a>3 TCP协议</h1><h2 id="3-1-TCP段"><a href="#3-1-TCP段" class="headerlink" title="3.1 TCP段"></a>3.1 TCP段</h2><ul><li>面向连接</li><li>只能有两个端点，只能是点对点</li><li>可靠交付</li><li>提供全双工</li><li>面向字节流</li><li>TCP连接是一条虚连接</li><li>根据对方给出的窗口值和当前网络拥塞程度来决定一个报文段应包含多少个字节</li><li>TCP可把太长的数据块划分短一些再传送</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/3CCDFBC7B5024E868952FBEC3B448C20?method=download&shareKey=4bfc577c3122e1322f3393d6719657e4" alt></p><h2 id="3-2-TCP的连接管理"><a href="#3-2-TCP的连接管理" class="headerlink" title="3.2 TCP的连接管理"></a>3.2 TCP的连接管理</h2><ul><li>TCP把连接作为最基本的抽象</li><li>每一条TCP连接有两个端点</li><li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口，TCP连接的端点叫做套接字或插口</li><li>端口号拼接到IP地址即构成了套接字</li><li>传输连接有三个阶段，即：建立连接，数据传送和连接释放</li><li>建立连接过程要解决一下三个问题<ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够传输实体资源</li></ul></li></ul><p>（1）建立连接（三次握手）</p><p>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段，称为三报文握手，主要是为了防止已失效的连接请求报文突然又传送到了，因而产生错误</p><p><img src="https://note.youdao.com/yws/api/personal/file/5CEAF751EA4C4C7C9704310F6F7FCBA0?method=download&shareKey=ad2bd6d9c823843d2879523899a3111a" alt></p><p>一开始TCP服务器创建传输控制块，准备接受客户进程的连接请求，然后服务器进程处理LISTEN收听状态，等待客户的连接请求，如有即作出响应</p><ol><li><p>TCP客户也创建传输控制模块，在打算建立TCP连接时，向服务端发出连接请求报文，TCP客户端进程进入SYN-SENT同步已发送状态</p></li><li><p>服务端到请求报文后，如同意建立连接，则发送确认，进入同步收到状态</p></li><li><p>TCP客户进程收到服务端的确认后，再给服务端给出确认，这时TCP连接已经建立，客户端进入已建立连接状态</p></li></ol><p>当服务端收到客户端的确认后，也进入已建立连接状态</p><p>（2）连接释放（四次握手）</p><p><img src="https://note.youdao.com/yws/api/personal/file/1F81C26CCC94472593D302BE252F06E1?method=download&shareKey=90481f9f275da417bc784de3e700f2b1" alt></p><ol><li>客户端先想服务端发出连接释放报文，并停止再发送数据，主动关闭TCP连接，等待服务端的确认</li><li>服务端收到连接释放报文后即发出确认，这时TCP连接处于半关闭状态，即服务端到客户端连接并未关闭</li><li>客户端收到服务端的确认后，等待服务端发送的连接释放报文，若服务端也没有要发送的数据，则发出连接释放报文，等待客户端的确认</li><li>客户端收到服务端的连接释放报文后，对此发出确认，经过时间等待计时器设置的时间后，进入关闭状态</li></ol><h2 id="3-3-TCP可靠传输"><a href="#3-3-TCP可靠传输" class="headerlink" title="3.3 TCP可靠传输"></a>3.3 TCP可靠传输</h2><ul><li>TCP连接的每一端都必须设有两个窗口，一个发送窗口和一个接受窗口</li><li>TCP的可靠传输机制用字节的序号进行控制，所有的确认都是基于序号而不是基于报文段</li><li>TCP两端的四个窗口处于动态变化之中</li><li>TCP连接的往返时间RTT也不是固定不变的，需要使用特点的算法估算较为合理的重传时间</li></ul><p>（1）TCP的滑动窗口</p><p>发送窗口的范围与接收方给发送方设置的“窗口”值有关，也与发送方已发送但未被确认的TCP报文段的数量有关，每当接收方正确收到一个TCP报文段并交给上层，便发回相应的确认报文，发送方收到相应的确认，便将对应已发并确认的发送缓冲释放，发送窗口同时向前滑动</p><h2 id="3-4-TCP流量控制与拥塞控制"><a href="#3-4-TCP流量控制与拥塞控制" class="headerlink" title="3.4 TCP流量控制与拥塞控制"></a>3.4 TCP流量控制与拥塞控制</h2><p>（1）流量控制</p><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受</p><p>（2）拥塞控制</p><p>TCP基于窗口进行拥塞控制，属于闭环控制方法</p><p>TCP发送方维持一个拥塞窗口CWND</p><ul><li>大小取决于网络的拥塞程度，并且动态地在变化</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量</li><li>发送窗口大小不仅取决于接收方公告的接受窗口，还取决于网络的拥塞情况，所以真正的发送窗口值为：</li></ul><p>真正的发送窗口值=MIN（公告接受窗口值，拥塞窗口值）</p><p>只要网络没有出现拥塞，拥塞窗口可以大一些，只要出现拥塞，就必须把拥塞窗口减小一点</p><p>拥塞的判断</p><ul><li>重传定时器超时</li><li>收到三个相同重复的ACK，预示可能会出现拥塞</li></ul><p>TCP拥塞控制算法</p><p>（1）慢开始</p><p>由小到大逐渐增大拥塞窗口数值</p><p>初始拥塞窗口cwnd设置：</p><ul><li>旧的规定：设置为1-2个发送方的最大报文段SMSS的数值</li><li>新的固定：设置2-4个SMSS</li></ul><p>没有特殊说明就是1个SMSS</p><p>慢开始门限：防止拥塞窗口增长过大</p><p>每收到一个新的报文段确认，可以把拥塞窗口增加多一个</p><p>每经过一个传输轮次，拥塞窗口加倍。窗口按指数增加</p><p><img src="http://note.youdao.com/noteshare?id=82b0ebf222a392a52865e1c74a15e32f&sub=9845A0F352624ADC8CBD58346DC17652" alt></p><p>（2）拥塞避免算法</p><p>没经过一个往返时间RTT就把拥塞窗口加1，使拥塞窗口按线性规律缓慢增大</p><p>当网络出现拥塞时</p><p>门限阈值设为窗口/2</p><p>窗口设置为1</p><p>执行慢开始算法</p><p><img src="https://note.youdao.com/yws/api/personal/file/E4D159D17BC24A0BBAC287D02DFFE98B?method=download&shareKey=a7eaab7740e883c4240ec1404c584dd8" alt></p><p>（3）快重传算法</p><p>只要收到三个重复确认，立即进行重传</p><p>（4）快恢复</p><p>当连续收到三个重复确认</p><ol><li>慢开始门限=当前拥塞窗口/2</li><li>新拥塞窗口=慢开始门限</li><li>执行拥塞避免算法</li></ol><hr><h1 id="4-面试常见问题总结"><a href="#4-面试常见问题总结" class="headerlink" title="4 面试常见问题总结"></a>4 面试常见问题总结</h1><h2 id="4-1-三次握手和四次握手"><a href="#4-1-三次握手和四次握手" class="headerlink" title="4.1 三次握手和四次握手"></a>4.1 三次握手和四次握手</h2><p>（1）三次握手</p><ul><li>客户端发送带有SYN标志的数据报给服务端</li><li>服务端发送带有SYN/ACK标志的数据报给客户端</li><li>客户端发送带有ACK标志的数据报给服务端</li></ul><blockquote><p>SYN同步序列编号，是TCP/IP建立连接时使用的握手信号，在客户机和服务器之间建立正常的TCP网络连接时，客户端首先发出一个SYN消息，服务器使用SYN-ACK应答表示接受到了这个消息，最后客户端再以ACK消息响应，这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户端和服务器之间传递</p></blockquote><p>三次握手的目的是建立可靠通信，能够使双方确认自己与对方的发送与接收都是正常的</p><p>（2）四次握手</p><ul><li>客户端发送一个FIN用来关闭客户端到服务器的数据发送</li><li>服务器收到FIN，发回一个ACK，确认序号为收到的序号加1</li><li>服务器关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态，当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接</p><h2 id="4-2-TCP和UDP协议的区别"><a href="#4-2-TCP和UDP协议的区别" class="headerlink" title="4.2 TCP和UDP协议的区别"></a>4.2 TCP和UDP协议的区别</h2><ul><li>UPD在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给任何确认，虽然UDP不提供可靠交付，但在某些情况下UDP却是一种罪有效的工作方式（一般永固即时通信），比如语音、视频、直播等</li><li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束要释放连接，TCP不提供广播或多播服务，由于TCP要提供可靠的，面向连接的传输服务，会增加许多开销，一般用于文件传送，接受邮件、远程登录等</li></ul><h2 id="4-3-TCP协议如何保证可靠传输"><a href="#4-3-TCP协议如何保证可靠传输" class="headerlink" title="4.3 TCP协议如何保证可靠传输"></a>4.3 TCP协议如何保证可靠传输</h2><ol><li>应用数据被分割成TCP认为最适合发送的数据块</li><li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层</li><li>校验和：TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测书剑在传送过程中的任何变化，如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li><li>TCP的接受端会丢弃重复的数据</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只会允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送速率，防止包丢失，TCP使用的流量控制协议是可变大小的滑动窗口协议</li><li>拥塞控制：当网络拥塞时，减少数据的发送</li><li>ARQ协议：每发完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li><li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</li></ol><p>（1）ARQ协议</p><p>自动重传请求是OSI模型中数据链路层和传输层错误纠正协议之一，通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输，如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送，ARQ包括停止等待协议ARQ和连续ARQ</p><p><strong>停止等待ARQ协议</strong></p><ul><li>停止等待协议是为了实现可靠传输的，基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK），如果过了一段时间后，还没有收到ACK确认，就说明没有发送成功，需要重新发送，知道收到确认后再发送下一个分组</li><li>若收到重复分组，就丢弃该分组，但同时还要发送确认</li></ul><p>简单，但是信道利用率低</p><p><strong>无差错情况</strong></p><p>在规定时间能收到，并回复确认，发送方再次传送下一个数据</p><p><strong>出现差错情况（超时重传）</strong></p><p>每发送完一个分组需要设置一个超时计时器，重传时间比数据在分组传输的平均往返时间更长一些，称为自动重传请求ARQ。</p><p>而连续ARQ可提高信道利用率，发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p><p><strong>确认丢失和确认迟到</strong></p><ul><li>确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失，而A不知道，在超时计时后，A重传M1下次，B再次收到该消息后采取以下两点措施：1.丢弃这个重复的M1消息，不向上层交付。2.向A发送确认消息</li><li>确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认，在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息，此时A收到了B第二次发送的确认消息，接着发送其他数据，过了一会儿，A又收到了B第一次发送的迟到确认消息，处理如下：1.A收到重复的确认后，直接丢弃2.B收到重复的M1也直接丢弃重复的M1</li></ul><p><strong>连续ARQ协议</strong></p><p>连续ARQ协议可提高信道利用率，发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p><p>优点是信道利用率高，容易实现，即使确认丢失，也不必重传</p><p>缺点是不能像发送方反映出接受方已经正确收到的所有分组信息。当出现丢失时，需要退回重传已经发送过的N个消息</p><p>（2）滑动窗口和流量控制</p><p>TCP利用滑动窗口实现流量控制，为了控制发送方发送的速率，保证接收方来得及接收</p><p>（3）拥塞控制</p><p>拥塞控制是一个全局性的过程，设计到所有的主机，所有的路由器，以及降低网络传输性能有关的所有因素</p><p>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</p><p>TCP的拥塞控制采用了四种算法：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使用路由器采用适当的分组丢弃策略（主动队列管理AQM），以减少网络拥塞的发生</p><ul><li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入网络，那么可能会引起网络阻塞，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，cwnd初始值为1，每经过一个传播轮次，cwnd加倍</li><li>拥塞避免：拥塞避免算法的思路是rag拥塞窗口cwnd缓慢增大，没经过一个往返时间RTT就把发送的cwnd加1</li><li>快重传和快恢复：在TCP/IP中，快重传和恢复是一种拥塞控制算法，它能快速恢复丢失的数据报。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。有了FRR，如果接收机收到了一个不按顺序的数据段，它会立即给发送机发送一个重复确认，如果接受到三个重复确认，它会假定确认件直除的数据段丢失了，并立即重传这些丢失的数据段</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-传输层提供的服务&quot;&gt;&lt;a href=&quot;#1-传输层提供的服务&quot; class=&quot;headerlink&quot; title=&quot;1 传输层提供的服务&quot;&gt;&lt;/a&gt;1 传输层提供的服务&lt;/h1&gt;&lt;h2 id=&quot;1-1-传输层的功能&quot;&gt;&lt;a href=&quot;#1-1-传输层的功能&quot; class=&quot;headerlink&quot; title=&quot;1.1 传输层的功能&quot;&gt;&lt;/a&gt;1.1 传输层的功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务&lt;/li&gt;
&lt;li&gt;传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网在技术、设计上的差异和服务质量的不足，想高层提供一个标准的完善的通信服务&lt;/li&gt;
&lt;li&gt;从通信和信息处理的角度看，应用层是面向信息处理的，而传输层是为应用层提供通信服务的&lt;/li&gt;
&lt;li&gt;对收到的报文进行差错校验&lt;/li&gt;
&lt;li&gt;面向连接的TCP和无连接的UDP&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（四）：网络层</title>
    <link href="https://liangggggg.github.io/2020/08/15/network4/"/>
    <id>https://liangggggg.github.io/2020/08/15/network4/</id>
    <published>2020-08-15T01:47:42.000Z</published>
    <updated>2020-08-27T12:24:53.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络层的功能"><a href="#1-网络层的功能" class="headerlink" title="1 网络层的功能"></a>1 网络层的功能</h1><h2 id="1-1-异构网络互联"><a href="#1-1-异构网络互联" class="headerlink" title="1.1 异构网络互联"></a>1.1 异构网络互联</h2><p>由于参加互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看作一个虚拟互联网络，所谓虚拟互联网络也就是逻辑互联网络，互联起来的各个捂脸网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。</p><a id="more"></a><h2 id="1-2-路由与转发"><a href="#1-2-路由与转发" class="headerlink" title="1.2 路由与转发"></a>1.2 路由与转发</h2><p>在路由表中，对每一条路由最主要的是以下两个信息：目的网络地址、下一跳地址</p><p>我们根据目的网络地址来确定下一跳路由器，这样可得出以下结果</p><p>（1）IP数据报最终一定可以找到目的主机所在目的网络上的路由器</p><p>（2）只有到达最后一个路由器时，才视图向目的主机进行直接交付</p><p>分组转发算法：</p><p>（1）从数据报的首部提取目的主机IP地址D，得出目的网络地址为N</p><p>（2）若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址D转换为具体的硬件地址）；否则就是间接交付，执行（3）</p><p>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</p><p>（4）路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器：否则，执行（5）</p><p>（5）若路由表中有一个默认路由，则把数据表传送给路由表中所指明的默认路由器；否则执行（6）</p><p>（6）报告转发分组出错</p><p>路由表想主要字段：目的网络、子网掩码、下一跳路由器、经由接口</p><p>默认路由：若匹配路由表中其它项都不匹配，则走默认路由指明的路由</p><p>若路由表项都不匹配且无默认路由，则向源主机发送错的ICMP包</p><p>主机路由：IP地址，255.255.255.255 下一跳 接口</p><h2 id="1-3-拥塞控制"><a href="#1-3-拥塞控制" class="headerlink" title="1.3 拥塞控制"></a>1.3 拥塞控制</h2><p>1、拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该网络来不及处理以致引起这部分乃至整个网络性能下降的现象，严重时会出现死锁。拥塞现象产生的原因主要有三个方面：路由器缓冲区不够；通信线路的带宽不够；处理器速度慢</p><p>2、拥塞控制：目的是确保子网能够承载所有到达流量，是全局问题，涉及节点包括：主机、路由器</p><p>3、流量控制：目的是确保发送端的发送速度小于接受端的接收速度，使接收端来得及正确接收。流量控制只与发送和接收端有关系，是局部问题</p><h1 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2 路由算法"></a>2 路由算法</h1><h2 id="2-1-静态路由与动态路由"><a href="#2-1-静态路由与动态路由" class="headerlink" title="2.1 静态路由与动态路由"></a>2.1 静态路由与动态路由</h2><p>静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由</p><p>动态路由选择也叫自适应路由选择，其特点是能较好地自适应网络状态的变化，但实现起来较为复杂，开销也较大，因此，适用于较复杂的大网络。</p><h2 id="2-2-距离-向量路由算法"><a href="#2-2-距离-向量路由算法" class="headerlink" title="2.2 距离-向量路由算法"></a>2.2 距离-向量路由算法</h2><h2 id="2-3-链路状态路由算法"><a href="#2-3-链路状态路由算法" class="headerlink" title="2.3 链路状态路由算法"></a>2.3 链路状态路由算法</h2><h2 id="2-4-层次路由"><a href="#2-4-层次路由" class="headerlink" title="2.4 层次路由"></a>2.4 层次路由</h2><p>（1）互联网的规模非常大，如果让所有路由器知道所有网络应该怎样到达，则这种路由表将非常大</p><p>（2）许多单位不愿意外界了解自己单位网络的布局细节和本部分所采用的路由选择协议</p><p>为此，将整个互联网划分成许多较小的自治系统</p><h1 id="3-IPv4"><a href="#3-IPv4" class="headerlink" title="3 IPv4"></a>3 IPv4</h1><h2 id="3-1-IPv4分组"><a href="#3-1-IPv4分组" class="headerlink" title="3.1 IPv4分组"></a>3.1 IPv4分组</h2><p>IP数据报的格式能够说明IP协议都具有什么功能，在TCP/IP的标准中，各种数据格式常常以32位（4字节）为单位来表述</p><p><img src="https://note.youdao.com/yws/api/personal/file/587F26252FD94B0A8E49E55E40988A0F?method=download&shareKey=d8379ce9bacd34421d0217526f1108b3" alt></p><p>（1）IP数据报首部的固定部分中的各字段</p><ol><li>版本占4位，指IP协议的版本，通信双方使用的IP协议版本必须一致，目前广泛使用的为4（即IPv4）</li><li>首部长度占4位</li><li>区分服务占8位，用来获得更好的服务</li><li>总长度指首部和数据之和的长度</li><li>标识占16位</li><li>标志占3位</li><li>片偏移占13位。较长的分组在分片后，某片在原分组中的相对位置</li><li>生存时间占8位</li><li>协议占8位，指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理</li><li>首部检验和占16位</li></ol><h2 id="3-2-IPv4地址与NAT"><a href="#3-2-IPv4地址与NAT" class="headerlink" title="3.2 IPv4地址与NAT"></a>3.2 IPv4地址与NAT</h2><p>（1）IP地址及其表示方法</p><p>IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配以个在全世界范围内是唯一的32位标识符，具有以下重要特点</p><ol><li>每一个IP地址都由网络号和主机号两部分组成</li><li>实际上IP地址标志一台主机（或路由器）和一条链路的接口。路由器至少应当有两个不同的IP地址</li><li>一个网络是指具有相同网络号net-id的主机的集合，因此用转发器或网桥连接起来的若干个局域网仍为一个网络</li><li>在IP地址中，所有分配到网络号的网络都是平等的</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/27C68544341842C9A1439F6AF31EC516?method=download&shareKey=dff0f29f2e04b88dca9d17e7bf85a20c" alt></p><p>主机号全0，或全1不使用</p><p>A类地址：网络号：0-127，主机地址24位：$2^24-2$个</p><p>B类地址：网络号：128.0-191.255,主机地址16位：$2^16-2$个</p><p>C类地址：网络号：192.0.0-223.255.255，主机地址8位：$2^8-2$</p><p>D类地址：网络号：224~239之间，一般用于多路广播用户</p><p>E类地址：网络号：240~250之间，保留地址</p><p>（2）NAT技术</p><p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件，装有NAT软件的路由器叫作NAT路由器，至少有一个有效的外部全球IP地址，这样，所有使用本地地址的主机和外界通信时，都要在NAT路由器上讲本地地址转换成全球IP地址，才能和互联网连接。</p><h2 id="3-3-子网划分、路由聚集、子网掩码、CIDR"><a href="#3-3-子网划分、路由聚集、子网掩码、CIDR" class="headerlink" title="3.3 子网划分、路由聚集、子网掩码、CIDR"></a>3.3 子网划分、路由聚集、子网掩码、CIDR</h2><p>（1）从两级IP地址到三级IP地址</p><p>划分子网的基本思路如下：</p><ol><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号，当然主机号也就相应减少了同样的位数，IP地址在单位内部变为三级IP地址：网络号、子网号、主机号</li><li>范式从其他网络发送给本单位某台主机的IP数据报，仍是根据IP数据报的目的网络号找到链接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，吧IP数据报交付目的主机</li></ol><p>（2）子网掩码</p><p>使用子网掩码的好处就是，不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的与运算，就立即得出网络地址来。</p><p><img src="https://note.youdao.com/yws/api/personal/file/15B0A407CC8747CAAB1084D4E6EA4484?method=download&shareKey=c11b3faa3b315d7e7c0b52a797c0fdb9" alt></p><p>（3）使用子网分组的转发</p><p>在划分子网的情况下，分组转发的算法必须做相应的改动，使用子网划分后，路由表必须包括以下三项内容：目的网络地址、子网掩码和下一跳地址，下划分子网情况下，路由转发分组的算法如下：</p><ol><li>从收到的数据报的首部提取目的IP地址D</li><li>先判断是否为直接交付，用各网络的子网掩码和D逐位相与，看结果是否和相应的网络地址匹配，若匹配进行直接交付，否则间接交付，执行（3）</li><li>若路由表中有目的地址为D的特点主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</li><li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相与，其结果为N，若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器，否则执行5</li><li>路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由器，否则执行6</li><li>报告转发分组出错</li></ol><h2 id="3-4-无分类编址CIDR（构造超网）"><a href="#3-4-无分类编址CIDR（构造超网）" class="headerlink" title="3.4 无分类编址CIDR（构造超网）"></a>3.4 无分类编址CIDR（构造超网）</h2><p>CIDR最主要的特点有两个：</p><p>（1）CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，把32位的IP地址划分为前后两个部分，前面部分是“网络前缀”，用来指明网络，后面部分则用来指明主机。因此CIDR使IP地址从三级编址回到了两级编址：IP地址=网络前缀、主机号，在IP地址后面加上斜线，然后写上网络前缀所占的位数</p><p>（2）CIDR把网络前缀都相同的连续的IP地址组成一个CIDR地址块。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数</p><p>路由聚合</p><p>这个ISP共拥有64个C类网络，如果不采用CIDR技术，则与该ISP的路由器交换路由信息的每一个路由器的路由表中，就需要有64个项目，但采用地址聚合后，就只需用路由聚合后的一个项目206.0.64.0/18就能找到该ISP</p><p><img src="https://note.youdao.com/yws/api/personal/file/C6F0B28F52FA4CBB8912A657C5DA19A7?method=download&shareKey=e71d81b3e28fa6b144aaac0811d2ff5a" alt></p><p>最长前缀匹配</p><p>每个项目由网络前缀和下一跳地址组成，但是在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由</p><h2 id="3-5-ARP协议、DHCP协议与ICMP协议"><a href="#3-5-ARP协议、DHCP协议与ICMP协议" class="headerlink" title="3.5 ARP协议、DHCP协议与ICMP协议"></a>3.5 ARP协议、DHCP协议与ICMP协议</h2><h3 id="3-5-1-地址解析协议ARP"><a href="#3-5-1-地址解析协议ARP" class="headerlink" title="3.5.1 地址解析协议ARP"></a>3.5.1 地址解析协议ARP</h3><p>从网络层使用的IP地址，解析出在数据链路层使用的硬件地址</p><ul><li>ARP请求分组：包含发送方硬件地址和IP地址，目标方硬件地址（未知填0），目标方IP地址</li><li>本地广播ARP请求（路由器不转发ARP请求）</li><li>ARP相应分组：发送方硬件地址、发送方IP地址、目标方硬件地址、目标方IP地址</li><li>ARP分组封装在物理网络的帧中传输</li></ul><h3 id="3-5-2-网络控制报文协议ICMP"><a href="#3-5-2-网络控制报文协议ICMP" class="headerlink" title="3.5.2 网络控制报文协议ICMP"></a>3.5.2 网络控制报文协议ICMP</h3><ul><li>为了提高IP数据交付成功的机会</li><li>允许主机或路由器报告差错情况和提供有关异常情况的报告</li><li>不是高层协议而是IP层的协议</li><li>作为IP层数据报的数据</li><li>有差错报告和询问报文</li><li>前4个字节是统一的格式，共有三个字段：即类型、代码和校验和，接着的4个字节的内容与ICMP的类型有关</li></ul><h3 id="3-5-3-动态主机设置协议DHCP"><a href="#3-5-3-动态主机设置协议DHCP" class="headerlink" title="3.5.3 动态主机设置协议DHCP"></a>3.5.3 动态主机设置协议DHCP</h3><ul><li>动态主机配置协议DHCP提供了即插即用连网的机制</li><li>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参加</li><li>需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就称为DHCP客户</li><li>本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文</li><li>DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文</li></ul><h1 id="4-IPv6"><a href="#4-IPv6" class="headerlink" title="4 IPv6"></a>4 IPv6</h1><h2 id="4-1-IPv6的主要特点"><a href="#4-1-IPv6的主要特点" class="headerlink" title="4.1 IPv6的主要特点"></a>4.1 IPv6的主要特点</h2><p>（1）地址从IPv4的32位增加到128位</p><p>（2）扩展地址层次结构</p><p>（3）灵活的首部格式</p><p>（4）改进的选项</p><p>（5）允许协议继续扩充</p><p>（6）支持资源的预分配</p><p>（7）支持即插即用</p><p>（8）首部8字节对齐</p><h2 id="4-2-IPv6的地址"><a href="#4-2-IPv6的地址" class="headerlink" title="4.2 IPv6的地址"></a>4.2 IPv6的地址</h2><p>（1）单播：传统的点到点通信</p><p>（2）组播：一点对多点通信</p><p>（3）任播：终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个</p><p>为了使地址再稍简洁，使用冒号十六进制法</p><h1 id="5-路由协议"><a href="#5-路由协议" class="headerlink" title="5 路由协议"></a>5 路由协议</h1><h2 id="5-1-自治系统"><a href="#5-1-自治系统" class="headerlink" title="5.1 自治系统"></a>5.1 自治系统</h2><ul><li>核心是路由寻址的“自治”</li><li>自治系统内部的路由器了解内部全部网路的路由信息</li><li>自治系统内部的路由器要向主干路由器报告内部路由信息</li></ul><h2 id="5-2-域内路由与域间路由"><a href="#5-2-域内路由与域间路由" class="headerlink" title="5.2 域内路由与域间路由"></a>5.2 域内路由与域间路由</h2><ul><li>内部网关协议IGP，如RIP,OSPF协议</li><li>外部网关协议EGP，如BGP-4</li></ul><h2 id="5-3-RIP路由协议"><a href="#5-3-RIP路由协议" class="headerlink" title="5.3 RIP路由协议"></a>5.3 RIP路由协议</h2><p>1、工作原理</p><ul><li>内部网关协议</li><li>分布式的基于距离向量</li><li>要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</li></ul><p>距离的定义：</p><ol><li>路由器到直接连接的网络距离定义为1</li><li>路由器到非直连的网络的距离为所经过的路由器加1</li><li>RIP协议的距离也称为跳数</li><li>距离指的是最短距离</li><li>允许一条路径最多只包含15个路由器</li><li>16个路由器则不可达，可见RIP适用于小型网络</li><li>不能再两个网络之间同时使用多条路由</li></ol><p>RIP三个要点：</p><ul><li>仅和相邻路由交换信息</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表</li><li>按固定的时间间隔交换路由信息</li></ul><p>2、距离向量算法</p><p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p><ol><li><p>对地址为X相邻路由器发来的RIP报文，先修改此报文中的所有项目：把下一跳字段中的地址都改为X，并把所有距离字段的值都加1，每一项目都有三个关键数据，即：目的网络N，距离d,下一跳路由X</p></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤:若原来的路由表中没有目的网络N，则把该项目添加到路由表中，否则（即在路由表中有目的网络N，这时就再查看下一跳路由地址）</p><ul><li>若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目，否则</li><li>若收到项目中的距离小于路由表中的距离，则进行更新，否则什么都不做</li></ul></li><li><p>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器</p></li></ol><h2 id="5-4-OSPF路由协议"><a href="#5-4-OSPF路由协议" class="headerlink" title="5.4 OSPF路由协议"></a>5.4 OSPF路由协议</h2><p>1、OSPF的三个要点</p><ul><li>向本自治系统中所有路由器发送信息</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</li><li>只有当链路状态发生变化时，路由器才想所有路由器用洪泛法发送此信息</li></ul><p>2、OSPF的五种分组类型</p><ul><li>问候分组</li><li>数据库描述</li><li>链路状态请求</li><li>链路状态更新</li><li>链路状态确认</li></ul><h2 id="5-5-BGP路由协议"><a href="#5-5-BGP路由协议" class="headerlink" title="5.5 BGP路由协议"></a>5.5 BGP路由协议</h2><ul><li>因特网的规模太大，寻找最佳路径不现实，只交换可达性的信息</li><li>自治系统之间的路由必须考虑有关策略</li><li>边界网关协议BGP只能是力求寻找一条能够到达目的地网络且比较好的路由</li></ul><h1 id="6-IP组播"><a href="#6-IP组播" class="headerlink" title="6 IP组播"></a>6 IP组播</h1><h2 id="6-1-组播的概念"><a href="#6-1-组播的概念" class="headerlink" title="6.1 组播的概念"></a>6.1 组播的概念</h2><p>在一对多的通信中，组播可大大节约网络资源，组播组的标识符就是IP地址的D类地址</p><h1 id="7-移动IP"><a href="#7-移动IP" class="headerlink" title="7 移动IP"></a>7 移动IP</h1><h2 id="7-1-移动IP的概念"><a href="#7-1-移动IP的概念" class="headerlink" title="7.1 移动IP的概念"></a>7.1 移动IP的概念</h2><p>这种技术允许计算机移动到外地时，仍然保留原来的IP地址，使用户的移动性对上层的网络应用是透明的</p><h1 id="8-网络层设备"><a href="#8-网络层设备" class="headerlink" title="8 网络层设备"></a>8 网络层设备</h1><ul><li>路由器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-网络层的功能&quot;&gt;&lt;a href=&quot;#1-网络层的功能&quot; class=&quot;headerlink&quot; title=&quot;1 网络层的功能&quot;&gt;&lt;/a&gt;1 网络层的功能&lt;/h1&gt;&lt;h2 id=&quot;1-1-异构网络互联&quot;&gt;&lt;a href=&quot;#1-1-异构网络互联&quot; class=&quot;headerlink&quot; title=&quot;1.1 异构网络互联&quot;&gt;&lt;/a&gt;1.1 异构网络互联&lt;/h2&gt;&lt;p&gt;由于参加互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看作一个虚拟互联网络，所谓虚拟互联网络也就是逻辑互联网络，互联起来的各个捂脸网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（四）：图</title>
    <link href="https://liangggggg.github.io/2020/08/15/Data4/"/>
    <id>https://liangggggg.github.io/2020/08/15/Data4/</id>
    <published>2020-08-15T01:12:59.000Z</published>
    <updated>2020-08-27T01:52:48.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图的存储及基本操作"><a href="#1-图的存储及基本操作" class="headerlink" title="1 图的存储及基本操作"></a>1 图的存储及基本操作</h1><h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><p>用一维数组存储图中顶点信息，用矩阵表示图中各顶点之间的邻接关系</p><p>假设图$G=(V,E)$有$n$个确定的顶点，即$V=\lbrace v_0,v_1,\dots,v_{n-1}\rbrace$,$A[n][n]$存储顶点之间关系的信息</p><p>以顶点在vexs数组中的下标代表顶点</p><a id="more"></a><p>（1）无向图的邻接矩阵一定是一个对称矩阵，只需存放上（或下）三角矩阵的元素即可</p><p>（2）对于无向图，邻接矩阵第i行（或第i列）非零元素（或非$\infty$元素）的个数正好是第i个顶点的度$TD(v_i)$</p><p>（3）对于有向图，邻接矩阵第i行（或第i列）非零元素（或非$\infty$元素）的个数正好是第i个顶点的出度$OD(v_i)$（或入度$ID(v_i)$）</p><p>（4）邻接矩阵要确定图中有多少条边，则必须按行、列对每个元素进行检测，时间代价大，是邻接矩阵存储图的局限性</p><h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p>邻接表示图的一种顺序存储与链式存储结合的存储方式。对图G中的每个顶点$v_i$，将所有邻接与$v_i$的顶点$v_j$链成一个单链表，这个单恋表就称为顶点$v_i$的邻接表，再将所有点的邻接表表头放到数组中，构成了图的邻接表。</p><p>（1）若无向图中有n个顶点，e条边，则它的邻接表需n个头结点和2e个表结点</p><p>（2）在无向图的邻接表中，顶点$v_i$的度恰为第i个链表中的结点数</p><p>（3）在有向图中，第i个链表中的结点个数是顶点$v_i$的入度</p><p>（4）在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个顶点$v_i,v_j$之间是否有边，则需要搜索第i个或第J个链表，不及邻接矩阵方便</p><h1 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h1><h2 id="2-1-深度优先搜索"><a href="#2-1-深度优先搜索" class="headerlink" title="2.1 深度优先搜索"></a>2.1 深度优先搜索</h2><p>DFS类似于树的先根遍历，是树的先根遍历的推广。</p><p>其耗费的时间则取决于所采用的存储结构。当用二维数组表示邻接矩阵图的存储结构时，查找每个顶点的邻接点所需时间为$O(n^2)$，其中$n$为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为$O(e)$，其中$e$为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。</p><h2 id="2-2-广度优先搜索"><a href="#2-2-广度优先搜索" class="headerlink" title="2.2 广度优先搜索"></a>2.2 广度优先搜索</h2><p>BFS类似于树的按层次遍历的过程。</p><p>如果使用邻接表表示图，总时间代价为$O(n+e)$，如果用邻接矩阵，总的时间代价为$O(n^2)$</p><h1 id="3-图的应用"><a href="#3-图的应用" class="headerlink" title="3 图的应用"></a>3 图的应用</h1><h2 id="3-1-最小生成树"><a href="#3-1-最小生成树" class="headerlink" title="3.1 最小生成树"></a>3.1 最小生成树</h2><p>（1）Prim算法</p><p>假设$G=(V,E)$为一网图，其中$V$为网图中所有顶点的集合，$E$为网图中所有带权边的集合。设置两个新的结合$U$和$T$，集合$U$用于存放$G$的最小生成树的顶点，集合$T$存放$G$的最小生成树的边。令集合$U$的初值为$u=\lbrace u_1 \rbrace$</p><ol><li>从所有$u\in U , v\in V-U$的边中，选取具有最小权值的边$(u,v)$</li><li>将顶点$v$加入集合$U$中，将边$(u,v)$加入集合$T$中，不断重复</li><li>直到$U=V$时，最小生成树构造完毕</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/B0434A610F8B457C8FE7C374B1E9C6B2?method=download&shareKey=9d6342c361f13787d7d0bdb6cc2d561f" alt></p><p>Prim算法的时间复杂度为$O(n^2)$，与网中的边数无关，适用于求边稠密的网的最小生成树</p><p>（2）Kruskal算法</p><p>按照网中的权值递增顺序构造最小生成树的方法，需对$e$条边按权值进行排序，时间复杂度为$O(eloge)$（$e$为网中边的数目），因此适用于求边稀疏的网的最小生成树</p><p><img src="https://note.youdao.com/yws/api/personal/file/90EF181691074DBCB7EF3CE9D25FD795?method=download&shareKey=e18b362fdc112a35adf5f8e7a9cc78fe" alt></p><h2 id="3-2-最短路径"><a href="#3-2-最短路径" class="headerlink" title="3.2 最短路径"></a>3.2 最短路径</h2><p>（1）单源点最短路径</p><p>前提：非负权值的图</p><p>设给定源点为$V_s$，$S$为已求得最短路径的终点集，开始时令$S=\lbrace V_s \rbrace$，当求得第一条最短路径$(V_s,V_i)$后，S为$\lbrace V_s,V_i \rbrace$</p><ol><li>令$S=\lbrace V_s \rbrace$，用带权的邻接矩阵表示有向图，对图中每个顶点$V_i$按以下原则设置初值</li></ol><p>$$<br>dist[i]=<br>\begin{cases}<br>0 &amp; i=s\\<br>W_{si} &amp;i \ne s 且&lt;V_s,V_i&gt; \in E，W_{si}为弧上的权值\\<br>\infty &amp; i\ne s且&lt;V_s,V_i&gt;不属于E<br>\end{cases}<br>$$</p><ol start="2"><li>选择一个顶点$V_j$，使得：<br>$$dist[j]=Min{dist[k]|V_k\in V-S}$$</li></ol><p>$V_j$就是求得下一条最短路径重点，将$V_j$并入到$S$中，即$S=S\cup \lbrace V_j \rbrace$</p><ol start="3"><li>对$V-S$中的每个顶点$V_k$，修改$dist[k]$，方法是：</li></ol><p>若$dist[j]+W_{jk}&lt;dist[k]$，则修改为：$dist[k]=dist[j]+W_{jk} (\forall V_k \in V-S)$</p><ol start="4"><li>重复2，3，知道S=V为止</li></ol><p>时间复杂度$O(n^2)$</p><p><img src="https://note.youdao.com/yws/api/personal/file/CA666348EB3F47E38C99A46E2797F5EE?method=download&shareKey=8be271a12c0ec4ed3d00b3aeea6907ae" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/0EC47118409644B89304F162CC011C3A?method=download&shareKey=277330d42d8968178b86457f8c17f636" alt></p><p>（3）每一对顶点之间的最短路径</p><p>设顶点集$S$（初值为空），用数组$A$的每个元素$A[i][j]$保存$V_i$值经过$S$中的顶点到达$V_j$的最短路径长度，其思想是：</p><ol><li>设初始时令$S=\lbrace  \rbrace$,$A[i][j]$的赋初值方式是：</li></ol><p>$$<br>A[i][j]=<br>\begin{cases}<br>0 &amp; i=j\\<br>W_{ii} &amp;i \ne j 且&lt;V_i,V_j&gt; \in E，W_{ij}为弧上的权值\\<br>\infty &amp; i\ne j且&lt;V_i,V_i&gt;不属于E<br>\end{cases}<br>$$</p><ol start="2"><li>将图中一个顶点$V_k$加入到$S$中，修改$A[i][j]$的值，修改方式：</li></ol><p>$$A[i][j]=Min\lbrace A[i][j],(A[i][k]+A[k][j]) \rbrace$$</p><ol start="3"><li>重复2，直到$G$的所有顶点都 加入到$S$中为止</li></ol><p>时间复杂度为$O(n^3)$</p><p><img src="http://note.youdao.com/noteshare?id=d714a4e0dcbe51a82c7c2fe3047db2db&sub=4977D64EAF3A46D3AF7730228E2A555A" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/6A15DA39F38946F4907806B14FA49471?method=download&shareKey=b17f11c2ac0784dfec9a9c9d44183577" alt></p><h2 id="3-3-拓扑排序"><a href="#3-3-拓扑排序" class="headerlink" title="3.3 拓扑排序"></a>3.3 拓扑排序</h2><p>有向无环图</p><p>主要用于研究工程项目的工序问题</p><ol><li>从AVO网中选择一个没有前驱的顶点（入度为0），并且输出它</li><li>从网中删除该顶点，并且删除从该顶点发出的全部有向边</li><li>重复上述步骤，知道剩余网中不再存在没有前驱的顶点为止</li></ol><h2 id="3-4-关键路径"><a href="#3-4-关键路径" class="headerlink" title="3.4 关键路径"></a>3.4 关键路径</h2><ol><li>利用拓扑排序求出AOE网的一个拓扑序列</li><li>从拓扑排序的序列的第一个顶点开始，按拓扑顺序依次计算每个时间的最早发生时间（选择最大的）</li><li>从拓扑排序的序列的最后一个顶点开始，按拟拓扑顺序依次计算每个时间的最晚发生时间（选择最小的）</li></ol><p>最早发生时间等于最晚发生时间的事件为关键事件</p><p><img src="https://note.youdao.com/yws/api/personal/file/DDBFB4920153461085F4183EC16B2B8C?method=download&shareKey=eaf12c4b3ff1ea75085c551154dcedc2" alt></p><p>其拓扑排序序列为$&lt;V_0,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8&gt;$</p><p>计算各事件的$ve(i),vl(i)$值</p><p><img src="https://note.youdao.com/yws/api/personal/file/AC8580E97E5E4B5E90D6F48EE738DFF4?method=download&shareKey=27d90648fa2b48f6c99e1ed8a4f4638d" alt></p><p>其次计算$e,l$</p><p>$e$为对应第一个顶点的$ve(i)$</p><p>$l$为对应第二个顶点$vl(i)-ve(i)$</p><p><img src="https://note.youdao.com/yws/api/personal/file/83E7282B9C5048C48BBF903E663EDFE2?method=download&shareKey=67ceb99e4d35e5bdf5a4670216a959c2" alt></p><p>$e,l$相等的事件为关键事件，其构成的路径为关键路径</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-图的存储及基本操作&quot;&gt;&lt;a href=&quot;#1-图的存储及基本操作&quot; class=&quot;headerlink&quot; title=&quot;1 图的存储及基本操作&quot;&gt;&lt;/a&gt;1 图的存储及基本操作&lt;/h1&gt;&lt;h2 id=&quot;1-1-邻接矩阵&quot;&gt;&lt;a href=&quot;#1-1-邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;1.1 邻接矩阵&quot;&gt;&lt;/a&gt;1.1 邻接矩阵&lt;/h2&gt;&lt;p&gt;用一维数组存储图中顶点信息，用矩阵表示图中各顶点之间的邻接关系&lt;/p&gt;
&lt;p&gt;假设图$G=(V,E)$有$n$个确定的顶点，即$V=\lbrace v_0,v_1,\dots,v_{n-1}\rbrace$,$A[n][n]$存储顶点之间关系的信息&lt;/p&gt;
&lt;p&gt;以顶点在vexs数组中的下标代表顶点&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（三）：树与二叉树</title>
    <link href="https://liangggggg.github.io/2020/08/14/Data3/"/>
    <id>https://liangggggg.github.io/2020/08/14/Data3/</id>
    <published>2020-08-14T00:12:59.000Z</published>
    <updated>2020-08-26T12:56:56.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h1><h2 id="1-1-二叉树的定义及其主要特性"><a href="#1-1-二叉树的定义及其主要特性" class="headerlink" title="1.1 二叉树的定义及其主要特性"></a>1.1 二叉树的定义及其主要特性</h2><p>二叉树是有序的，即使树中节点只有一颗子树，也要区分它是左子树还是右子树</p><p>二叉树具有的性质：</p><ol><li>一颗非空二叉树的第$i$层上最多有$2^{i-1}$个结点$（i&gt;=1）$</li><li>一颗深度为$k$的二叉树中，最多具有$2^k-1$个结点</li><li>对于一颗非空的二叉树，如果叶子节点数为$n_0$，度数为2的结点数为$n_2$，则有$n_0=n_2+1$</li></ol><a id="more"></a><ol start="4"><li>具有$n$个结点的完全二叉树的深度为$\lfloor log_2n \rfloor+1$</li><li>对于一个有$n$个结点的全完二叉树（深度为$\lfloor log_2n \rfloor+1$），按照从根结点起，自上而下，从左到右的约定对所有结点从1到n进行编号，则对任意的编号为i的结点$(1&lt;=i&lt;=n)$有以下性质<ul><li>如果$i=1$，则结点$i$是二叉树的根，无双亲</li><li>如果$i&gt;1$，则双亲结点编号$\lfloor i/2 \rfloor$</li><li>如果$2i&gt;n$，则结点$i$无左孩子（结点$i$为叶子结点），否则其左孩子结点是$2i$</li><li>如果$2i+1&gt;n$，则结点$i$无右孩子，否则其右孩子结点$2i+1$</li></ul></li></ol><h2 id="1-2-二叉树的顺序存储结构和链式存储结构"><a href="#1-2-二叉树的顺序存储结构和链式存储结构" class="headerlink" title="1.2 二叉树的顺序存储结构和链式存储结构"></a>1.2 二叉树的顺序存储结构和链式存储结构</h2><p>（1）顺序存储结构</p><p>用一组连续的存储单元存放二叉树中的结点，一般按照二叉树结点从上至下、从左到右的顺序存储，依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映出结点之间的逻辑关系</p><p>对于一般的二叉树，只有添加一些并不存在的空结点，使之成为一颗完全二叉树的形式，然后再用一维数组顺序存储</p><p><img src="https://note.youdao.com/yws/api/personal/file/FFBEBB8C44AB4B52B84F5D6BE7F80AC9?method=download&shareKey=59baeb75b97d01169c42ae3332c597ed" alt></p><p>（2）链式存储结构</p><ol><li>二叉链表：包括三个域，数据域和左、右指针域，分别指向该结点的左孩子和右孩子</li><li>三叉链表：为了方便检索结点的双亲或祖先结点，在结构中增加一个指向其双亲结点的指针域</li></ol><h2 id="1-3-二叉树的遍历"><a href="#1-3-二叉树的遍历" class="headerlink" title="1.3 二叉树的遍历"></a>1.3 二叉树的遍历</h2><p>（1）先序遍历 </p><ol><li>访问根结点</li><li>先序遍历结点的左子树</li><li>先序遍历结点的右子树</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">if(b!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">Visit(b-&gt;data); &#x2F;&#x2F;访问结点的数据域</span><br><span class="line">PreOrder(b-&gt;lchild); &#x2F;&#x2F;先序遍历b的左子树</span><br><span class="line">PreOrder(b-&gt;rchild); &#x2F;&#x2F;先序遍历b的右子树</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><ol><li>中序遍历根结点的左子树</li><li>访问根结点</li><li>中序遍历根结点的右子树</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">if(b!&#x3D;NULL)&#123;</span><br><span class="line">InOrder(b-&gt;lchild); &#x2F;&#x2F;中序递归遍历b的左子树</span><br><span class="line">Vist(b-&gt;data); &#x2F;&#x2F; 访问结点的数据域</span><br><span class="line">InOrder(b-&gt;rchild); &#x2F;&#x2F;中序递归遍历b的右子树</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><ol><li>后序遍历根结点的左子树</li><li>后序遍历根结点的右子树</li><li>访问根结点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PostOrder(BiTree b)</span><br><span class="line">&#123;</span><br><span class="line">if(b!&#x3D;NULL)&#123;</span><br><span class="line">PostOrder(b-&gt;lchild); &#x2F;&#x2F;后续遍历b的左子树</span><br><span class="line">PostOrder(b-&gt;rchild); &#x2F;&#x2F;后续遍历b的右子树</span><br><span class="line">Vist(b-&gt;data); &#x2F;&#x2F;访问结点的数据域</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）层次遍历<br>在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根结点开始，首先将根结点指针入队列，然后从头取出一个元素，每取一个元素，执行下面两个操作：</p><ol><li>访问该元素所指结点</li><li>若该元素所指结点的左、右孩子结点非空，则将该元素所指结点的左孩子指针和右孩子指针顺序入队</li></ol><p>此过程不断进行，当队列为空时，二叉树的层次遍历结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">void LevelorderTraverse(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">BTNode *Queue[MAX_NODE], *p &#x3D; T</span><br><span class="line">int front&#x3D;0, rear&#x3D;0;</span><br><span class="line">if(p!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">Queue[++rear]&#x3D;p; # 根结点入队</span><br><span class="line"></span><br><span class="line">while(front&lt;rear)</span><br><span class="line">&#123;</span><br><span class="line">p &#x3D; Queue[++front]</span><br><span class="line">visit(p-&gt;dta);</span><br><span class="line">if(p-&gt;Lchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 左结点入队</span><br><span class="line">if(p-&gt;Rchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 右结点入队</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）遍历与恢复</p><p>已知结点的先序遍历和中序遍历，可以唯一确定这颗二叉树</p><p>已知二叉树的后续序列和中序序列也可以唯一地确定一颗二叉树</p><p>（6）遍历的应用</p><ol><li>按满二叉树方式建立链式二叉树，在建立过程中借助一个一维数组$S[n]$，编号为$i$的结点指针保存在$S[i]$中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">typedef struct BTNode</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct BTNode *Lchild, *Child;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *Create_BTree(void)</span><br><span class="line">&#123;</span><br><span class="line">BTNode *T, *p, *s[MAX_NODE];</span><br><span class="line">char ch;</span><br><span class="line">int i,j;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">if(i&#x3D;&#x3D;0) break; # 输入0结束</span><br><span class="line">else&#123;</span><br><span class="line">ch&#x3D;getchar();</span><br><span class="line">p&#x3D;(BTNode *)malloc(sizeof(BTNode));</span><br><span class="line">p-&gt;data&#x3D;ch;</span><br><span class="line">p-&gt;Lchild&#x3D;p-&gt;Rchild&#x3D;NULL;</span><br><span class="line">s[i]&#x3D;p;</span><br><span class="line">if(i&#x3D;&#x3D;1) T&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">j &#x3D; i&#x2F;2 # j是i的双亲结点编号</span><br><span class="line">if(i%2&#x3D;&#x3D;0) s[j]-&gt;Lchild&#x3D;p;</span><br><span class="line">else s[j]-Rchild&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>按先序遍历对一颗二叉树进行扩充</li></ol><p>读入一棵二叉树对应的扩充二叉树的前序遍历的结点值序列。每读入一个结点值就进行分析：</p><ul><li>若是扩充结点值：令根指针为 NULL；</li><li>若是(正常)结点值：动态地为根指针分配一个结点，将该值赋给根结点，然后递归地  创建根的左子树和右子树。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define NULLKY &#39;?&#39;</span><br><span class="line">#define MAX_NODE 50</span><br><span class="line">typedef struct BTNode</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct BTNode *Lchild, *Rchild;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *Preorder_Create_BTree(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">ch &#x3D; getchar(); getchar();</span><br><span class="line">if(ch&#x3D;&#x3D;NULLKY)</span><br><span class="line">&#123;</span><br><span class="line">T&#x3D;NULL;</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">T&#x3D;(BTNode *)malloc(sizeof(BTNode));</span><br><span class="line">T-&gt;data&#x3D;ch;</span><br><span class="line">Preorder_Creat_BTree(T-&gt;Lchild);</span><br><span class="line">Preorder_Creat_BTree(T-&gt;Rchild);</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>求二叉树的深度</li></ol><p>利用层次遍历可以直接求得二叉树的深度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_NODE 50</span><br><span class="line">int search_depth(BTNode *T)</span><br><span class="line">&#123;</span><br><span class="line">BTNode *Queue[MAX_NODE], *p&#x3D;T;</span><br><span class="line">int front&#x3D;0,rear&#x3D;0,depth&#x3D;0,level; # level总是指向访问层的最后一个结点在队列的位置</span><br><span class="line">if(T!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">Queue[++rear]&#x3D;p; # 根结点入队</span><br><span class="line">level &#x3D; rear; # 根是第一层的最后一个结点</span><br><span class="line">while(front&lt;rear)</span><br><span class="line">&#123;</span><br><span class="line">p&#x3D;Queue[++front];</span><br><span class="line">if(p-&gt;Lchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 左结点入队</span><br><span class="line">if(p-&gt;Rchild!&#x3D;NULL) Queue[++rear]&#x3D;p; # 右结点入队</span><br><span class="line"># 正好访问的是当前层的最后一个结点</span><br><span class="line">if(front&#x3D;&#x3D;level)&#123;</span><br><span class="line">depth++;</span><br><span class="line">level&#x3D;rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-线索二叉树的基本概念和构造"><a href="#1-4-线索二叉树的基本概念和构造" class="headerlink" title="1.4 线索二叉树的基本概念和构造"></a>1.4 线索二叉树的基本概念和构造</h2><p>（1）线索二叉树的定义</p><p>为了保留结点在某种遍历序列中直接前驱和直接后继的位置信息，可以利用具有$n$个结点的二叉树中的叶子节点和一度节点的$n+1$的空指针域来表示。线索二叉树便利时可不需要栈，也不需要递归了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct BiTreeNode *Lchild, *Rchild;</span><br><span class="line">int Ltag, Rtag;</span><br><span class="line">&#125;BiThrNode;</span><br></pre></td></tr></table></figure><p>（2）线索二叉树的结构</p><table><thead><tr><th align="center">lchild</th><th align="center">LTag</th><th align="center">data</th><th align="center">RTag</th><th align="center">rchild</th></tr></thead></table><p>若节点有左子树，则左指针lchild指示其左孩子（LTag=0）；否则，令指针指示其前驱（LTag=1）<br>若节点有右子树，则右指针rchild指示其右孩子（RTag=0）；否则，令指针指示其后继（RTag=1）</p><p>由于序列可由不同的遍历方法得到，因此线索树有先序线索二叉树、中序线索二叉树和后续线索二叉树</p><h1 id="2-树和森林"><a href="#2-树和森林" class="headerlink" title="2 树和森林"></a>2 树和森林</h1><h2 id="2-1-树的存储结构"><a href="#2-1-树的存储结构" class="headerlink" title="2.1 树的存储结构"></a>2.1 树的存储结构</h2><p>树的存储有多种方式，既可以是顺序存储也可以使链式存储，但是无论采用何种存储方式，都要求存储结构不但能够存储各结点本身的数据信息，还要能唯一地反映树中各结点之间的逻辑关系。</p><p>（1）双亲表示法</p><p>每个结点都有唯一的一个双亲结点，根据这一特性，可用有一组连续的存储空间（一维数组）存储树中的各个结点，数组中的一个元素表示树中的一个结点，数组元素为结构体类型，其中包含结点本身的信息以及结点的双亲结点在数组中的序号</p><p><img src="https://note.youdao.com/yws/api/personal/file/75607BFFC3A8450EA03EE96468E42F6D?method=download&shareKey=5539f5c0d7c04ef62aca513e038e96d0" alt></p><p>（2）孩子链表示法</p><p>主体是一个与结点个数一样大小的一维数组，数组的每一个元素有两个域组成，一个域用来存放结点信息，另一个用来存放指针，该指针指向由该节点孩子组成的单链表的首位置。单链表的结构也由两个域组成，一个存放孩子结点在一维数组中的序号，另一个是指针域，指向下一个孩子。</p><p><img src="https://note.youdao.com/yws/api/personal/file/8A42544EBBA44326BBA5666F33BE24A1?method=download&shareKey=4c688f9694b88b0728ab777026686f16" alt></p><p>（3）孩子兄弟表示法</p><p>在树中，每个结点除信息域外，再增加两个分别指向该节点的第一个孩子结点和下一个兄弟结点的指针</p><p><img src="https://note.youdao.com/yws/api/personal/file/FA250D1719794C3C9882EF5BCF3D863F?method=download&shareKey=91bbd9735987030fe5179f337c18e88a" alt></p><h2 id="2-2-森林和二叉树的转换"><a href="#2-2-森林和二叉树的转换" class="headerlink" title="2.2 森林和二叉树的转换"></a>2.2 森林和二叉树的转换</h2><p>（1）树转换为二叉树</p><ol><li>树中所有相邻兄弟之间加一条连线</li><li>对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</li><li>以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/EE4E54CB8140417F94E0F1FBD4E8935E?method=download&shareKey=178b6538a41ec660e9715ef1be1eb972" alt></p><p>（2）二叉树转为树</p><ol><li>加虚线，若某结点$i$是其父结点的左子树的根结点，则将该结点$i$的右子结点以及沿右子链不断地搜索所有的右子结点，将所有这些右子结点与$i$结点的父结点之间加虚线相连</li><li>去连线，去掉二叉树所有父结点与其右子结点之间的连线</li><li>规整化，将各结点按层次排列且将所有的虚线变为实线</li></ol><p>（3）森林转为二叉树</p><ol><li>将森林中的每棵树转化成相应的二叉树</li><li>第一课二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时得到的二叉树就是由森林转换得到的二叉树</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/1396EA2DA83C47B99970805C171BF8FA?method=download&shareKey=dd8d3b3b3470844848c0236d36c194eb" alt></p><p>（4）二叉树转为森林</p><ol><li>去连线，将二叉树B的根结点与其右子结点以及沿右子结点链方向的所有右子结点的连线全部去掉，得到若干棵孤立的二叉树，每一颗就是原来森林F中的树一次对应的二叉树</li><li>二叉树的还原，将各棵孤立的二叉树按二叉树还原为树的方法还原成一般的树</li></ol><h2 id="2-3-树和森林的遍历"><a href="#2-3-树和森林的遍历" class="headerlink" title="2.3 树和森林的遍历"></a>2.3 树和森林的遍历</h2><h3 id="2-3-1-树的遍历"><a href="#2-3-1-树的遍历" class="headerlink" title="2.3.1 树的遍历"></a>2.3.1 树的遍历</h3><p>（1）先根遍历</p><ol><li>访问根结点</li><li>按照从左到右的顺序先根遍历根结点的每一颗子树</li></ol><p>（2）后根遍历</p><ol><li>按照从左到右的顺序后根遍历结点的每一颗子树</li><li>访问根结点</li></ol><p>树的先根遍历与其转换的相应二叉树的先序遍历的结果序列相同；</p><p>树的后根遍历与其转换的相应二叉树的中序遍历结果序列相同</p><h3 id="2-3-2-森林的遍历"><a href="#2-3-2-森林的遍历" class="headerlink" title="2.3.2 森林的遍历"></a>2.3.2 森林的遍历</h3><p>（1）前序遍历</p><ol><li>访问森林中第一棵树的根结点</li><li>前序遍历第一课树的根结点的子树</li><li>前序遍历去掉地棵树后的子森林</li></ol><p>（2）中序遍历</p><ol><li>中序遍历第一课树的根结点的子树</li><li>访问森林中第一棵树的根结点</li><li>中序遍历去掉第一棵树后的子森林</li></ol><p>森林的前序遍历和中序遍历与所转换的二叉树的先序遍历和中序遍历的结果序列相同</p><h1 id="3-树的应用"><a href="#3-树的应用" class="headerlink" title="3 树的应用"></a>3 树的应用</h1><h2 id="3-1-二叉排序树"><a href="#3-1-二叉排序树" class="headerlink" title="3.1 二叉排序树"></a>3.1 二叉排序树</h2><p>（1）二叉排序树的性质</p><ol><li>若左子树不空，则左子树上所有结点的值均小于根节点的恶值；若右子树不空，则右子树所有结点的值均大于根结点的值</li><li>左右子树也都是二叉排序树</li></ol><p>若按中序遍历一颗二叉排序树，所得到的结点序列是一个递增序列，通常取二叉链表作为二叉排序树的存储结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">KeyType key; # 关键字</span><br><span class="line">...# 其他数据域</span><br><span class="line">struct Node *Lchild, *Rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure><p>（2）二叉排序树查找过程</p><ol><li>若查找树为空，查找失败</li><li>查找树非空，将给定值key与查找树的根结点关键码比较</li><li>若相等，查找成功，结束查找过程，否则<ul><li>当key小于根结点关键码，查找将在以左孩子为根的子树上继续进行，转1</li><li>当给key大于根结点关键码，查找将在以右孩子为根的子树上继续进行，转1</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（1）递归算法</span><br><span class="line">BSNode *BST_Search(BSTNode *T, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">if(T&#x3D;&#x3D;NULL) return NULL;</span><br><span class="line">else&#123;</span><br><span class="line">if(T-&gt;key&#x3D;&#x3D;key) return T;</span><br><span class="line">else if(key&lt; T-&gt;key) return BST_Search(T-&gt;Lchild,key);</span><br><span class="line">else return BST_Search(T-&gt;Rchild,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(2) 非递归算法</span><br><span class="line">BSTNode *BST_Search(BSTNode *T, keyType key)</span><br><span class="line">&#123;</span><br><span class="line">BSTNode p&#x3D;T;</span><br><span class="line">while(p!&#x3D;NULL &amp;&amp; p-&gt;key!&#x3D;key)</span><br><span class="line">&#123;</span><br><span class="line">if(key&lt; p-key) p&#x3D;p-&gt;Lchild;</span><br><span class="line">else p&#x3D;p-&gt;Rchild;</span><br><span class="line">&#125;</span><br><span class="line">if(p!&#x3D;NULL) return p;</span><br><span class="line">else return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）二叉排序树插入操作和构造一棵二叉排序树</p><p>设待插入节点的关键码为key，为将其插入，先要在二叉排序树中进行查找，若查找成功，不用插入；若查找不成功，则插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">（1）递归算法</span><br><span class="line">void Insert_BST(BSTNode *T, keyType key)</span><br><span class="line">&#123;</span><br><span class="line">BSTNode *x;</span><br><span class="line">x &#x3D; (BSTNode *)malloc(sizeof(BSTNode));</span><br><span class="line">x-&gt;key &#x3D; key; x-&gt;Lchild&#x3D;x-&gt;Rchild&#x3D;NULL;</span><br><span class="line">if(T&#x3D;&#x3D;NULL) T&#x3D;x;</span><br><span class="line">else&#123;</span><br><span class="line">if(T-&gt;key&#x3D;&#x3D; x-&gt;key) return; # 已有结点</span><br><span class="line">else if(x-&gt;key &lt; T-&gt;key)&#123;</span><br><span class="line">Inser_BST(T-&gt;Lchild,key);</span><br><span class="line">&#125;</span><br><span class="line">else Insert_BST(T-&gt;Rchild, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）非递归写法</span><br><span class="line">void Insert_BST(BSTNode *T, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">BSTNode *x, *p, *q;</span><br><span class="line">x &#x3D; (BSTNode *)malloc(sizeof(BSTNode));</span><br><span class="line">x-&gt;key&#x3D;key; x-&gt;Lchild &#x3D; x-&gt;Rchild&#x3D;NULL;</span><br><span class="line">if(T&#x3D;&#x3D;NULL) T&#x3D;x;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">p&#x3D;T;</span><br><span class="line">while(p!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">if(p-&gt;key&#x3D;&#x3D;x-&gt;key) return;</span><br><span class="line">q&#x3D;p;</span><br><span class="line">if(x-&gt;key &lt; p-&gt;key) p&#x3D;p-&gt;Lchild;</span><br><span class="line">else p&#x3D;p-&gt;Rchild;&#125;</span><br><span class="line">if(x-&gt;key &lt; q-&gt;key) q-&gt;Lchild&#x3D;x;</span><br><span class="line">else q-&gt;Rchild&#x3D;x;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）二叉排序树删除操作<br>从BST树上删除一个节点，仍然要保证删除后满足BST的性质，设被删除结点为p，其父结点为f</p><p>（前驱和后继是指中序遍历中的）</p><ol><li>若 p 是叶子结点： 直接删除 p。</li><li>若 p 只有一棵子树(左子树或右子树)：直接用 p 的左子树(或右子树)取代 p 的位置而成为 f 的一棵子树。原来 p 是 f 的左子树，则 p 的子树为 f 的左子树；原来 p 是 f 的右子树，则 p 的子树为 f 的右子树。</li><li>若 p 既有左子树又有右子树 ：<ul><li>a、用 p 的直接前驱结点代替 p。即从 p 的左子树中选择值最大的结点 s 放在 p 的位置(用结点 s 的内容替换结点 p 内容)，然后删除结点 s。s 是 p 的左子树中的最右边的结点且没有右子树，对 s 的删除同 2</li><li>b、用 p 的直接后继结点代替p。即从 p 的右子树中选择值最小的结点 s 放在 p 的位置(用结点 s 的内容替换结点 p 内容)，然后删除结点 s。s 是 p 的右子树中的最左边的结点且没有左子树，对 s 的删除同 2</li></ul></li></ol><h2 id="3-2-平衡二叉树"><a href="#3-2-平衡二叉树" class="headerlink" title="3.2 平衡二叉树"></a>3.2 平衡二叉树</h2><p>具有下列性质的二叉排序树：左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差的绝对值不超过一</p><p>结点类型定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BNode</span><br><span class="line">&#123;</span><br><span class="line">KeyType key; # 关键字域</span><br><span class="line">int Bfactoe; # 平衡因子域</span><br><span class="line">... # 其它数据域</span><br><span class="line">struct BNode *Lchild, *Rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure><p>（1）LL在结点a的左孩子的左子树进行插入，插入使结点a失去平衡</p><p>通过顺时针旋转调整</p><ol><li>用b取代a的位置</li><li>a成为b的右子树的根结点</li><li>b原来的右子树作为a的左子树<br><img src="https://note.youdao.com/yws/api/personal/file/A8C880E9070E4BCC80D88E2C693BA16A?method=download&shareKey=a1fb1ffd7ee5d74e98528ca8bebe6d57" alt></li></ol><p>（2）LR在结点a的左孩子的右子树上进行插入，插入使结点a失去平衡</p><p>通过LR旋转</p><ol><li>先以b进行一次逆时针旋转（将以b为根的子树旋转为以c为根）</li><li>以a进行一次顺时针旋转，将整棵子树旋转以c为根</li><li>c的右子树移到a的左子树位置，c的左子树移到b的右子树位置</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/F6D908CCFFB6491F8511CF4CC0C3B1AB?method=download&shareKey=ee74a5e0fd169044915253fc53c2e363" alt></p><p>（3）RL在结点a的右孩子的左子树上进行插入，插入使结点a失去平衡，与LR型正好对称</p><p>通过RL旋转</p><ol><li>先以b进行一次顺时针旋转</li><li>再以a进行一次逆时针旋转，将整棵子树（以a为根）旋转为以c为根</li><li>c的右子树移到b的左子树，c的左子树移到a的右子树</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/10E450C657424D2DA03FBD2C10AE1EE5?method=download&shareKey=e078245da33388048e5785f4c9fbaef0" alt></p><p>（4）RR在结点a的右孩子的右子树上进行插入，插入使结点a失去平衡</p><p>要进行一次逆时针旋转，和LL旋转正好对称</p><ol><li>用b取代a的位置</li><li>a作为b的左子树的根结点</li><li>b原来的左子树作为a的右子树</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/EAD2CBB56809414793546497AD6114FC?method=download&shareKey=d48eb4d2a65c980204ed747905b4ef89" alt></p><h2 id="3-3-哈夫曼树和哈夫曼编码"><a href="#3-3-哈夫曼树和哈夫曼编码" class="headerlink" title="3.3 哈夫曼树和哈夫曼编码"></a>3.3 哈夫曼树和哈夫曼编码</h2><p>（1）Huffman树的构造</p><ol><li>根据n个权值，构造哈夫曼树</li><li>选取两棵根结点权值最小的树作为左、右子树构造一棵新的二叉树，且新的二叉树根结点权值为其左、右子树根结点的权值之和</li><li>重复2操作，知道所有权值都使用上</li></ol><p>（2）Huffman编码</p><p>规定左分支代表“0”，右分支代表“1”。从根结点到每个叶子结点所经历的路径上的字符串，为该节点所对应的编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-二叉树&quot;&gt;&lt;a href=&quot;#1-二叉树&quot; class=&quot;headerlink&quot; title=&quot;1 二叉树&quot;&gt;&lt;/a&gt;1 二叉树&lt;/h1&gt;&lt;h2 id=&quot;1-1-二叉树的定义及其主要特性&quot;&gt;&lt;a href=&quot;#1-1-二叉树的定义及其主要特性&quot; class=&quot;headerlink&quot; title=&quot;1.1 二叉树的定义及其主要特性&quot;&gt;&lt;/a&gt;1.1 二叉树的定义及其主要特性&lt;/h2&gt;&lt;p&gt;二叉树是有序的，即使树中节点只有一颗子树，也要区分它是左子树还是右子树&lt;/p&gt;
&lt;p&gt;二叉树具有的性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一颗非空二叉树的第$i$层上最多有$2^{i-1}$个结点$（i&amp;gt;=1）$&lt;/li&gt;
&lt;li&gt;一颗深度为$k$的二叉树中，最多具有$2^k-1$个结点&lt;/li&gt;
&lt;li&gt;对于一颗非空的二叉树，如果叶子节点数为$n_0$，度数为2的结点数为$n_2$，则有$n_0=n_2+1$&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（三）：数据链路层</title>
    <link href="https://liangggggg.github.io/2020/08/13/network3/"/>
    <id>https://liangggggg.github.io/2020/08/13/network3/</id>
    <published>2020-08-13T01:47:42.000Z</published>
    <updated>2020-08-27T05:38:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据链路层的功能"><a href="#1-数据链路层的功能" class="headerlink" title="1 数据链路层的功能"></a>1 数据链路层的功能</h1><p>链路层主要包括链路管理、帧同步、流量控制、差错控制、数据和控制信息分开、透明传输和寻址</p><a id="more"></a><h1 id="2-组帧"><a href="#2-组帧" class="headerlink" title="2 组帧"></a>2 组帧</h1><p>封装成帧就是在一段数据的前后分别添加首部和尾部。</p><p>控制字符SOH放在帧的最前面，表示帧的首部开始，EOT表示帧的结束</p><p>为解决透明传输问题，发送端在数据链路层在数据中出现控制字符SOH或EOT的前面插入一个转义字符ESC</p><p>（1）面向比特的方法</p><p>PPP协议采用零比特填充方法来实现透明传输（只要发现5个连续1，则立即填入一个0）</p><p>（2）面向字符的异步传输</p><p>把转义字符定义为0x7D（011111101）</p><ol><li>把信息字段中出现的每一个0x7E转变为2字节序列（0x7D,0x5E）</li><li>若信息字段中出现一个0x7D字节，把0x7D转换为2字节序列(0x7D,0x5D)</li><li>若出现ASCII码控制字符，在该字符前面加入0x7D字节，同时将该字符的编码加以改变</li></ol><h1 id="3-差错控制"><a href="#3-差错控制" class="headerlink" title="3 差错控制"></a>3 差错控制</h1><p>循环冗余校验CRC技术</p><p>在数据M的后面添加提供差错检测用的n位冗余码，然后构成一个帧发送出去，一共发送(k+n)位</p><p>在接收端把每一个帧都除以相同的除数p，检查得到的余数R</p><p>如果传输过程中无差错，那么经过CRC校验后得出的余数R为0</p><h1 id="4-流量控制与可靠传输机制"><a href="#4-流量控制与可靠传输机制" class="headerlink" title="4 流量控制与可靠传输机制"></a>4 流量控制与可靠传输机制</h1><p>流量控制的目的是控制双方发送的速率，可靠传输保证不丢帧</p><h2 id="4-1-停止-等待协议"><a href="#4-1-停止-等待协议" class="headerlink" title="4.1 停止-等待协议"></a>4.1 停止-等待协议</h2><p>每发送完一个分组就停止发送，等待对方的确认，收到确认后再发送下一个分组</p><p>具有确认和重传机制的可靠传输协议称为自动重传请求ARQ，为提高传输效率，采用连续ARQ协议，发送方每收到一个确认，就把发送串口向前滑动一个分组的位置</p><p>接收方采用累积确认的方式</p><h2 id="4-2-退后N帧协议（GBN）"><a href="#4-2-退后N帧协议（GBN）" class="headerlink" title="4.2 退后N帧协议（GBN）"></a>4.2 退后N帧协议（GBN）</h2><p>若发现N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧</p><h2 id="4-3-选择重传协议（SR）"><a href="#4-3-选择重传协议（SR）" class="headerlink" title="4.3 选择重传协议（SR）"></a>4.3 选择重传协议（SR）</h2><p>当接收方发现某镇出错后，某后继续送来的正确的帧虽然不能立即递交给接受方的高层，但接受方仍可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧</p><h1 id="5-介质访问控制"><a href="#5-介质访问控制" class="headerlink" title="5 介质访问控制"></a>5 介质访问控制</h1><h2 id="5-1-信道划分介质访问控制"><a href="#5-1-信道划分介质访问控制" class="headerlink" title="5.1 信道划分介质访问控制"></a>5.1 信道划分介质访问控制</h2><p>1、频分复用FDM、时分复用TDM和统计时分复用</p><p>2、波分复用WDM</p><p>3、码分复用CDM</p><p>更常用的名词是码分多址CDMA，每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><h2 id="5-2-随机访问介质控制访问"><a href="#5-2-随机访问介质控制访问" class="headerlink" title="5.2 随机访问介质控制访问"></a>5.2 随机访问介质控制访问</h2><p>1、ALOHA协议</p><p>用户有帧即发送，采用冲突监听与随机重发机制。两帧冲突或重叠则会被破坏，因此效率不高</p><p>2、载波监听多路访问CSMA</p><p>当一个站点要发送数据前，监听总线，如果总线空闲则发送数据</p><p>3、载波监听多路访问/冲突检测 CSMA/CD</p><p>载波监听就是用电子技术检测总线上有没有其他计算机也在发送，碰撞检测也就是边发送边监听，判断自己在发送数据时其他站点是否也在发送数据</p><p>4、CSMA/CA</p><p>CSMA/CD协议已经成功地应用于有线连接的局域网，但无线局域网要使用CSMA/CA</p><h1 id="6-局域网"><a href="#6-局域网" class="headerlink" title="6 局域网"></a>6 局域网</h1><p>（1）具有广播功能，从一个站点可很方便地访问全网</p><p>（2）各设备的位置可灵活调整和改变，提高了系统的可靠性、可用性和生存性</p><p>为了使数据链路层更好地适应多种局域网标准，将IEEE 802委员会把局域网的数据链路层拆成两个子层，即逻辑链路控制LLC和媒体接入控制MAC</p><p>与接入到传输谋体有关的内容放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的</p><p>MAC层的硬件地址</p><p>在局域网中，硬件地址又称为物理地址或MAC地址</p><h1 id="7-广域网"><a href="#7-广域网" class="headerlink" title="7 广域网"></a>7 广域网</h1><h2 id="7-1-PPP协议"><a href="#7-1-PPP协议" class="headerlink" title="7.1 PPP协议"></a>7.1 PPP协议</h2><p>当PPP使用异步传输时，把转义字符定义为0x7D，并用字节填充</p><p>用SONET/SDH链路时，使用同步传输，采用零比特填充方法来实现透明传输</p><h2 id="7-2-HDLC协议"><a href="#7-2-HDLC协议" class="headerlink" title="7.2 HDLC协议"></a>7.2 HDLC协议</h2><p>通用的数据链路控制协议，在开始建立数据链路时，允许选用特定的操作方式</p><p>所谓操作方式，通俗来将就是某站点是以主站点方式操作还是从站点方式操作，或者二者兼备。</p><h1 id="8-数据链路设备"><a href="#8-数据链路设备" class="headerlink" title="8 数据链路设备"></a>8 数据链路设备</h1><p>1、网桥</p><p>在数据链路层扩展局域网是使用网桥。根据MAC帧的目的地址对收到的帧进行转发</p><p>2、交换机</p><p>以太网交换机实质上就是一个多接口的网桥</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-数据链路层的功能&quot;&gt;&lt;a href=&quot;#1-数据链路层的功能&quot; class=&quot;headerlink&quot; title=&quot;1 数据链路层的功能&quot;&gt;&lt;/a&gt;1 数据链路层的功能&lt;/h1&gt;&lt;p&gt;链路层主要包括链路管理、帧同步、流量控制、差错控制、数据和控制信息分开、透明传输和寻址&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（二）：栈、队列和数组</title>
    <link href="https://liangggggg.github.io/2020/08/13/Data2/"/>
    <id>https://liangggggg.github.io/2020/08/13/Data2/</id>
    <published>2020-08-13T00:33:42.000Z</published>
    <updated>2020-08-26T12:56:49.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h1><p>限定仅在表尾进行插入或删除操作的线性表</p><p><img src="https://note.youdao.com/yws/api/personal/file/E759729F50D449788BC9B52C9C1611E9?method=download&shareKey=4708c48d5e45c8fd0af3e6ec588b1381" alt></p><h2 id="1-1-栈的顺序存储结构"><a href="#1-1-栈的顺序存储结构" class="headerlink" title="1.1 栈的顺序存储结构"></a>1.1 栈的顺序存储结构</h2><p>栈的顺序存储结构简称为顺序栈，用一维数组来存储栈。根据数组是否可以根据需要增大，又可分为静态顺序栈和动态顺序栈</p><a id="more"></a><p>（1）动态顺序栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本操作实现</span><br><span class="line">1 栈的定义</span><br><span class="line"># define STACK_SIZE 100;</span><br><span class="line"># define STACKINCREMENT 10;</span><br><span class="line"># typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct sqstack</span><br><span class="line">&#123;</span><br><span class="line">ElemType *bottem; # 栈不存在时为NULL</span><br><span class="line">ElemType *top; # 栈顶指针</span><br><span class="line">int stacksize; # 当前已分空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">SqStack Init_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">S.bottom &#x3D; (ElemType *)malloc(STACK_SIZE * sizeof(ElemType));</span><br><span class="line">if (!S.bottom) return ERROR;</span><br><span class="line">S.top &#x3D; S.bottom; # 栈空时栈顶和栈底指针相同</span><br><span class="line">S.stacksize &#x3D; STACK_SIZE;</span><br><span class="line">return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 压栈</span><br><span class="line">Status push(SqStack &amp;S, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if(S.top-S.bottom&gt;&#x3D;S.sstacksize-1)</span><br><span class="line">&#123;# 栈满，追加空间</span><br><span class="line">S.bottom&#x3D;(ElemType *)realloc(S.bottom, (S.STACKINCRMENT+STACK_SIEZE)*sizeof(ElemType));</span><br><span class="line">if(!S.bottom) return ERROR;</span><br><span class="line">S.top &#x3D; S.bottom+S.stacksize-1;</span><br><span class="line">S.stacksize+&#x3D;STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">S.top &#x3D; e; S.top++; # 栈顶指针+1，e称为新的栈顶</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4 弹栈</span><br><span class="line">Status pop(SqStack &amp;S, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if(S.top&#x3D;&#x3D;S.bottom) return ERROR;</span><br><span class="line">S.top--; *e &#x3D; S.top;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）静态顺序栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">基本操作的实现</span><br><span class="line">1 栈的类型定义</span><br><span class="line"># define MAX_STACK_SIZE 100</span><br><span class="line">typedef int ElemTypde;</span><br><span class="line">typedef struct Sqstack</span><br><span class="line">&#123;</span><br><span class="line">ElemType stack_array[MAX_STACK_SIZE];</span><br><span class="line">int top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">SqStack Init_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">S.top &#x3D; 0;</span><br><span class="line">return S;</span><br><span class="line">&#125;</span><br><span class="line">3 压栈</span><br><span class="line">Status push(SqStack &amp;S, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if(S.top&#x3D;&#x3D;MAX_STACK_SIZE-1) return ERROR;</span><br><span class="line">S.top++;</span><br><span class="line">S.stack_array[S.top]&#x3D;e</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line">4 弹栈</span><br><span class="line">Status pop(SqStack &amp;S, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if(S.top&#x3D;&#x3D;0) return ERROR;</span><br><span class="line">*e &#x3D; S.stack_array[S.top];</span><br><span class="line">S.top--;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）栈的链式存储结构</p><p>链栈，是运算受限的单链表，其插入和删除操作只能在表头位置上进行，栈顶指针top就是链表的头指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1 栈的定义</span><br><span class="line">typedef struct Stack_Node</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">Struct Stack_Node *next;</span><br><span class="line">&#125;Stack_Node;</span><br><span class="line"></span><br><span class="line">2 栈的初始化</span><br><span class="line">Stack_Node *Init_Link_Stack(void)</span><br><span class="line">&#123;</span><br><span class="line">Stack_Node *top;</span><br><span class="line">top &#x3D; (Stack_Node *)malloc(sizeof(Stack_Node));</span><br><span class="line">top-&gt;next&#x3D;NULL;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 压栈</span><br><span class="line">Status push(Stack_Node *top, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">Stack_Node *p;</span><br><span class="line">p &#x3D; (Stack_Node *)malloc(sizeof(Stack_Node));</span><br><span class="line">if(!p) return ERROR;</span><br><span class="line">p-&gt;data &#x3D; e;</span><br><span class="line">p-&gt;next &#x3D; top-&gt;next;</span><br><span class="line">top-&gt;next &#x3D; p;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4 出栈</span><br><span class="line">Status pop(Stack_Node *top, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">Stack_Node *p;</span><br><span class="line">if(top-&gt;next&#x3D;NULL) return ERROR;</span><br><span class="line">p &#x3D; top-&gt;next; *e&#x3D;p-&gt;data;</span><br><span class="line">top-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">free(p)</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/179D6F1B2AA8401183DAD94F42E83FE9?method=download&shareKey=2b508c9cf73a4e6f8d5eb58630dc5f0c" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/8ABC92C47E6C482CBEB192D618EF06B8?method=download&shareKey=4d35165ff818a4551ec522a880c9c59a" alt></p><h2 id="1-2-栈的应用"><a href="#1-2-栈的应用" class="headerlink" title="1.2 栈的应用"></a>1.2 栈的应用</h2><p>（1）数制转换<br>十进制数N和其他d进制数的转换是计算机实现计算的基本问题，最简单算法基于：$N=(N\ div\ d)* d + N\ mod\ d$</p><p>采用静态顺序栈方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">将十进制数N转化为d进制数</span><br><span class="line">void conversion(int n, int d)</span><br><span class="line">&#123;</span><br><span class="line">SqStack S; int k, *e;</span><br><span class="line">S&#x3D;Init_Stack();</span><br><span class="line"># 求所有的余数，进栈</span><br><span class="line">while(n&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">k &#x3D; n%d;</span><br><span class="line">push(S,k);</span><br><span class="line">n&#x3D;n&#x2F;d;</span><br><span class="line">&#125;</span><br><span class="line"># 栈不空时，输出</span><br><span class="line">while(S.top!&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">pop(S,e);</span><br><span class="line">printf(&quot;%1d&quot;, *e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）括号匹配</p><p>设置一个栈，当读到左括号时，左括号进栈，当读到右括号时，则从栈中弹出一个元素，与读到的左括号进行匹配，若匹配成功则继续读入；否则匹配失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define TRUE 0</span><br><span class="line">#define FALSE -1</span><br><span class="line">SqStack S;</span><br><span class="line">S &#x3D; Init_Stack();</span><br><span class="line">int Match_Brackets()</span><br><span class="line">&#123;</span><br><span class="line">char ch, x;</span><br><span class="line">scanf(&quot;%c&quot;, &amp;ch);</span><br><span class="line">while(asc(ch)!&#x3D;13)</span><br><span class="line">&#123;</span><br><span class="line">if((ch&#x3D;&#x3D;&#39;(&#39;)||(ch&#x3D;&#x3D;&#39;[&#39;)) push(S,ch);</span><br><span class="line">else if(ch&#x3D;&#x3D;&#39;]&#39;)</span><br><span class="line">&#123;</span><br><span class="line">x&#x3D;pop(S);</span><br><span class="line">if(x!&#x3D;&#39;[&#39;)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;&#39;]&#39;括号不匹配&quot;);</span><br><span class="line">return FALSE;&#125;&#125;</span><br><span class="line">else if(ch&#x3D;&#x3D;&#39;)&#39;)</span><br><span class="line">&#123;</span><br><span class="line">x&#x3D;pop(S);</span><br><span class="line">if(x!&#x3D;&#39;(&#39;)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;&#39;(&#39;括号不匹配&quot;)，</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(S.top!&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;括号数量不匹配&quot;);</span><br><span class="line">return FALSE;&#125;</span><br><span class="line">else return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）递归</p><p>为保证递归调用正确执行，系统设立一个“递归工作栈”，作为整个递归调用过程期间使用的数据存储区。每一层包含的信息如：参数，局部变量、上一层的返回地址构建一个“工作记录”。每进入一层递归栈，就产生一个新的工作记录压入栈顶；每退出一层递归，就从栈顶弹出一个工作记录。</p><h1 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h1><p>插入在表一端进行，而删除在表的另一端进行，把允许插入的一端叫队尾，允许删除的一端叫队头</p><h2 id="2-1-队列的顺序存储结构"><a href="#2-1-队列的顺序存储结构" class="headerlink" title="2.1 队列的顺序存储结构"></a>2.1 队列的顺序存储结构</h2><p><img src="https://note.youdao.com/yws/api/personal/file/6E8BB975C5E840FA836368D66975CA58?method=download&shareKey=dff56d5e9e448f78b30951418edd884a" alt></p><p>当尾指针移动到最后，再有元素入队就会溢出，但是此时队列并未真正的“满员”，这种现象称为“假溢出”，为了解决假溢出，可以将队列的数据区看成首尾相接的循环结构，头尾指针的关系不变，将其称为“循环队列”</p><p>约定以“队列头指针在队列尾指针的下一位置（指换装的下一位置）”上作为队列满的标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">队空特征：front&#x3D;rear;</span><br><span class="line">队满特征：front&#x3D;(rear+1)%MAX_QUEUE_SIZE;</span><br><span class="line">队列长度：L&#x3D;(MAX_QUEUE_SIZE+rear-front)%MAX_QUEUE_SIZE；</span><br><span class="line"></span><br><span class="line">静态顺序队列，其类型定义如下：</span><br><span class="line"># define MAX_QUEUE_SIZE 100</span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">ElemType Queue_array[MAX_QUEUE_SIZE];</span><br><span class="line">int front;</span><br><span class="line">int rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">循环队列的基本操作</span><br><span class="line">1 循环队列的初始化</span><br><span class="line">Status Init_CirQueue(* &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">Q &#x3D; (SqQueue *)malloc(sizeof(SqQueue));</span><br><span class="line">if(Q&#x3D;&#x3D;NULL) return ERROR;</span><br><span class="line">Q-&gt;front&#x3D; Q-&gt;rear&#x3D;0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2 入队操作</span><br><span class="line">Status Insert_CirQueue(SqQueue *&amp;Q, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if((Q-&gt;rear+1)%MAX_QUEUE_SIZE&#x3D;&#x3D;Q-&gt;front) return ERROR;</span><br><span class="line">Q-&gt;Queue_array[Q-&gt;rear] &#x3D;e;</span><br><span class="line">Q-&gt;rear&#x3D;(Q-&gt;rear+1)%MAX_QUEUE_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 出队操作</span><br><span class="line">Status Delete_CireQueue(SqQueue *&amp;Q, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear) return ERROR;</span><br><span class="line">*x &#x3D; Q-&gt;Queue_array[Q-&gt;front];</span><br><span class="line">Q-&gt;front &#x3D; (Q-&gt;front+1)% MAX_QUEUE_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-队列的链式存储结构"><a href="#2-2-队列的链式存储结构" class="headerlink" title="2.2 队列的链式存储结构"></a>2.2 队列的链式存储结构</h2><p>队列的链式存储结构简称为链队列，是限制仅在表头进行删除操作和表尾进行插入操作的单链表，需要两类不同的结点：数据元素结点，队列的队首指针和队尾指针的结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">元素结点的定义</span><br><span class="line">typedef struct Qnode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">Struct Qnode *next;</span><br><span class="line">&#125;QNode;</span><br><span class="line">指针结点类型定义：</span><br><span class="line">typedef struct link_queue</span><br><span class="line">&#123;</span><br><span class="line">QNode *front, *rear;</span><br><span class="line">&#125;Link_Queue;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/3B00BB79D4854E1FAD7625888C9A5550?method=download&shareKey=b324c8b770023286850dac1c9c3e30fb" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 链队列初始化</span><br><span class="line">LinkQueue *Init_Link_Queue(void)</span><br><span class="line">&#123;</span><br><span class="line">Link_Queue *Q; </span><br><span class="line">QNode *p;</span><br><span class="line">p &#x3D; (QNode *)malloc(sizeof(QNode)) # 开辟头结点</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">Q &#x3D; (Link_Queue *)malloc(sizeof(Link_Queue)); # 开辟链队的指针结点</span><br><span class="line">Q.front &#x3D; Q.rear&#x3D;p;</span><br><span class="line">return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2 链队列的入队</span><br><span class="line">在已知队列的队尾插入一个元素e,即修改队尾指针Q.rear</span><br><span class="line">Status Insert_LinkQueue(Link_Queue *Q, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">QNode *p;</span><br><span class="line">p &#x3D; (QNode *)malloc(sizeof(QNode)); if(!p) return ERROR;</span><br><span class="line">p-&gt;data&#x3D;e; p-&gt;next&#x3D;NULL;</span><br><span class="line">Q-&gt;rear-&gt;next&#x3D;p;</span><br><span class="line">Q-&gt;rear&#x3D;p;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3 链队列的出队</span><br><span class="line">Status Delete_LinkQueue(LinkQueue *Q, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">QNode *p;</span><br><span class="line">if(Q-&gt;front &#x3D; Q-&gt;rear) return ERROR;</span><br><span class="line">p&#x3D;Q-&gt;front-&gt;next;</span><br><span class="line">*x &#x3D; p-&gt;data;</span><br><span class="line">Q-&gt;front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">if(p&#x3D;&#x3D;Q-&gt;rear) Q-&gt;rear&#x3D;Q-&gt;front; # 当队列只有一个结点时应防止丢失队尾指针</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-特殊矩阵的压缩存储"><a href="#3-特殊矩阵的压缩存储" class="headerlink" title="3 特殊矩阵的压缩存储"></a>3 特殊矩阵的压缩存储</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>数组是一组对偶（下标值，数据元素值）的集合，并且该序列必须存储在一块地址连续的存储单元中</p><ul><li>数组中的元素数据具有相同数据类型</li><li>数组是一种随机存取结构，给定一组下标，就可以访问与其对应的数据元素</li><li>数组中的数据元素个数是固定的</li></ul><p>二维数组是最简单的多维数组，通常有两种顺序存储方式</p><p>（1）行优先顺序：将数组元素按行排列，第$i+1$个行向量紧接在第$i$个行向量后面</p><p>设有二维数组$A=(a_{ij})m * n$，若每个元素占有的存储单元为1个，$LOC[a_{11}]$表示数组的首地址</p><p>二维数组中，任意元素$a_{ij}$的地址是：<br>$$LOC[a_{ij}]=LOC[a_{11}]+[(i-1) * n+(j-1)] * 1$$</p><p>（2）列优先顺序：将数组元素按列排列，第$j+1$个列向量紧接在第$j$个列向量后面</p><p>二维数组中，任意元素$a_{ij}$的地址是：<br>$$LOC[a_{ij}]=LOC[a_{11}]+[(j-1) * m+(i-1)] * 1$$</p><h2 id="3-2-特殊矩阵"><a href="#3-2-特殊矩阵" class="headerlink" title="3.2 特殊矩阵"></a>3.2 特殊矩阵</h2><p>特殊矩阵（对称矩阵，对角矩阵，三角矩阵）压缩矩阵：若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</p><p>（1）对称矩阵</p><p>关于主对角线对称，因此只需存储上三角或下三角即可</p><p>以一维数组$sa[n(n+1)/2]$作为n阶对称矩阵A的存储结构，则$sa[k]$和矩阵元$a_{ij}$之间存在着一一对应的关系：</p><p>$$<br>k=<br>\begin{cases}<br>\frac{i(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{j(j-1)}{2}+i-1,\ i&lt;j<br>\end{cases}<br>$$</p><p>（2）三角矩阵</p><ul><li>下三角矩阵</li></ul><p>在下三角矩阵，主对角线以上的元素是一个常量，存完下三角中的元素之后，紧接着储存对角线上方的常量，因为是同一个常数，所以存一个即可</p><p>共存储了$n(n+1)/2$个元素，设存入向量$sa=[k]$中，$k$与$i，j$的对应关系为:</p><p>$$<br>k=<br>\begin{cases}<br>\frac{i(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{n(n-1)}{2},\ i&lt;j<br>\end{cases}<br>$$</p><ul><li>上三角矩阵<br>和下三角矩阵类似，其对应关系如下：<br>$$<br>k=<br>\begin{cases}<br>\frac{(2n-i+2)(i-1)}{2}+j-1, \  i&gt;=j\\<br>\frac{n(n-1)}{2},\ i&lt;j<br>\end{cases}<br>$$</li></ul><p>（3）对角矩阵</p><p>所有非零元素都集中在以主对角线为中心的对角区域，即除了主对角线和它的上下方若干条对角线的元素外，所有其他元素都为零（或同一个常数C）</p><h2 id="3-3-稀疏矩阵"><a href="#3-3-稀疏矩阵" class="headerlink" title="3.3 稀疏矩阵"></a>3.3 稀疏矩阵</h2><p>稀疏矩阵：设矩阵 A 是一个 $n * m$ 的矩阵中有 $s$ 个非零元素，设 $\delta=s/(n * m)$，称$\delta$为稀疏因子，如果某一矩阵的稀疏因子$\delta$满足$\delta&lt;=0.05$ 时称为稀疏矩阵。对于稀疏矩阵，采用压缩存储方法时，只存储非 0 元素。必须存储非 0 元素的行下标值、列下标值、元素值。</p><p><img src="https://note.youdao.com/yws/api/personal/file/60254E2717D14DB39AF9A804B447F040?method=download&shareKey=cc6925679ea8792332ab7da244769187" alt></p><p>（1）三元组顺序表</p><p>若以行序为主序，稀疏矩阵中所有非 0 元素的三元组，就可以得构成该稀疏矩阵的一个三元组顺序表。相应的数据结构定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1） 三元组结点定义</span><br><span class="line">#define MAX_SIZE 101 </span><br><span class="line">typedef int elemtype;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;int row; &#x2F;*行下标*&#x2F; </span><br><span class="line">int col; &#x2F;*列下标*&#x2F; </span><br><span class="line">elemtype value; &#x2F;*元素值*&#x2F;</span><br><span class="line">&#125;Triple;</span><br><span class="line">（2） 三元组顺序表定义</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int rn;# 行数</span><br><span class="line">int cn; # 列数</span><br><span class="line">int tn; # 非零元素个数</span><br><span class="line">Triple data[MAX_SIZE];</span><br><span class="line">&#125;TMatrix;</span><br></pre></td></tr></table></figure><p>（2）十字链表</p><p>对于稀疏矩阵，当非 0 元素的个数和位置在操作过程中变化较大时，采用链式存储结构表示比三元组的线性表更方便。<br>矩阵中非 0 元素的结点所含的域有：行、列、值、行指针(指向同一行的下一个非 0 元)、<br>列指针(指向同一列的下一个非 0 元)。其次，十字交叉链表还有一个头结点，结点的结构如图所示。</p><p><img src="https://note.youdao.com/yws/api/personal/file/9CBAA88EAE7344A29B1EE9251565FE35?method=download&shareKey=9a5a57e9724f4a833bbf4016fc97ce24" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Clnode</span><br><span class="line">&#123;</span><br><span class="line">int row, col;</span><br><span class="line">elemtype value;</span><br><span class="line">struct Clnode *down, *right;</span><br><span class="line">&#125;QLNode;</span><br><span class="line"></span><br><span class="line">typdef struct Clonde</span><br><span class="line">&#123;</span><br><span class="line">int rn; # 行数</span><br><span class="line">int cn; # 列数</span><br><span class="line">int tn; # 非0元素总数</span><br><span class="line">QLNode *rhead;</span><br><span class="line">QLNode *chead;</span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/CF1C494E17F841DB90012A6139364334?method=download&shareKey=42bca25aac0ad5118ff7ee86eefe94ea" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;1 栈&quot;&gt;&lt;/a&gt;1 栈&lt;/h1&gt;&lt;p&gt;限定仅在表尾进行插入或删除操作的线性表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/E759729F50D449788BC9B52C9C1611E9?method=download&amp;shareKey=4708c48d5e45c8fd0af3e6ec588b1381&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-栈的顺序存储结构&quot;&gt;&lt;a href=&quot;#1-1-栈的顺序存储结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 栈的顺序存储结构&quot;&gt;&lt;/a&gt;1.1 栈的顺序存储结构&lt;/h2&gt;&lt;p&gt;栈的顺序存储结构简称为顺序栈，用一维数组来存储栈。根据数组是否可以根据需要增大，又可分为静态顺序栈和动态顺序栈&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（二）：物理层</title>
    <link href="https://liangggggg.github.io/2020/08/12/network2/"/>
    <id>https://liangggggg.github.io/2020/08/12/network2/</id>
    <published>2020-08-12T01:47:42.000Z</published>
    <updated>2020-08-26T13:56:05.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通信基础"><a href="#1-通信基础" class="headerlink" title="1 通信基础"></a>1 通信基础</h1><p>时延：是指数据（一个报文或者分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，网络中的时延由以下几个不同部分组成</p><ol><li>传输时延=发送时延：发送数据时，数据块从结点进入到传输媒体所需要的时间</li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间</li><li>处理时延：交换结点为储存转发而进行一些必要的处理所花费的时间</li><li>排序时延：结点缓存队列中分组排序所经历的时延</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/DDD4CD39869743DE8A80130BC9D21D21?method=download&shareKey=e60a924c7b234f947269dd2c1f6e99e1" alt></p><a id="more"></a><h1 id="2-电路交换、报文交换与分组交换"><a href="#2-电路交换、报文交换与分组交换" class="headerlink" title="2 电路交换、报文交换与分组交换"></a>2 电路交换、报文交换与分组交换</h1><p>（1）电路交换</p><p>在使用电路交换通话前，必须先拨号请求建立连接，当被叫用户听到交换机送来的震铃音并摘机后，从主叫端到被叫端建立了一条连接，也就是一条专用的物理通路，通话完毕后，交换机释放刚才使用的这条专用的物理通路。这种必须经过建立连接、通话和释放连接三个步骤的交换方式称为电路交换</p><p>（2）报文交换</p><p>传输单位是报文，一次性发送的数据块，当一个站要发送报文时，将一个目的地址附加到报文上，网络结点根据报文上的目的地址信息，把报文发送到下一节点，一直逐个节点地转送到目的节点，无需通过呼叫建立连接</p><p>（3）分组交换</p><p>分组交换是报文交换的一种改进，将报文分成若干个组，可以存储在内存中，提高了交换速度</p><h1 id="3-数据报与虚电路"><a href="#3-数据报与虚电路" class="headerlink" title="3 数据报与虚电路"></a>3 数据报与虚电路</h1><p>当两台计算机进行通信时，应当先建立连接（虚电路），预留双方通信所需要的一切网络资源，然后双方就沿着已建立的虚电路发送分组。这样分组的首部不需要填写完整的目的主机地址，只需要填写这条虚电路的编号，减少了分组的开销。</p><h1 id="4-传输介质"><a href="#4-传输介质" class="headerlink" title="4 传输介质"></a>4 传输介质</h1><p>1、双绞线<br>2、同轴电缆<br>3、光缆<br>4、无线通信</p><h1 id="5-物理层设备"><a href="#5-物理层设备" class="headerlink" title="5 物理层设备"></a>5 物理层设备</h1><p>（1）中继器</p><p>过去广泛使用粗缆或细缆以太网，常用工作在物理层的中继器又称转发器来扩展以太网的地理覆盖范围</p><p>（2）集线器</p><p>集线器是多端口的中继器，用多个集线器可以连成更大的局域网</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-通信基础&quot;&gt;&lt;a href=&quot;#1-通信基础&quot; class=&quot;headerlink&quot; title=&quot;1 通信基础&quot;&gt;&lt;/a&gt;1 通信基础&lt;/h1&gt;&lt;p&gt;时延：是指数据（一个报文或者分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，网络中的时延由以下几个不同部分组成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传输时延=发送时延：发送数据时，数据块从结点进入到传输媒体所需要的时间&lt;/li&gt;
&lt;li&gt;传播时延：电磁波在信道中需要传播一定的距离而花费的时间&lt;/li&gt;
&lt;li&gt;处理时延：交换结点为储存转发而进行一些必要的处理所花费的时间&lt;/li&gt;
&lt;li&gt;排序时延：结点缓存队列中分组排序所经历的时延&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/DDD4CD39869743DE8A80130BC9D21D21?method=download&amp;shareKey=e60a924c7b234f947269dd2c1f6e99e1&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode学习笔记</title>
    <link href="https://liangggggg.github.io/2020/08/11/leetcode/"/>
    <id>https://liangggggg.github.io/2020/08/11/leetcode/</id>
    <published>2020-08-11T07:47:42.000Z</published>
    <updated>2020-09-04T04:27:14.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组与矩阵"><a href="#1-数组与矩阵" class="headerlink" title="1 数组与矩阵"></a>1 数组与矩阵</h1><h2 id="Problem-1-数组中重复的数字"><a href="#Problem-1-数组中重复的数字" class="headerlink" title="Problem 1 数组中重复的数字"></a>Problem 1 数组中重复的数字</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="方法一：-先排序，然后看相邻元素是否有相同的，直接return-时间O-nlogn-，空间O-1"><a href="#方法一：-先排序，然后看相邻元素是否有相同的，直接return-时间O-nlogn-，空间O-1" class="headerlink" title="方法一： 先排序，然后看相邻元素是否有相同的，直接return,时间O(nlogn)，空间O(1)"></a>方法一： 先排序，然后看相邻元素是否有相同的，直接return,时间O(nlogn)，空间O(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findRepeatNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        pre &#x3D; nums[0]</span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        for index in range(1,n):</span><br><span class="line">            if pre &#x3D;&#x3D; nums[index]:</span><br><span class="line">                return pre</span><br><span class="line">            pre &#x3D; nums[index]</span><br></pre></td></tr></table></figure><h3 id="方法二：使用哈希表，时间O-n-，空间O-n"><a href="#方法二：使用哈希表，时间O-n-，空间O-n" class="headerlink" title="方法二：使用哈希表，时间O(n)，空间O(n)"></a>方法二：使用哈希表，时间O(n)，空间O(n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findRepeatNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        repeatDict &#x3D; &#123;&#125;</span><br><span class="line">        for num in nums:</span><br><span class="line">            if num not in repeatDict:</span><br><span class="line">                repeatDict[num] &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                return num</span><br></pre></td></tr></table></figure><h2 id="Problem-2-二维数组中的查找"><a href="#Problem-2-二维数组中的查找" class="headerlink" title="Problem 2 二维数组中的查找"></a>Problem 2 二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 20，返回 false</span><br></pre></td></tr></table></figure><h3 id="方法一：-利用矩阵特点引入标志数"><a href="#方法一：-利用矩阵特点引入标志数" class="headerlink" title="方法一： 利用矩阵特点引入标志数"></a>方法一： 利用矩阵特点引入标志数</h3><ol><li>若flag&gt;target，则target一定在flag所在行的上方，即flag所在行可被消除</li><li>若flag&lt;target, 则target一定在flag所在列的右方，即flag所在列可被消除</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool:</span><br><span class="line">        i, j &#x3D; len(matrix) - 1, 0</span><br><span class="line">        while i &gt;&#x3D; 0 and j &lt; len(matrix[0]):</span><br><span class="line">            if matrix[i][j] &gt; target: i -&#x3D; 1</span><br><span class="line">            elif matrix[i][j] &lt; target: j +&#x3D; 1</span><br><span class="line">            else: return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="Problem-3-删除排序数组中的重复项"><a href="#Problem-3-删除排序数组中的重复项" class="headerlink" title="Problem 3 删除排序数组中的重复项"></a>Problem 3 删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素</span><br></pre></td></tr></table></figure><h3 id="方法一：使用双指针"><a href="#方法一：使用双指针" class="headerlink" title="方法一：使用双指针"></a>方法一：使用双指针</h3><ol><li>慢指针i从0开始,快指针j从1开始，两个指针每次移动一步</li><li>当指针i与j所指数字不同时，i后移一步，把j的值复制给i，j后移一步</li><li>当i与j所指数字相同，i不动，j后移一步</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        j &#x3D; 1</span><br><span class="line">        while j &lt; len(nums):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; nums[j]:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                nums[i]&#x3D;nums[j]</span><br><span class="line">        return i+1</span><br></pre></td></tr></table></figure><h2 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem 4"></a>Problem 4</h2><h3 id="方法一：每一天做一次清算"><a href="#方法一：每一天做一次清算" class="headerlink" title="方法一：每一天做一次清算"></a>方法一：每一天做一次清算</h3><ol><li>设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1] ；</li><li>当该天利润为正 tmp &gt; 0，则将利润加入总利润 profit；当利润为 00 或为负，则直接跳过；</li><li>遍历完成后，返回总利润 profit。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices: List[int]) -&gt; int:</span><br><span class="line">        profit &#x3D; 0</span><br><span class="line">        for i in range(1,len(prices)):</span><br><span class="line">            if prices[i] &gt; prices[i-1]:</span><br><span class="line">                profit +&#x3D; prices[i] - prices[i-1]</span><br><span class="line">        return profit</span><br></pre></td></tr></table></figure><h2 id="Problem-5"><a href="#Problem-5" class="headerlink" title="Problem 5"></a>Problem 5</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="方法一：-数组移动使用三次反转"><a href="#方法一：-数组移动使用三次反转" class="headerlink" title="方法一： 数组移动使用三次反转"></a>方法一： 数组移动使用三次反转</h3><p>三次反转</p><p>对于[1,2,3,4,5,6,7]，根据k = k%n，数组分为两段：</p><ul><li>第一段，对应数组下标[0,n-k-1],即[1,2,3,4]</li><li>第二段，对应数组下标[n-k, n-1],即[5,6,7]</li></ul><p>分为三步:</p><ol><li>反转第一段[4,3,2,1,5,6,7]</li><li>反转第二段[4,3,2,1,7,6,5]</li><li>反转整体[5,6,7,1,2,3,4]</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        k&#x3D;k%n</span><br><span class="line">        def swap(l,r):</span><br><span class="line">            while(l&lt;r):</span><br><span class="line">                nums[l],nums[r]&#x3D;nums[r],nums[l]</span><br><span class="line">                l&#x3D;l+1</span><br><span class="line">                r&#x3D;r-1</span><br><span class="line">        swap(0,n-k-1)</span><br><span class="line">        swap(n-k,n-1)</span><br><span class="line">        swap(0,n-1)</span><br></pre></td></tr></table></figure><h2 id="Problem-6-只出现一次的数字"><a href="#Problem-6-只出现一次的数字" class="headerlink" title="Problem 6 只出现一次的数字"></a>Problem 6 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><h3 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p>使用异或的性质</p><ol><li>任何数和本身异或则为0</li><li>任何数和0异或是本身</li><li>异或运算满足交换律</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        single_number &#x3D; 0</span><br><span class="line">        for num in nums:</span><br><span class="line">            single_number ^&#x3D; num</span><br><span class="line">        return single_number</span><br></pre></td></tr></table></figure><h2 id="Problem-7-两个数组的交集-II"><a href="#Problem-7-两个数组的交集-II" class="headerlink" title="Problem 7 两个数组的交集 II"></a>Problem 7 两个数组的交集 II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><h3 id="方法一：-哈希表"><a href="#方法一：-哈希表" class="headerlink" title="方法一： 哈希表"></a>方法一： 哈希表</h3><ul><li>collections.Counter()利用哈希表对元素进行计数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        num1 &#x3D; collections.Counter(nums1)</span><br><span class="line">        num2 &#x3D; collections.Counter(nums2)</span><br><span class="line"># 取与计算交集，返还哈希表字典元素</span><br><span class="line">        num &#x3D; num1 &amp; num2</span><br><span class="line">        return num.elements()</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h3><p>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</p><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p><p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line"></span><br><span class="line">        length1, length2 &#x3D; len(nums1), len(nums2)</span><br><span class="line">        intersection &#x3D; list()</span><br><span class="line">        index1 &#x3D; index2 &#x3D; 0</span><br><span class="line">        while index1 &lt; length1 and index2 &lt; length2:</span><br><span class="line">            if nums1[index1] &lt; nums2[index2]:</span><br><span class="line">                index1 +&#x3D; 1</span><br><span class="line">            elif nums1[index1] &gt; nums2[index2]:</span><br><span class="line">                index2 +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                intersection.append(nums1[index1])</span><br><span class="line">                index1 +&#x3D; 1</span><br><span class="line">                index2 +&#x3D; 1</span><br><span class="line">        </span><br><span class="line">        return intersection</span><br></pre></td></tr></table></figure><h2 id="Problem-8-加一"><a href="#Problem-8-加一" class="headerlink" title="Problem 8 加一"></a>Problem 8 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><h3 id="方法一：从后往前依次判断末尾是否为9-如果是-则去除："><a href="#方法一：从后往前依次判断末尾是否为9-如果是-则去除：" class="headerlink" title="方法一：从后往前依次判断末尾是否为9 如果是 则去除："></a>方法一：从后往前依次判断末尾是否为9 如果是 则去除：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        newlst &#x3D; []</span><br><span class="line">        while digits and digits[-1] &#x3D;&#x3D; 9:</span><br><span class="line">            digits.pop()</span><br><span class="line">            newlst.append(0)</span><br><span class="line">        if not digits:</span><br><span class="line">            return [1] + newlst</span><br><span class="line">        else:</span><br><span class="line">            digits[-1] +&#x3D; 1</span><br><span class="line">            return digits + newlst</span><br></pre></td></tr></table></figure><h3 id="方法二：先将数字列表转化为数字，然后-1-再转化为数组"><a href="#方法二：先将数字列表转化为数字，然后-1-再转化为数组" class="headerlink" title="方法二：先将数字列表转化为数字，然后+1,再转化为数组"></a>方法二：先将数字列表转化为数字，然后+1,再转化为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        a &#x3D; [i *10**index for index,i in enumerate(digits[::-1])]</span><br><span class="line">        num &#x3D; sum(a) + 1</span><br><span class="line">        return [int(x) for x in str(num)]</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-9-移动零"><a href="#Problem-9-移动零" class="headerlink" title="Problem 9 移动零"></a>Problem 9 移动零</h2><h3 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h3><p>参照快速排序的思想，用0当做中间点，把不等于0的放到中间点的左边，等于零0的放到其右边</p><p>使用两个指针$i,j$，只要$nums[i]!=0$就交换$nums[i]$和$nums[j]$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 找到第一个0</span><br><span class="line">        for i in range(0,len(nums)):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; 0:</span><br><span class="line">                break</span><br><span class="line">        for j in range(i+1,len(nums)):</span><br><span class="line">            if nums[j] !&#x3D; 0:</span><br><span class="line">                temp &#x3D; nums[i]</span><br><span class="line">                nums[i] &#x3D; nums[j]</span><br><span class="line">                nums[j] &#x3D; temp</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure><h2 id="Problem-10-有效的数独"><a href="#Problem-10-有效的数独" class="headerlink" title="Problem 10 有效的数独"></a>Problem 10 有效的数独</h2><h3 id="方法一：哈希表一次迭代完成"><a href="#方法一：哈希表一次迭代完成" class="headerlink" title="方法一：哈希表一次迭代完成"></a>方法一：哈希表一次迭代完成</h3><p>通过三个哈希表映射记录 行/列/子数独出现的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValidSudoku(self, board):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # init data</span><br><span class="line">        rows &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line">        columns &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line">        boxes &#x3D; [&#123;&#125; for i in range(9)]</span><br><span class="line"></span><br><span class="line">        # validate a board</span><br><span class="line">        for i in range(9):</span><br><span class="line">            for j in range(9):</span><br><span class="line">                num &#x3D; board[i][j]</span><br><span class="line">                if num !&#x3D; &#39;.&#39;:</span><br><span class="line">                    num &#x3D; int(num)</span><br><span class="line">                    box_index &#x3D; (i &#x2F;&#x2F; 3 ) * 3 + j &#x2F;&#x2F; 3</span><br><span class="line">                    </span><br><span class="line">                    # keep the current cell value</span><br><span class="line">                    rows[i][num] &#x3D; rows[i].get(num, 0) + 1</span><br><span class="line">                    columns[j][num] &#x3D; columns[j].get(num, 0) + 1</span><br><span class="line">                    boxes[box_index][num] &#x3D; boxes[box_index].get(num, 0) + 1</span><br><span class="line">                    </span><br><span class="line">                    # check if this value has been already seen before</span><br><span class="line">                    if rows[i][num] &gt; 1 or columns[j][num] &gt; 1 or boxes[box_index][num] &gt; 1:</span><br><span class="line">                        return False         </span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h2 id="Problem-11"><a href="#Problem-11" class="headerlink" title="Problem 11"></a>Problem 11</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="方法一：-转置加翻转"><a href="#方法一：-转置加翻转" class="headerlink" title="方法一： 转置加翻转"></a>方法一： 转置加翻转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :rtype: void Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n &#x3D; len(matrix[0])        </span><br><span class="line">        # transpose matrix</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i, n):</span><br><span class="line">                matrix[j][i], matrix[i][j] &#x3D; matrix[i][j], matrix[j][i] </span><br><span class="line">        </span><br><span class="line">        # reverse each row</span><br><span class="line">        for i in range(n):</span><br><span class="line">            matrix[i].reverse()</span><br></pre></td></tr></table></figure><hr><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h1><h2 id="Problem-1-字符串转换整数-atoi"><a href="#Problem-1-字符串转换整数-atoi" class="headerlink" title="Problem 1 字符串转换整数 (atoi)"></a>Problem 1 字符串转换整数 (atoi)</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</li></ul><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><h3 id="方法一：普通使用字符串转换写法"><a href="#方法一：普通使用字符串转换写法" class="headerlink" title="方法一：普通使用字符串转换写法"></a>方法一：普通使用字符串转换写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s: str) -&gt; int:</span><br><span class="line">        s &#x3D; s.strip(&#39; &#39;)</span><br><span class="line">        string &#x3D; &#39;0&#39;</span><br><span class="line">        if len(s) &gt; 0:</span><br><span class="line">            if s[0] &#x3D;&#x3D; &#39;-&#39; or s[0].isdigit() or s[0] &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">                string &#x3D; s[0]</span><br><span class="line">                if s[0] &#x3D;&#x3D; &#39;+&#39; or s[0] &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">                    string +&#x3D; &#39;0&#39;</span><br><span class="line">                for c in range(1,len(s)):</span><br><span class="line">                    if s[c].isdigit():</span><br><span class="line">                        string +&#x3D; s[c]</span><br><span class="line">                    else:</span><br><span class="line">                        break</span><br><span class="line">        num &#x3D; int(string)</span><br><span class="line">        if num &lt; -2**31:</span><br><span class="line">            return -2**31</span><br><span class="line">        elif num &gt; 2**31-1:</span><br><span class="line">            return 2**31-1</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure><h3 id="方法二：利用Python正则化"><a href="#方法二：利用Python正则化" class="headerlink" title="方法二：利用Python正则化"></a>方法二：利用Python正则化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s: str) -&gt; int:</span><br><span class="line">        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;, s.lstrip())), 2**31 - 1), -2**31)</span><br></pre></td></tr></table></figure><p>^：匹配字符串开头<br>[+-]：代表一个+字符或-字符<br>?：前面一个字符可有可无<br>\d：一个数字<br>+：前面一个字符的一个或多个<br>\D：一个非数字字符<br>*：前面一个字符的0个或多个</p><hr><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3 链表"></a>3 链表</h1><h2 id="Problem-1-删除链表的倒数第N个节点"><a href="#Problem-1-删除链表的倒数第N个节点" class="headerlink" title="Problem  1 删除链表的倒数第N个节点"></a>Problem  1 删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>对于链表类题目，对某一个特定索引的元素进行操作往往会成为增加运算时间的瓶颈，因此如何通过尽可能少的遍历次数寻找到所要操作的元素就成为关键。</p><h3 id="方法一：-双指针"><a href="#方法一：-双指针" class="headerlink" title="方法一： 双指针"></a>方法一： 双指针</h3><p>为了方便，我们在原有链表前面设置一个哑结点，哑结点的好处在于，因为这里我们是要删除一个结点，所以我们可以定位到被删除结点的前置结点，然后将前置结点的后续指针指向被删除结点的后续结点，则可完成删除。</p><p>我们设置两个指针，两个指针初始状态都指向哑结点，指针fast 先走n步，然后指针fast和指针slow同步往前继续遍历链表，直至fast的后续结点为空，此时指针slow到达被删除结点的前置结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode:</span><br><span class="line">def __init__(self, x):</span><br><span class="line">self.val &#x3D; x</span><br><span class="line">self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">if not head:</span><br><span class="line">return head</span><br><span class="line">slownode &#x3D; ListNode(None)</span><br><span class="line">slownode.next &#x3D; head</span><br><span class="line">fastnode &#x3D; slownode</span><br><span class="line">for i in range(n):</span><br><span class="line">fastnode &#x3D; fastnode.next</span><br><span class="line">while(fastnode.next!&#x3D;None):</span><br><span class="line">slownode &#x3D; slownode.next</span><br><span class="line">fastnode &#x3D; fastnode.next</span><br><span class="line">if slownode.next &#x3D;&#x3D; head:</span><br><span class="line">head &#x3D; head.next</span><br><span class="line">else:</span><br><span class="line">slownode.next &#x3D; slownode.next.next</span><br><span class="line">return head</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>先通过head.next = self.removeNthFromEnd(head.next,n)，找到base case也就是if head is None时，设i=0.<br>然后通过递归慢慢向前并每次加一，找到倒数第n个节点，并且返回这个要删除节点的next。<br>如果i!=n，也就是这个节点要保留，返回这个节点（通过.next也包括了他后面的那些节点）。<br>返回节点时会通过head.next = self.removeNthFromEnd(head.next,n)把每次返回的节点接到head.next上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        global i </span><br><span class="line">        if head is None:</span><br><span class="line">            i&#x3D;0</span><br><span class="line">            return None</span><br><span class="line">        head.next &#x3D; self.removeNthFromEnd(head.next,n)</span><br><span class="line">        i+&#x3D;1</span><br><span class="line">        return head.next if i&#x3D;&#x3D;n else head</span><br></pre></td></tr></table></figure><h2 id="Problem-2-翻转链表"><a href="#Problem-2-翻转链表" class="headerlink" title="Problem 2  翻转链表"></a>Problem 2  翻转链表</h2><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="方法一：双指针法"><a href="#方法一：双指针法" class="headerlink" title="方法一：双指针法"></a>方法一：双指针法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        cur &#x3D; head</span><br><span class="line">        while cur:</span><br><span class="line">            temp &#x3D; cur.next   # 先把原来cur.next位置存起来</span><br><span class="line">            cur.next &#x3D; pre</span><br><span class="line">            pre &#x3D; cur</span><br><span class="line">            cur &#x3D; temp</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure><h3 id="方法二：递归-1"><a href="#方法二：递归-1" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        ## 递归</span><br><span class="line">        if not (head and head.next):</span><br><span class="line">            return head</span><br><span class="line">        </span><br><span class="line">        newHead &#x3D; self.reverseList(head.next)</span><br><span class="line">        </span><br><span class="line">        head.next.next &#x3D; head</span><br><span class="line">        head.next &#x3D; None</span><br><span class="line">        return newHead</span><br></pre></td></tr></table></figure><h2 id="Problem-3-合并两个有序链表"><a href="#Problem-3-合并两个有序链表" class="headerlink" title="Problem 3 合并两个有序链表"></a>Problem 3 合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="方法一：-递归"><a href="#方法一：-递归" class="headerlink" title="方法一： 递归"></a>方法一： 递归</h3><p>当我们使用递归方法解题时，主要思考两个关键</p><ul><li>递归的中值条件</li><li>递归不断调用自身，直到遇到终止条件后进行回溯，最终返回答案</li></ul><p>所以根据以上考虑本题</p><ul><li>终止条件： 当两个链表都为空时，表示我们对链表已合并完成</li><li>如何递归： 判断l1,l2头结点哪个更小，然后较小结点next指针指向其余结点的合并结果（调用递归）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1: return l2  # 终止条件，直到两个链表都空</span><br><span class="line">        if not l2: return l1</span><br><span class="line">        if l1.val &lt;&#x3D; l2.val:  # 递归调用</span><br><span class="line">            l1.next &#x3D; self.mergeTwoLists(l1.next,l2)</span><br><span class="line">            return l1</span><br><span class="line">        else:</span><br><span class="line">            l2.next &#x3D; self.mergeTwoLists(l1,l2.next)</span><br><span class="line">            return l2</span><br></pre></td></tr></table></figure><h3 id="方法二：-双指针"><a href="#方法二：-双指针" class="headerlink" title="方法二： 双指针"></a>方法二： 双指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        phead &#x3D; ListNode(0)</span><br><span class="line">        dummy &#x3D; phead</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt;&#x3D; l2.val:</span><br><span class="line">                dummy.next &#x3D; l1</span><br><span class="line">                dummy &#x3D; dummy.next</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            else:</span><br><span class="line">                dummy.next &#x3D; l2</span><br><span class="line">                dummy &#x3D; dummy.next</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">        if l1:</span><br><span class="line">            dummy.next &#x3D; l1</span><br><span class="line">        if l2:</span><br><span class="line">            dummy.next &#x3D; l2</span><br><span class="line">        return phead.next</span><br></pre></td></tr></table></figure><h1 id="4-树"><a href="#4-树" class="headerlink" title="4 树"></a>4 树</h1><h2 id="Problem-1-重建二叉树"><a href="#Problem-1-重建二叉树" class="headerlink" title="Problem 1 : 重建二叉树"></a>Problem 1 : 重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回二叉树如下：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        if len(inorder) &#x3D;&#x3D; 0:</span><br><span class="line">            return None</span><br><span class="line">        </span><br><span class="line">        # 根节点</span><br><span class="line">        root &#x3D; TreeNode(preorder[0])</span><br><span class="line">        # 获取根节点在 inorder 中的索引</span><br><span class="line">        idx &#x3D; inorder.index(preorder[0])</span><br><span class="line">        # 左子树</span><br><span class="line">        root.left &#x3D; self.buildTree(preorder[1:idx+1], inorder[:idx])</span><br><span class="line">        # 右子树</span><br><span class="line">        root.right &#x3D; self.buildTree(preorder[idx+1:], inorder[idx+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure><hr><h1 id="5-DFS深度优先搜索-BFS广度优秀搜索"><a href="#5-DFS深度优先搜索-BFS广度优秀搜索" class="headerlink" title="5 DFS深度优先搜索/BFS广度优秀搜索"></a>5 DFS深度优先搜索/BFS广度优秀搜索</h1><h2 id="Problem-1：矩阵中的路径"><a href="#Problem-1：矩阵中的路径" class="headerlink" title="Problem 1：矩阵中的路径"></a>Problem 1：矩阵中的路径</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="方法：DFS-剪枝"><a href="#方法：DFS-剪枝" class="headerlink" title="方法：DFS+剪枝"></a>方法：DFS+剪枝</h3><p><strong>思想</strong></p><ul><li>深度优先搜索：可理解为暴力遍历矩阵所有字符串可能性，DFS通过递归，先朝一个方向搜索到第，再回溯至上各结点，沿另一个方向搜索，以此类推</li><li>剪枝：在搜索中，如果这条路不可能和目标字符串匹配成功，则立即返回</li></ul><p><strong>细节</strong></p><ul><li><p>递归参数：当前元素在矩阵board中的行列索引i,j和当前目标字符在word中的索引</p></li><li><p>终止条件：</p><ol><li>返回false：行列越界/当前矩阵元素与目标字符不同/当前元素已访问过</li><li>返回true：字符串已经全部匹配</li></ol></li><li><p>递推工作：</p><ol><li>标记当前矩阵元素，将board[i][j]暂存为tmp，并修改为’0’，代表已访问过，防止之后搜索时重复访问</li><li>搜索下一单元格：朝当前元素的上、下、左、右四个方向开启下层递归，使用或链接，并记录结果至res</li><li>还原当前矩阵元素：将tmp的值还原至board[i][j]元素</li></ol></li><li><p>回溯返回值：返回res，代表是否搜索到目标字符串</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def exist(self, board: List[List[str]], word: str) -&gt; bool:</span><br><span class="line">        # 使用深度优先搜索</span><br><span class="line">        if not board:   # 边界条件</span><br><span class="line">            return False</span><br><span class="line">        for i in range(len(board)):</span><br><span class="line">            for j in range(len(board[0])):</span><br><span class="line">                if self.dfs(board, i, j, word):</span><br><span class="line">                    return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def dfs(self, board, i, j, word):</span><br><span class="line">        if len(word) &#x3D;&#x3D; 0: # 如果单词已经检查完毕</span><br><span class="line">            return True</span><br><span class="line">        if i &lt; 0 or i &gt;&#x3D; len(board) or j &lt; 0 or j &gt;&#x3D; len(board[0]) or word[0] !&#x3D; board[i][j]:  # 如果路径出界或者矩阵中的值不是word的首字母，返回False</span><br><span class="line">            return False</span><br><span class="line">        tmp &#x3D; board[i][j]  # 如果找到了第一个字母，检查剩余的部分</span><br><span class="line">        board[i][j] &#x3D; &#39;0&#39;</span><br><span class="line">        res &#x3D; self.dfs(board,i+1,j,word[1:]) or self.dfs(board,i-1,j,word[1:]) or self.dfs(board,i,j+1,word[1:]) or self.dfs(board, i, j-1, word[1:]) # 上下左右四个方向搜索</span><br><span class="line"></span><br><span class="line">        board[i][j] &#x3D; tmp</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h2 id="Problem-2：机器人的运动范围"><a href="#Problem-2：机器人的运动范围" class="headerlink" title="Problem 2：机器人的运动范围"></a>Problem 2：机器人的运动范围</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="方法一：DFS深度优先搜索"><a href="#方法一：DFS深度优先搜索" class="headerlink" title="方法一：DFS深度优先搜索"></a>方法一：DFS深度优先搜索</h3><ul><li>深度优先搜索：由于题目要求从（0，0）出发，因此任何一个点都可以只通过向右和向下两个动作达到，因此只考虑两个方向即可</li><li>剪枝：在搜索中，遇到位数和超出目标值、此元素已访问，或走到方格边界，则返回</li></ul><p><strong>细节</strong></p><ul><li>递归参数：当前元素在矩阵中的行列索引i,j</li><li>终止条件：1.行列索引越界 2.数位和超出目标值 3.当前元素已经访问。则返回</li><li>递推工作：1. 标记当前单元格，存入set中，2.搜索下一单元格</li><li>回溯返回值：set的长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">        def get_sum(x,y):</span><br><span class="line">            result &#x3D; 0</span><br><span class="line">            while x:</span><br><span class="line">                result  +&#x3D;x%10</span><br><span class="line">                x &#x3D; x &#x2F;&#x2F; 10</span><br><span class="line">            while y :</span><br><span class="line">                result +&#x3D;y%10</span><br><span class="line">                y &#x3D; y&#x2F;&#x2F;10</span><br><span class="line">            return result</span><br><span class="line">        </span><br><span class="line">        def DFS(i,j):</span><br><span class="line">            if i &#x3D;&#x3D; m or j &#x3D;&#x3D; n or get_sum(i,j)&gt;k or (i,j) in mark:</span><br><span class="line">                return</span><br><span class="line">            mark.add((i,j))</span><br><span class="line">            DFS(i+1,j)</span><br><span class="line">            DFS(i,j+1)</span><br><span class="line">        mark&#x3D;set()</span><br><span class="line">        DFS(0,0)</span><br><span class="line">        return len(mark)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-数组与矩阵&quot;&gt;&lt;a href=&quot;#1-数组与矩阵&quot; class=&quot;headerlink&quot; title=&quot;1 数组与矩阵&quot;&gt;&lt;/a&gt;1 数组与矩阵&lt;/h1&gt;&lt;h2 id=&quot;Problem-1-数组中重复的数字&quot;&gt;&lt;a href=&quot;#Problem-1-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;Problem 1 数组中重复的数字&quot;&gt;&lt;/a&gt;Problem 1 数组中重复的数字&lt;/h2&gt;&lt;p&gt;找出数组中重复的数字。&lt;/p&gt;
&lt;p&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 1, 0, 2, 5, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2 或 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://liangggggg.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://liangggggg.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（一）：线性表</title>
    <link href="https://liangggggg.github.io/2020/08/11/Data/"/>
    <id>https://liangggggg.github.io/2020/08/11/Data/</id>
    <published>2020-08-11T01:47:42.000Z</published>
    <updated>2020-08-26T12:56:38.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h1><h2 id="1-1-线性表的定义和基本操作"><a href="#1-1-线性表的定义和基本操作" class="headerlink" title="1.1 线性表的定义和基本操作"></a>1.1 线性表的定义和基本操作</h2><p>1.线性结构的特点是：在数据元素的非空有限集中</p><ul><li>存在唯一的一个被称作“第一个”的数据元素</li><li>存在唯一一个被称作“最后一个”的数据元素</li><li>除第一个之外，集合中的每个元素均只有一个前驱</li><li>除最后一个之外，集合中每个元素均只有一个后继</li></ul><p>2.线性表示一种线性结构，在一个线性表中数据元素的类型是相同的，长度可以根据需要增长或缩短</p><a id="more"></a><h2 id="1-2-线性表的实现"><a href="#1-2-线性表的实现" class="headerlink" title="1.2 线性表的实现"></a>1.2 线性表的实现</h2><h3 id="1-2-1-顺序存储"><a href="#1-2-1-顺序存储" class="headerlink" title="1.2.1 顺序存储"></a>1.2.1 顺序存储</h3><p>1.顺序表的定义<br>线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素</p><p><img src="https://note.youdao.com/yws/api/personal/file/96E6535559A647A3B6F63C3AE1535948?method=download&shareKey=7b053e18c9fb7504affa8b8851745fd7" alt></p><p>2.顺序表上基本运算的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; - -一一一线性表的动态分配顺序存储结构一一</span><br><span class="line">define LIST_INIT_SIZE 100 &#x2F;&#x2F;线性表存储空间的初始分量</span><br><span class="line"></span><br><span class="line">define LISTINCREMNT 10 &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line"></span><br><span class="line">1）静态结构：表一旦装满，不能扩充</span><br><span class="line">define MAX_SIZE 100</span><br><span class="line">typdef int Status;</span><br><span class="line">typdef int ElemType;</span><br><span class="line">typdef struct sqlist</span><br><span class="line">&#123;</span><br><span class="line">ElemType Elem_array[Max_SIZE];</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">2) 动态结构，可以扩充，新的大小计入数据成员maxSize中</span><br><span class="line">typedef struct sqlist&#123;</span><br><span class="line">ElempType *elem; &#x2F;&#x2F;存储数组int length</span><br><span class="line">int length &#x2F;&#x2F;当前表元素个数</span><br><span class="line">int maxSize; &#x2F;&#x2F;表的最大长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>(1)顺序表的初始化</p><p>将L设为引用参数，首先动态分配存储空间，然后将length置为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status Init_SqList(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;elem &#x3D; (ElemType *)malloc(MAX_SIZE*sizeof(ElemType));</span><br><span class="line">if (!L-&gt;elem)</span><br><span class="line">return ERROR;</span><br><span class="line">else&#123;</span><br><span class="line">L-&gt;length &#x3D; 0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)插入运算</p><p>在第i个位置上插入x，从$a_i-a_n$都要向下移动一个位置，共需要移动$n-i+1$个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status Insert_SqList(Sqlist *L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">if (i&lt;0 || i-&gt;L-&gt;length+1) return ERROR;</span><br><span class="line">if (L-&gt;length&gt;&#x3D;MAX_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">printf(“溢出！\n”);</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">for (j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; --j)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* i-1位置以后的所有结点往后移 *&#x2F;</span><br><span class="line">L-&gt;Elem_array[j+1]&#x3D;L-&gt;Elem_array[j];&#125;</span><br><span class="line">L-&gt;Elem_array[i-1] &#x3D; e;</span><br><span class="line">&#x2F;* 在i-1个位置插入*&#x2F;</span><br><span class="line">L-&gt;length++;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)删除运算</p><p>删除第i个元素，其后面的元素$a_{i+1}-a_n$都要向上移动，共移动了$n-i$个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ElemType Delete_SqList(Sqlist *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">int k;</span><br><span class="line">ElemTpye x;</span><br><span class="line">if (L-&gt;length&#x3D;&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">printf(“要删除的数据元素不存在!\n”);</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">x&#x3D;L-&gt;Elem_array[i-1]; # 保存结点的值</span><br><span class="line">for(k&#x3D;i; k &lt; L-&gt;length; k++)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;Elem_array[k-1]&#x3D;L-&gt;Elem_array[k]; # i位置以后的所有结点前移</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line">reutrn x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/A5E9B6356BA5483D8C339A5E599C9D35?method=download&shareKey=ffe88d5b4391046d95eebfc796a71a70" alt></p><p>3.顺序线性表的查找定位删除</p><p>在线性表$L=(a_1,a_2,\dots,a_n)$删除值为$x$的第一个节点</p><p>(1)在线性表L查找值为x的第一个数据元素</p><p>(2)将从找到的位置至最后一个结点依次向前移动一个位置</p><p>(3)线性表长度减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Status Locate_Delete_SqList(Sqlist *L, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">int i&#x3D;0,k;</span><br><span class="line">while(i&lt; L-&gt;length) # 查找值为x的第一个结点</span><br><span class="line">&#123;</span><br><span class="line">if(L-&gt;Elem_array[i]!&#x3D;x) i++;&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(k &#x3D; i+1; k&lt; L-&gt;length; k++) </span><br><span class="line">L-&gt;Elem_array[k-1]&#x3D;L-&gt;Elem_array[k];</span><br><span class="line">L-&gt;length--;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i&gt;L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;要删除的数据元素不存在！\n&quot;);</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.顺序表的合并问题</p><p>对于有序顺序表$L_a,L_b$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int MergeList(SqList La, SqList Lb, SqList *Lc)</span><br><span class="line">&#123;</span><br><span class="line">Lc-&gt;listsize &#x3D; Lc.length &#x3D; La.lenth + Lb.length;</span><br><span class="line">Pc &#x3D; Lc-&gt;elem &#x3D; (ElemType *)malloc(Lc.listsize * sizeof(ElemType));</span><br><span class="line">if(!Lc.elem) exit(overflow);</span><br><span class="line">pa_last &#x3D; La.elem + La.length-1;</span><br><span class="line">pb_last &#x3D; Lb.elem + Lb.length-1;</span><br><span class="line">while(pa&lt;&#x3D;pa_last &amp;&amp; pb &lt;&#x3D; pb_last)&#123;</span><br><span class="line">if(*pa&lt;&#x3D;*pb)</span><br><span class="line">*pc++&#x3D;*pa++;</span><br><span class="line">else</span><br><span class="line">*pc++&#x3D;*pb++;</span><br><span class="line">&#125;</span><br><span class="line">while(pa&lt;pa_last) *pc++&#x3D;*pa++;</span><br><span class="line">while(pb&lt;&#x3D;pb_last) *pc++&#x3D;*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-链式存储"><a href="#1-2-2-链式存储" class="headerlink" title="1.2.2 链式存储"></a>1.2.2 链式存储</h3><p>1.单链表</p><p>线性表的链式存储结构特点是用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以使不连续的）</p><p>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode* next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>2.单链表基本运算实现</p><p>（1）建立单链表</p><ul><li>头插法————在链表的头部插入节点建立单链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LNode *create_LinkList(void) # 头插法创建单链表，头结点head作为返回值</span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">LNode *head, *p;</span><br><span class="line">head &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">head-&gt;next &#x3D; NULL # 创建链表的头结点head</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">if(data&#x3D;&#x3D;327667) break;</span><br><span class="line">p&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">p-&gt;data &#x3D; data; # 数据域赋值</span><br><span class="line">p-&gt;next &#x3D; head-&gt;next;</span><br><span class="line">head-&gt;next &#x3D; p; # 钩链，新创建的结点总是作为第一个结点</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/8849B8BB9FE946FC8CC970D8022939A1?method=download&shareKey=e854f232f11469e6c244f77d5f73ab42" alt></p><ul><li>尾插法————头插法虽然简单但是读入的数据元素顺序与生成的链表中元素是相反的，为了次序一致，可以使用尾插法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LNode *create_LinkList(void) # 尾插法创建单链表，头结点head作为返回值</span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">LNode *head, *last, *q;</span><br><span class="line">head &#x3D; p &#x3D; (LNode *)malloc(sizeof(LNode))</span><br><span class="line">p-&gt;next&#x3D;NULL # 创建单链表的头结点head</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;data);</span><br><span class="line">if(data&#x3D;&#x3D;32767) break;</span><br><span class="line">q &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">q-&gt;data&#x3D;data # 数据域赋值</span><br><span class="line">q-&gt;next &#x3D; last-&gt;next;</span><br><span class="line">last-&gt;next&#x3D;q;</span><br><span class="line">last&#x3D;q; # 钩链，新创建的结点总是作为最后一个结点</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/A17A2DAD6A0B44F8B383E21B37DFBC81?method=download&shareKey=6b0d21c3a6ea6e2ed2387497e28ee6a0" alt></p><p>(2)查找操作</p><ul><li>按序号查找</li></ul><p>子单链表中，取得第1个数据元素必须从头指针出发寻找，因此单链表是非随机存取的存储结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ElemType Get_Elem(LNode *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">LNode *p;</span><br><span class="line">if(i&lt;1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;i太小\n&quot;);</span><br><span class="line">return;&#125;</span><br><span class="line">P&#x3D;L-&gt;next; j&#x3D;1 # 使P指向第一个结点</span><br><span class="line">while(P!&#x3D;NULL &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p&#x3D;p-&gt;next;</span><br><span class="line">j++;&#125; # 移动指针p，j计数</span><br><span class="line">if(p&#x3D;&#x3D;NULL)</span><br><span class="line">return -32768</span><br><span class="line">else</span><br><span class="line">return p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按值查找</li></ul><p>查找时从开始节点出发，沿链表逐个将节点的值和给定值key作比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LNode *Locate_Note(LNode *L, int key)</span><br><span class="line">&#123;</span><br><span class="line">LNode *p&#x3D;L-&gt;next;</span><br><span class="line">while(P!&#x3D;NULL &amp;&amp; p-&gt;data!&#x3D;key) p&#x3D;p-&gt;next;</span><br><span class="line">if(p-&gt;data&#x3D;&#x3D;key) return p;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;所要查找的结点不存在！\n&quot;);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）插入运算（后插法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Insert_LNode(LNode *L, int i, ElemType e)</span><br><span class="line">&#x2F;*在以 L 为头结点的单链表的第 i 个位置插入值为 e 的结点 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">int j&#x3D;0; LNode *p, *q;</span><br><span class="line">if(i&lt;1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;i太小\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">p&#x3D;L;</span><br><span class="line">while(P!&#x3D;NULL &amp;&amp; j&lt;i-1)</span><br><span class="line">&#123;</span><br><span class="line">p&#x3D;p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">if(P&#x3D;&#x3D;NULL) printf(&quot;i太大!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">q&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">q-&gt;data&#x3D;e;</span><br><span class="line">q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">p-&gt;next&#x3D;q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）删除运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Delete_LinkList(LNode *L, int i)</span><br><span class="line">&#x2F;*删除以 L 为头结点的单链表中的第 i 个结点*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">int j&#x3D;1; LNode *p,*q;</span><br><span class="line">if(i&lt;1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;i太小\n&quot;);</span><br><span class="line">return;&#125;</span><br><span class="line">p&#x3D;L; q&#x3D;L-&gt;next;</span><br><span class="line">while(q!&#x3D;NULL &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p&#x3D;q;</span><br><span class="line">q&#x3D;q-&gt;next;</span><br><span class="line">j++;&#125;</span><br><span class="line">if(p&#x3D;&#x3D;NULL) printf(&quot;i太大!\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">p-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">free(q);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.单链表的合并</p><p>若La,Lb两个链表的长度分别是m,n，则链表合并的时间复杂度为O(m+n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LNode *Merge_LinkList(LNode *La, LNode *Lb)</span><br><span class="line">&#x2F;*合并以 La，Lb 为头结点的两个有序单链表*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">LNode *Lc, *pa, *pb, *pc, *ptr;</span><br><span class="line">Lc &#x3D; La; pc &#x3D; La;</span><br><span class="line">pa&#x3D;La-&gt;next; pb&#x3D;Lb-&gt;next;</span><br><span class="line">while(pa!&#x3D;NULL &amp;&amp; pb!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">if(pa-&gt;data &lt; pb-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next&#x3D;pa;</span><br><span class="line">pc&#x3D;pa;</span><br><span class="line">pa&#x3D;pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if(pa-&gt;data &gt; pb-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next&#x3D;pb;</span><br><span class="line">pc&#x3D;pb;</span><br><span class="line">pb&#x3D;pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 如果两个值相等，将pa所指结点合并，pb所指结点删除*&#x2F;</span><br><span class="line">if(pa-&gt;data&#x3D;&#x3D;pb-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next&#x3D;pa;</span><br><span class="line">pc&#x3D;pa;</span><br><span class="line">pa&#x3D;pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(pa!&#x3D;NULL) pc-&gt;next&#x3D;pa;</span><br><span class="line">else pc-&gt;next&#x3D;pb;</span><br><span class="line">free(Lb);</span><br><span class="line">return Lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.循环链表</p><p>对于单链表，最后一个节点的指针域是空指针，如果将该链表投指针置入该指针域，则使得链表头尾节点相连，构成了单循环链表</p><p>对于单链表只能从头结点开始遍历整个链表，而对于单循环链表则可以从表中任意结点   开始遍历整个链表，不仅如此，有时对链表常做的操作是在表尾、表头进行，此时可以改变   一下链表的标识方法，不用头指针而用一个指向尾结点的指针 R 来标识，可以使得操作效率得以提高。</p><ol start="5"><li>双向链表</li></ol><table><thead><tr><th align="center">前驱指针域</th><th align="center">数据域</th><th align="center">后继指针域</th></tr></thead></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Dulnode</span><br><span class="line">&#123;ElemType data;</span><br><span class="line">struct Dulnode*prior, *next;</span><br><span class="line">&#125;DulNode;</span><br></pre></td></tr></table></figure><p>(1)双向链表的插入</p><ol><li>插入时仅仅指出直接前驱节点，钩链时必须注意先后次序是：“先右后左”</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S&#x3D;(DulNode *)malloc(sizeof(DulNode));</span><br><span class="line">S-&gt;data&#x3D;e;</span><br><span class="line">S-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior&#x3D;S;</span><br><span class="line">p-&gt;next&#x3D;S;</span><br><span class="line">S-&gt;prior&#x3D;p; # 操作次序非常需要</span><br></pre></td></tr></table></figure><ol start="2"><li>插入时同时指出直接前驱节点p和直接后继节点q，钩链时无需注意先后次序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S&#x3D;(DulNode *)malloc(sizeof(DulNode));</span><br><span class="line">S-&gt;data&#x3D;e;</span><br><span class="line">p-&gt;next&#x3D;S;</span><br><span class="line">S-&gt;next&#x3D;q;</span><br><span class="line">S-&gt;prior&#x3D;p;</span><br><span class="line">q-&gt;prior&#x3D;S;</span><br></pre></td></tr></table></figure><p>(2)双向链表中节点的删除</p><p><img src="https://note.youdao.com/yws/api/personal/file/9E3F091C1048407BA19F473010DBB842?method=download&shareKey=71f41f90b3a0d26a4b185941b04bd5d9" alt></p><p>删除时可以不引入新的辅助指针变量，可以直接先断链，再释放结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior&#x3D;p-&gt;prior; </span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure><p>注意：与单链表的插入和删除操作不同的是，在双向链表中插入和删除必须同时修改两个方向上的指针域的指向。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-线性表&quot;&gt;&lt;a href=&quot;#1-线性表&quot; class=&quot;headerlink&quot; title=&quot;1 线性表&quot;&gt;&lt;/a&gt;1 线性表&lt;/h1&gt;&lt;h2 id=&quot;1-1-线性表的定义和基本操作&quot;&gt;&lt;a href=&quot;#1-1-线性表的定义和基本操作&quot; class=&quot;headerlink&quot; title=&quot;1.1 线性表的定义和基本操作&quot;&gt;&lt;/a&gt;1.1 线性表的定义和基本操作&lt;/h2&gt;&lt;p&gt;1.线性结构的特点是：在数据元素的非空有限集中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在唯一的一个被称作“第一个”的数据元素&lt;/li&gt;
&lt;li&gt;存在唯一一个被称作“最后一个”的数据元素&lt;/li&gt;
&lt;li&gt;除第一个之外，集合中的每个元素均只有一个前驱&lt;/li&gt;
&lt;li&gt;除最后一个之外，集合中每个元素均只有一个后继&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.线性表示一种线性结构，在一个线性表中数据元素的类型是相同的，长度可以根据需要增长或缩短&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
