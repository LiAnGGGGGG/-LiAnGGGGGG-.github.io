<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiAnG&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liangggggg.github.io/"/>
  <updated>2020-09-23T08:36:10.912Z</updated>
  <id>https://liangggggg.github.io/</id>
  
  <author>
    <name>LiAnG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库总结笔记（一）：关系数据库</title>
    <link href="https://liangggggg.github.io/2020/09/16/DB1/"/>
    <id>https://liangggggg.github.io/2020/09/16/DB1/</id>
    <published>2020-09-16T02:20:59.000Z</published>
    <updated>2020-09-23T08:36:10.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-关系数据库常识"><a href="#1-关系数据库常识" class="headerlink" title="1 关系数据库常识"></a>1 关系数据库常识</h1><p>（一）关系代数</p><p>抽象的查询语言，它运算的对象是关系，运算产生的结果也是关系</p><ol><li>基于传统的集合运算（二目运算，包括并、差、交和笛卡尔积）</li><li>专门的关系运算（选择、投影、连接和除运算等）</li></ol><p>自然连接是一种特殊的等值连接。要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉</p><p>外连接是连接运算的扩展，可以用来处理缺失的信息，避免信息的丢失</p><a id="more"></a><h1 id="2-SQL概述"><a href="#2-SQL概述" class="headerlink" title="2 SQL概述"></a>2 SQL概述</h1><h2 id="2-1-数据定义语言"><a href="#2-1-数据定义语言" class="headerlink" title="2.1 数据定义语言"></a>2.1 数据定义语言</h2><p>（一）定义表</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt;(&lt;列名称&gt;&lt;数据类型&gt;[列级完整性约束][,&lt;列名称&gt;&lt;数据类型&gt;[列级完整性约束]...][,&lt;表级完整性约束&gt;]);</span><br></pre></td></tr></table></figure><p>完整性约束：</p><ol><li>Not NULL:不能为空</li><li>NULL：可以为空</li><li>Unique：不能有相同的</li><li>PRIMARY KEY:主码，不能为空</li><li>FOREIGN KEY : 外键，另一张表的主键</li></ol><p>（二）修改表</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;[ADD&lt;列名&gt;&lt;数据类型&gt;[列的完整性约束]]|[ADD&lt;表级完整性约束&gt;]</span><br><span class="line">[ALTER COLUMN&lt;列名&gt;&lt;新的数据类型&gt;]</span><br><span class="line">[DROP COLUMN&lt;列名&gt;]</span><br><span class="line">[DROP CONSTRAINT&lt;表级完整性约束名&gt;]</span><br></pre></td></tr></table></figure><p>（三）删除表</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE&lt;表名1&gt;[,&lt;表名2&gt;]；</span><br></pre></td></tr></table></figure><p>（四）建立索引</p><p>1.数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX&lt;索引名称&gt;</span><br><span class="line"></span><br><span class="line">ON&lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...);</span><br></pre></td></tr></table></figure><ol><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER:索引引项的顺序与关系中的记录的物理顺序一致的索引组织</li><li>次序：ASC（升序）、DESC(降序)，默认为ASC</li></ol><p>（五）删除索引</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX&lt;索引名称&gt;;</span><br></pre></td></tr></table></figure><h2 id="2-2-数据查询语言"><a href="#2-2-数据查询语言" class="headerlink" title="2.2 数据查询语言"></a>2.2 数据查询语言</h2><p>（一）语句基本形式</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]...</span><br><span class="line">FROM &lt;表名或试图名称&gt;[,&lt;表名或视图名称&gt;]...</span><br><span class="line">[WHERE &lt;条件表达式&gt;]</span><br><span class="line">[GROUP BY &lt;列名1&gt;[HAVING&lt;条件表达式&gt;]]</span><br><span class="line">[ORDER BY &lt;列名2&gt;[ASC|DESC]];</span><br></pre></td></tr></table></figure><ol><li>[ALL|DISTINCT]：默认为ALL，有重复元组，如果不希望有重复元组则选DISTINCT</li><li>HAVING：如果GROUP BY中带HAVING短语，则只有满足条件的组才会被输出</li></ol><p>（二）单表查询</p><p>单表查询是对一个表的查询，也可以称为单关系查询</p><p>1.查询指定的列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT StudentName, StudentAddress FROM Stuednt;</span><br></pre></td></tr></table></figure><p>2.查询全部的列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student;</span><br></pre></td></tr></table></figure><p>3.查询计算的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">COUNT([DISTINCT&#x2F;ALL]*)----统计元组的个数</span><br><span class="line">COUNT([DISTINCT&#x2F;ALL]&lt;列名&gt;)----统计结果中某列值的个数</span><br><span class="line">MAX(&lt;列名&gt;)----给出一列上的最大值</span><br><span class="line">MIN(&lt;列名&gt;)</span><br><span class="line">SUM([DISTINCT&#x2F;ALL]&lt;列名&gt;)</span><br><span class="line">SUM([DISTINCT&#x2F;ALL]&lt;列名&gt;)</span><br></pre></td></tr></table></figure><p>4.消除取值重复的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT StudentNumber FROM Grade;</span><br></pre></td></tr></table></figure><p>5.查询满足条件的元组</p><p>（SQL语言中&lt;&gt;代表不等于）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">查询所有男同学信息</span><br><span class="line">SELECT * FROM Student WHERE StudentSex&#x3D;&quot;男&quot;;</span><br><span class="line"></span><br><span class="line">查询成绩介于70到80分的学生</span><br><span class="line">SELECT * FROM Grade WHERE StudentGrade BETWEEN 70 AND 80;</span><br><span class="line"></span><br><span class="line">查询系别为01或02的学生姓名</span><br><span class="line">SELECT StudentName FROM Student</span><br><span class="line">WHERE StudentDept IN(&quot;01&quot;,&quot;02&quot;);</span><br><span class="line"></span><br><span class="line">字符匹配查询(汉子占两个字节)</span><br><span class="line">[NOT] LIKE ‘&lt;匹配串&gt;’[ESCAPE ‘&lt;换码字符&gt;’]</span><br><span class="line">其中匹配串可以使一个完整的字符串也可以含有通配符&quot;-&quot;或&quot;%&quot;</span><br><span class="line"></span><br><span class="line">在Student表中，查询姓沙的信息</span><br><span class="line">SELECT * FROM Student WHERE StudentName LIKE &#39;沙%&#39;;</span><br><span class="line"></span><br><span class="line">查询系别01，并且性别为男的学生记录</span><br><span class="line">SELECT *FROM Student</span><br><span class="line">WHRER StudentSex&#x3D;&quot;男&quot; AND StudentDept &#x3D; 01</span><br><span class="line"></span><br><span class="line">按成绩降序排列</span><br><span class="line">SELECT *FROM Grade ORDER BY StudentGrade DESC</span><br><span class="line"></span><br><span class="line">统计每个学生所选的课程数</span><br><span class="line">SELECT COUNT (StudentNumber) AS 所选课程数 FROM Grade GROUP BY StudentNumber;</span><br></pre></td></tr></table></figure><p>（三）连接查询</p><p>也称多表查询</p><p>1.内连接查询</p><p>(1)语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT&#x2F;ALL]&lt;目标列表达式[别名]清单&gt;</span><br><span class="line">FROM &lt;关系名1[别名1]&gt; INNER JOIN&lt;关系名2[别名2]&gt;</span><br><span class="line">ON &lt;连接条件表达式&gt;;</span><br><span class="line"></span><br><span class="line">SELECT [DISTINCT&#x2F;ALL] &lt;目标列表达式[别名]清单&gt;</span><br><span class="line">FROM &lt;关系名[别名]清单&gt;</span><br><span class="line">WHERE &lt;连接条件表达式&gt;;</span><br></pre></td></tr></table></figure><p>2.外连接</p><p>除了返回满足条件的元组外，还返回不匹配的元组，相当于并集</p><p>3.自身连接</p><p>是一个表与其自己连接</p><p>（四）嵌套查询</p><p>在SQL语言中，一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p><p>但是不能使用ORDER BY子句，其只能对查询结果进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.IN的子查询</span><br><span class="line">查询属于软件工程系徐盛的学号、姓名和性别</span><br><span class="line">SELECT S.StudentNumber, S.StudentName, S.StudentSex</span><br><span class="line">FROM Student S WHERE StudentDept IN</span><br><span class="line">(SELECT DeptNumber FROM Dept WHERE DetpName&#x3D;&quot;软件工程系&quot;)</span><br><span class="line"></span><br><span class="line">2.比较运算符的查询</span><br><span class="line">SELECT S.StudentNumber, S.StudentName, S.StudentSex</span><br><span class="line">FROM Student S WHERE StudentDept&#x3D;</span><br><span class="line">(SELECT DeptNumber FROM Dept WHERE DetpName&#x3D;&quot;软件工程系&quot;)</span><br><span class="line"></span><br><span class="line">3.ANY或ALL的子查询</span><br><span class="line"></span><br><span class="line">4.EXISTS的子查询</span><br></pre></td></tr></table></figure><h2 id="2-3-数据更新语言"><a href="#2-3-数据更新语言" class="headerlink" title="2.3 数据更新语言"></a>2.3 数据更新语言</h2><p>（一）插入数据</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO&lt;表名&gt;[(&lt;属性名清单&gt;)] VALUES(&lt;常量清单&gt;);</span><br></pre></td></tr></table></figure><p>2.实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入学号、姓名、性别、籍贯、系别</span><br><span class="line">INSERT INTO Student(StudentNumber, StudentName, StudentSex,StudentAddress,StudentDept)</span><br><span class="line">VALUES(&#39;20160702&#39;,&#39;陈海&#39;,&#39;男&#39;,&#39;吉林&#39;,&#39;男&#39;)</span><br></pre></td></tr></table></figure><p>（二）修改数据</p><p>1.数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt;SET &lt;列名&gt;&#x3D;&lt;表达式&gt;[,&lt;列名&gt;&#x3D;&lt;表达式&gt;][WHERE&lt;条件&gt;];</span><br></pre></td></tr></table></figure><p>2.实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改籍贯</span><br><span class="line">Update Student SET StudentAddress&#x3D;&#39;黑龙江&#39;</span><br><span class="line">WHERE StudentName&#x3D;&#39;陈海&#39;;</span><br></pre></td></tr></table></figure><p>（三）删除语句</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM&lt;表名&gt;[WHERE&lt;条件&gt;];</span><br></pre></td></tr></table></figure><p>2.实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Student WHERE StudentSex&#x3D;&#39;女&#39;;</span><br></pre></td></tr></table></figure><h1 id="3-视图"><a href="#3-视图" class="headerlink" title="3 视图"></a>3 视图</h1><p>视图是一个虚表，不存放数据，数据仍然存放在原表中</p><p>（一）创立视图<br>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;视图名&gt;[&lt;列名清单&gt;]</span><br><span class="line"></span><br><span class="line">AS&lt;子查询&gt;[WITH CHECK OPTION];</span><br></pre></td></tr></table></figure><p>2.实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从Student表中取出系别为02的数据，组成视图</span><br><span class="line">CREATE VIEW Student_VIEW</span><br><span class="line">AS SELECT * FROM Student WHERE StudentDept&#x3D;02;</span><br></pre></td></tr></table></figure><p>（二）删除视图</p><p>1.语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW &lt;视图名&gt;;</span><br></pre></td></tr></table></figure><p>2.实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW Student_VIEW;</span><br></pre></td></tr></table></figure><p>（三）查询视图</p><p>与基本表一致</p><p>（四）更新视图</p><p>防止视图对基本表的修改，因此对视图的更新最终都是通过对基本表的更新来进行的</p><p>（五）视图表的有点与缺点</p><p>优点：</p><ol><li>简单</li><li>安全</li><li>逻辑数据独立性</li><li>视图用户能以多角度看待同一数据</li></ol><p>缺点：</p><ol><li>性能差</li><li>修改限制严重</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-关系数据库常识&quot;&gt;&lt;a href=&quot;#1-关系数据库常识&quot; class=&quot;headerlink&quot; title=&quot;1 关系数据库常识&quot;&gt;&lt;/a&gt;1 关系数据库常识&lt;/h1&gt;&lt;p&gt;（一）关系代数&lt;/p&gt;
&lt;p&gt;抽象的查询语言，它运算的对象是关系，运算产生的结果也是关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于传统的集合运算（二目运算，包括并、差、交和笛卡尔积）&lt;/li&gt;
&lt;li&gt;专门的关系运算（选择、投影、连接和除运算等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自然连接是一种特殊的等值连接。要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉&lt;/p&gt;
&lt;p&gt;外连接是连接运算的扩展，可以用来处理缺失的信息，避免信息的丢失&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（六）：I/O设备和系统</title>
    <link href="https://liangggggg.github.io/2020/09/11/CO6/"/>
    <id>https://liangggggg.github.io/2020/09/11/CO6/</id>
    <published>2020-09-11T04:47:42.000Z</published>
    <updated>2020-09-11T03:41:21.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-外存储器"><a href="#1-外存储器" class="headerlink" title="1 外存储器"></a>1 外存储器</h1><p>磁表面存储器的主要技术指标</p><ol><li>记录密度</li><li>存储容量</li><li>平均寻址时间</li><li>数据传输率</li><li>误码率</li></ol><a id="more"></a><p>磁表面存储器的记录方式</p><ol><li>归零制（RZ）</li><li>不归零制（NRZ）</li><li>“见1就翻”的不归零制（NRZ1）</li><li>调相制（PM）：磁带</li><li>调频制（FM）：硬盘和软盘</li><li>改进型调频制（MFM）</li></ol><p>评价记录方式的评价指标</p><ol><li>编码效率：记录一位信息的最大磁化翻转次数</li><li>自同步能力</li></ol><h1 id="2-中断方式"><a href="#2-中断方式" class="headerlink" title="2 中断方式"></a>2 中断方式</h1><ol><li>人为设置的中断</li><li>程序性事故</li><li>硬件故障</li><li>I/O设备</li><li>外部事件</li></ol><p>中断可简单地归纳为以下几个阶段</p><ol><li>中断请求</li><li>中断优判</li><li>中断响应</li><li>中断服务</li><li>中断返回</li></ol><h1 id="3-DMA方式"><a href="#3-DMA方式" class="headerlink" title="3 DMA方式"></a>3 DMA方式</h1><p>DMA适合于内存与高速I/O设备或外存之间的信息交换。DMA方式中，由于DMA接口与CPU共享内存，为有效分时使用内存，通常DMA与内存交换数据时采用以下三种方式</p><ol><li>CPU停止访问内存法</li><li>周期挪用法</li><li>DMA与CPU交替访问</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-外存储器&quot;&gt;&lt;a href=&quot;#1-外存储器&quot; class=&quot;headerlink&quot; title=&quot;1 外存储器&quot;&gt;&lt;/a&gt;1 外存储器&lt;/h1&gt;&lt;p&gt;磁表面存储器的主要技术指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录密度&lt;/li&gt;
&lt;li&gt;存储容量&lt;/li&gt;
&lt;li&gt;平均寻址时间&lt;/li&gt;
&lt;li&gt;数据传输率&lt;/li&gt;
&lt;li&gt;误码率&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（五）：中央处理器</title>
    <link href="https://liangggggg.github.io/2020/09/11/CO5/"/>
    <id>https://liangggggg.github.io/2020/09/11/CO5/</id>
    <published>2020-09-11T02:47:42.000Z</published>
    <updated>2020-09-11T02:53:14.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CPU的组成和功能"><a href="#1-CPU的组成和功能" class="headerlink" title="1 CPU的组成和功能"></a>1 CPU的组成和功能</h1><p>CPU是整个计算机的核心主要包括运算器和控制器</p><p>CPU的主要功能：</p><p>（一）指令控制</p><p>保证机器按顺序执行程序是CPU的首要任务</p><a id="more"></a><p>（二）操作控制</p><p>管理并产生由内存的每条指令的操作信号</p><p>（三）时间控制</p><p>（四）数据加工</p><p>CPU的主要寄存器</p><ol><li>通用寄存器</li><li>专用寄存器<ul><li>指令寄存器（IR）</li><li>程序计数器（PC）</li><li>存储器数据寄存器（MDR） </li><li>存储器地址寄存器（MAR）</li><li>状态标志寄存器（PSWR）</li></ul></li></ol><h1 id="2-时序系统和控制方式"><a href="#2-时序系统和控制方式" class="headerlink" title="2 时序系统和控制方式"></a>2 时序系统和控制方式</h1><ol><li>机器周期</li><li>时钟周期：机器周期又包含若干个时钟周期</li></ol><p>现在计算机微操作命令序列的形成方法主要有两种：一种是组合逻辑设计方法，为硬件连线逻辑；另一种是微程序设计方法，为存储逻辑</p><p>通常不同微操作序列所采用的时序控制方式称为CU的控制方式。常见的控制方式有</p><ol><li>同步控制</li><li>异步控制</li><li>联合控制</li><li>人工控制</li></ol><h1 id="3-微程序设计"><a href="#3-微程序设计" class="headerlink" title="3 微程序设计"></a>3 微程序设计</h1><p>将程序设计技术和存储技术相结合，将操作控制信号按一定规则进行信息编码，形成微指令，存放在一个只读存储器中。</p><p>一条微命令由一组实现一定操作功能的微命令构成。这些微操作时计算机最基本的、不可再分解的操作</p><p>一条微指令通常由两部分信息：</p><ol><li>操作控制字段：用于产生某一步所需的微操作控制信号</li><li>顺序控制字段：用于产生下一条执行的微指令地址</li></ol><p>微程序控制的计算机涉及到两个层次</p><ol><li>机器层：机器指令、程序、主存储器</li><li>微程序层：微指令、微程序和控制存储器</li></ol><p>微指令编码法是指微指令的操作控制字段的编码方法，通常有以下三种方法</p><ol><li>直接编码法</li><li>字段编码法</li><li>最短编译法</li></ol><p>微指令有垂直和水平之分，水平型微指令有很好的并行性，垂直型功能简单，容易掌握和利用，编程实现简单</p><p>微地址的形成</p><ol><li>增量方式（计数器法）</li><li>断定方法（下地址字段法）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-CPU的组成和功能&quot;&gt;&lt;a href=&quot;#1-CPU的组成和功能&quot; class=&quot;headerlink&quot; title=&quot;1 CPU的组成和功能&quot;&gt;&lt;/a&gt;1 CPU的组成和功能&lt;/h1&gt;&lt;p&gt;CPU是整个计算机的核心主要包括运算器和控制器&lt;/p&gt;
&lt;p&gt;CPU的主要功能：&lt;/p&gt;
&lt;p&gt;（一）指令控制&lt;/p&gt;
&lt;p&gt;保证机器按顺序执行程序是CPU的首要任务&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（四）：存储系统</title>
    <link href="https://liangggggg.github.io/2020/09/11/CO4/"/>
    <id>https://liangggggg.github.io/2020/09/11/CO4/</id>
    <published>2020-09-11T01:47:42.000Z</published>
    <updated>2020-09-11T02:42:21.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-存储器概述"><a href="#1-存储器概述" class="headerlink" title="1 存储器概述"></a>1 存储器概述</h1><p>按照数据的高字节和低字节在存储器中的存储次序，可分为</p><ul><li>大端：将最低字节存储在最大地址</li><li>小端：将最低字节存储在最小地址</li></ul><p>边界对齐虽然浪费了部分存储空间，但是提高了指令对操作数的访问速度</p><a id="more"></a><p>（一）按存储介质分类</p><ul><li>半导体</li><li>磁性材料</li><li>光盘等</li></ul><p>（二）按存取方式</p><ul><li>随机存储器：半导体和磁芯存储器</li><li>顺序存储器：磁带</li><li>半顺序存储器：磁盘</li></ul><p>（三）按存储器的读写功能分类</p><ul><li><p>只读存储器（ROM）：半导体存储器，只能读出不能写入</p><ul><li>掩膜只读存储器MROM</li><li>可编程只读存储器PROM：只能写一次</li><li>可编程可擦除EPROM</li><li>用电可擦除EEPROM</li></ul></li><li><p>随机存储器(RAM)</p><ul><li>静态随机存储器SRAM（速度比动态快）</li><li>动态随机存储器DRAM</li></ul></li></ul><p>（四）按信息的可保存性</p><p>断电后信息小时的存储器，称为易失性存储器；断电后能保存的，称为非易失性存储器</p><h1 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2 主存储器"></a>2 主存储器</h1><p>（一）DRAM的刷新</p><p>通常有三种刷新方式：集中刷新、分散刷新和异步刷新</p><p>（二）存储器与CPU的连接</p><p>存储器的扩展</p><p>1.位扩展</p><p>2.字扩展</p><p>3.字和位同时扩展</p><p>存储芯片与CPU芯片连接，要注意片与片之间的地址线、数据线和控制线的连接</p><p>1.地址线的连接</p><p>CPU的地址线往往比存储芯片的地址线多，通常是将CPU地址线的低位与存储芯片的地址线连接，高位在存储芯片扩充时使用，或做其他用途</p><p>2.数据线的连接</p><p>CPU的竖线数与存储芯片的数据线也不一定相等，要对存储芯片扩展，使其数据位数与CPU的数据线数相等</p><p>3.读/写命令线</p><p>可以直接与存储芯片的读/写命令线直接连接</p><p>4.片选线的连接</p><p>5.合理选择存储芯片</p><h1 id="3-高速缓冲存储器"><a href="#3-高速缓冲存储器" class="headerlink" title="3 高速缓冲存储器"></a>3 高速缓冲存储器</h1><p>Cache的容量与快长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。</p><p>Cache块内写入的信息，必须与被映射的主存块内的信息完全一致。</p><ol><li>写直达法</li><li>写回法</li></ol><p>高速缓冲存储器的改进</p><ol><li>单一缓存和两级缓存</li><li>统一缓存和分立缓存</li></ol><p>高速缓冲存储器的地址映射</p><ol><li>直接映射</li><li>全相联映射：可以将主存映射到Cache任意块上</li><li>组相联映射</li></ol><p>高速缓冲存储器的替换策略</p><ol><li>先进先出</li><li>近期最少使用使用</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-存储器概述&quot;&gt;&lt;a href=&quot;#1-存储器概述&quot; class=&quot;headerlink&quot; title=&quot;1 存储器概述&quot;&gt;&lt;/a&gt;1 存储器概述&lt;/h1&gt;&lt;p&gt;按照数据的高字节和低字节在存储器中的存储次序，可分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大端：将最低字节存储在最大地址&lt;/li&gt;
&lt;li&gt;小端：将最低字节存储在最小地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边界对齐虽然浪费了部分存储空间，但是提高了指令对操作数的访问速度&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（三）：指令和总线</title>
    <link href="https://liangggggg.github.io/2020/09/10/CO3/"/>
    <id>https://liangggggg.github.io/2020/09/10/CO3/</id>
    <published>2020-09-10T01:47:42.000Z</published>
    <updated>2020-09-10T07:21:18.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、指令系统"><a href="#一、指令系统" class="headerlink" title="一、指令系统"></a>一、指令系统</h1><p>（1）指令系统组成</p><p>计算机的指令有微指令、机器指令和宏指令之分</p><p>微指令是微程序级的命令，属于硬件；</p><p>宏指令是由若干条机器指令组成的软件指令，属于指令</p><p>机器指令则介于微指令与宏指令之间，是软件和硬件的交界面，通常简称为指令</p><a id="more"></a><p>指令系统一般由两种类型组成</p><p>1.非特权指令</p><p>主要提供用户使用，又可分为功能性指令和非功能性指令。功能性指令主要包括算术逻辑指令、数据传输指令、浮点运算指令、字符串指令等；非功能性指令主要包括转移指令、控制指令等。</p><p>2.特权指令</p><p>主要提供系统程序员使用，一般不允许用户使用。其中包括I/O指令，停机等待指令、存储管理及保护指令、控制系统状态指令、诊断指令等。</p><p>用户希望使用这些指令，必须通过访管指令调用操作系统，再由操作系统控制和执行这些特权指令</p><p>指令系统较好有几个原则：</p><ol><li>完备性</li><li>规整性：指令系统正交性、均匀性、对称性</li><li>兼容性</li><li>可扩充性</li></ol><p>（2）指令分类</p><p>按照功能可以分为</p><ol><li>数据传送指令</li><li>算术运算类</li><li>逻辑运算</li><li>程序控制</li><li>输入输出</li><li>字符串</li><li>系统控制类</li><li>其他指令</li></ol><p>（3）指令格式</p><p>1.基本格式</p><p>用二进制代码表示结构的形式，通常由操作码字段和地址码字段组成</p><p>2.指令长度</p><p>二进制代码的位数</p><p>指令长度可以等于机器字长，也可以大于或小于</p><p>指令长度等于机器字长称为单字长指令</p><p>等于半个机器字长，称为半字节指令</p><p>等于两个机器字长，称为双字长指令</p><p>若所有指令长度都是相等的，称为定长指令字结构；如果指令长度可变，称为变长指令字结构</p><p>3.操作码</p><p>指令系统中的每一条指令都有唯一确定的操作码</p><p>在字长较长的大中型计算机中大多采用固定长度，微小和小型计算机采用可变格式</p><p>4.地址码</p><p>用于指令的源操作数的地址、结果的地址以及下一条指令的地址</p><p>（4）寻址方式</p><p>寻址方式可以分为数据寻址和指令寻址。</p><p>1.指令寻址</p><p>指令寻址比较简单，可以分为顺序寻址和跳跃寻址</p><p>2.数据寻址</p><p>指令字中必须设字段来指明属于哪一种寻址方式。</p><ol><li>立即寻址：操作码和操作数被同时取出，不必再次访问存储器</li><li>直接寻址：给出地址A就是操作数的有效地址</li><li>间接寻址：指令给的地址不是操作数的地址，而是存放操作数的地址</li><li>寄存器寻址：所指寄存器中存放着的操作数（寄存器存取数据快；由于寄存器的数量较少，其地址码字段比主存单元地址字段短的多）</li><li>变址寻址：在遇到需要频繁修改地址时，无需修改命令，只需修改变址就可以</li><li>基址寻址：算法与变址寻址基本相同，但是面向场合不同，变址面向用户，基址面向系统</li><li>相对寻址</li><li>隐含寻址</li><li>堆栈寻址</li></ol><p>（5）RISC技术</p><p>精简指令系统</p><ol><li>选取使用频率较高的简单指令，以及很有用但不复杂</li><li>指令长度固定，指令格式少，寻址方式类少</li><li>只有存取指令访问存储器，其余操作都在寄存器内完成</li><li>CPU有多个通用寄存器</li><li>采用流水线操作，大部分指令在一个时钟周期完成</li><li>控制器采用组合逻辑控制为主</li><li>采用优化编译技术</li></ol><h1 id="二、总线系统"><a href="#二、总线系统" class="headerlink" title="二、总线系统"></a>二、总线系统</h1><p>总线是连接多个部件的信息传输线，是各部分共享的传输介质</p><p>从不同角度，按数据传输方式，可分为串行传输总线和并行传输总线；</p><p>按连接部件不同，可分为片内总线、系统总线和通信总线</p><p>系统总线按照传输信息的不同，又可以分为三类：</p><ol><li>地址总线：传送CPU发出的地址信息，是单向总线</li><li>数据总线：传送数据信息，是双向总线</li><li>控制总线：传送控制信号、时序信号和状态信息等，是双向总线</li></ol><p>总线的特性</p><ul><li>物理特性</li><li>功能特性</li><li>电器特性</li><li>时间特性</li></ul><p>总线性能指标</p><ul><li>总线频率</li><li>总线宽度：总线的位数</li><li>总线的传输速率</li><li>时钟同步/异步</li><li>总线复用</li><li>总线负载能力</li></ul><p>总结结构</p><ul><li>单总线结构：用一条系统总结连接计算机系统的各个功能部件，各功能间所有的信息传输都靠这条总线来实现</li><li>双总线结构</li><li>三总线结构</li></ul><p>总线标准</p><ul><li>SCSI：小型计算机接口，是一种通用的并行接口标准，用于计算机和外部设备之间进行物理连接和传输数据，通常用在硬盘和磁带</li><li>RS-232C：串行通信总线，应用于串行二进制交换的数据终端设备和数据通信设备之间的标准接口</li><li>FireWire</li><li>USB:通用串行，实现外设的简单快速连接<ul><li>USB2.0最高速度480Mbs,供电能力0.5A</li><li>USB3.0最高速度5Gbps，供电能力1A</li></ul></li></ul><p>总线控制</p><ul><li>总线仲裁：为避免总线冲突，以一定的优先算法仲裁总线的使用权</li></ul><p>1.链式查询</p><p>有点在于只用很少几根线就能按一定优先次序实现总线仲裁，很容易扩充设备。但是对电路故障很敏感，而且查询的优先极是固定的，优先极较低的设备可能长期不能使用总线</p><p>2.定时器定时查询</p><p>3.独立请求</p><ul><li>总线通信控制</li></ul><p>解决通信双方如何获知传输开始和传输结构</p><ol><li>同步通信：通信双方由同一时标控制通信</li><li>异步通信</li><li>半同步通信</li><li>分离式通信</li></ol><p>总线的信息传输模式</p><ol><li>读写操作</li><li>块传输操作</li><li>写后读、读修改写操作</li><li>广播、广集操作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、指令系统&quot;&gt;&lt;a href=&quot;#一、指令系统&quot; class=&quot;headerlink&quot; title=&quot;一、指令系统&quot;&gt;&lt;/a&gt;一、指令系统&lt;/h1&gt;&lt;p&gt;（1）指令系统组成&lt;/p&gt;
&lt;p&gt;计算机的指令有微指令、机器指令和宏指令之分&lt;/p&gt;
&lt;p&gt;微指令是微程序级的命令，属于硬件；&lt;/p&gt;
&lt;p&gt;宏指令是由若干条机器指令组成的软件指令，属于指令&lt;/p&gt;
&lt;p&gt;机器指令则介于微指令与宏指令之间，是软件和硬件的交界面，通常简称为指令&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（二）：数据的表示与运算</title>
    <link href="https://liangggggg.github.io/2020/09/09/CO2/"/>
    <id>https://liangggggg.github.io/2020/09/09/CO2/</id>
    <published>2020-09-09T01:47:42.000Z</published>
    <updated>2020-09-09T08:37:18.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、非十进制数转换为十进制数"><a href="#一、非十进制数转换为十进制数" class="headerlink" title="一、非十进制数转换为十进制数"></a>一、非十进制数转换为十进制数</h1><p>（一）方法</p><p>每位上的数码乘以基的位次方，然后求和</p><a id="more"></a><h1 id="二、十进制转换成非十进制数"><a href="#二、十进制转换成非十进制数" class="headerlink" title="二、十进制转换成非十进制数"></a>二、十进制转换成非十进制数</h1><p>（一）方法</p><p>整数部分：除N取余数，直至商为0，余数倒数输出</p><p>小数部分：乘N取整数，直至积为0（或满足精度），整数正输出</p><h1 id="三、二-八-十六进制相互转换"><a href="#三、二-八-十六进制相互转换" class="headerlink" title="三、二/八/十六进制相互转换"></a>三、二/八/十六进制相互转换</h1><p>对应位数相互转换</p><p>一个八进制对应3个二进制</p><p>一个十六进制对应4个二进制</p><h1 id="四、机器数"><a href="#四、机器数" class="headerlink" title="四、机器数"></a>四、机器数</h1><p>对于数的符号机器是无法识别的，需要把符号数码化，约定二进制的最高位为符号位</p><p>“0”表示正号，“1”表示负号</p><p>（一）原码</p><p>机器数最简单的表示方式，其符号位用0表示正号，1表示负号</p><p>（二）反码</p><p>机器数的反码由原码得到，如果是正数则与原码一样</p><p>如果是负数，则符号位不变，其余取反</p><p>（三）补码</p><p>如果是正数，则机器数的补码与原码一致</p><p>如果是负数，则是反码末尾加一</p><p>（四）补码的加减运算</p><p>1.补码加法</p><p>两个补码表示的数相加，符号位参与运算，且两位数和的补码等于两数补码之和：</p><p>$$[X+Y]补=[X]补+[Y]补$$</p><p>$$[Y补]补=[Y]原$$</p><p>已知[Y]补求[-Y]补的方法是：将[Y]<br>补连通符号位一起求反，末尾加一</p><p>2.符号扩展</p><p>原有符号位，保持不变，若<br>为正数所有附加位用0进行填充；若为负数则所有附加位用负数填充</p><p>3.补码溢出的产生</p><p>发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围</p><ul><li>若两数异号则不会溢出</li></ul><p>4.补码溢出的检测</p><p>（1）采用符号位检测</p><p>（2）采用进位位</p><p>（3）采用变形补码（双符号位补码）</p><h1 id="五、定点数和浮点数表示"><a href="#五、定点数和浮点数表示" class="headerlink" title="五、定点数和浮点数表示"></a>五、定点数和浮点数表示</h1><ul><li><p>定点数：小数点固定不变</p></li><li><p>浮点数：小数点可以浮动</p></li></ul><p>微型机多使用定点数</p><p>计算机中的浮点表示包括两个部分：一部分是阶码（表示指数，记作E）；另一部分是尾数（表示有效数字，记作M）</p><p>设任意一个数N可以表示为：</p><p>$$N*2^E$$</p><p>其中，2位基数；E为阶码；M为尾数，浮点数在机器中的表示方法如下：</p><table><thead><tr><th align="center">阶符</th><th align="center">阶码（E）</th><th align="center">数符</th><th align="center">尾数（M）</th></tr></thead></table><p>当一个数的阶码大于机器所能表示的最大阶码，产生上溢，上溢时机器一般不再继续运算而转入</p><p>当一个阶码小于机器所能表示的最小阶码，发生下溢，机器按0来处理</p><p>（一）IEEE754标准</p><p>S：1位，E：8位，M：23位</p><table><thead><tr><th align="center">符号位（S）</th><th align="center">阶码（E）</th><th align="center">尾数（M）</th></tr></thead></table><p>其对应的真值是：</p><p>$$x=(-1)^S * (1.M)* 2^e, e = (E)_{10}-127$$</p><h1 id="六、浮点加减法运算"><a href="#六、浮点加减法运算" class="headerlink" title="六、浮点加减法运算"></a>六、浮点加减法运算</h1><p>（一）对阶</p><p>对阶的目的是使两操作数的小数点位置对齐。</p><p>（二）尾数求和</p><p>将对阶后的两个尾数，按定点加（减）运算规则进行运算</p><p>（三）规格化</p><p>为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化</p><p>当尾数用二进制表示时，尾数M的规格化形式为</p><p>$$1/2&lt;=|M|&lt;1$$</p><p>（四）舍入</p><ol><li>0舍1入法：在尾数右移时，被移去的最高数值为0，则舍去；反之则在尾数的末位加1</li><li>恒置1法：尾数右移，尾数丢失，都在尾数末位恒置1</li></ol><p>（五）溢出判断</p><p>浮点数的溢出是以其阶码溢出表现出来的</p><h1 id="七、逻辑运算和位移操作"><a href="#七、逻辑运算和位移操作" class="headerlink" title="七、逻辑运算和位移操作"></a>七、逻辑运算和位移操作</h1><p>计算机中的逻辑运算包括与、或、非、异或等运算</p><p>移位运算为移位操作，对计算机来说有很大的实用价值，如当某计算机没有乘除法运算线路时，可以采用移位和加法相结合以实现乘除运算</p><p>算术移位的规则（有符号数）：</p><p>首先，不论是正数还是负数，移位后其符号位均不变</p><p>对于正数，移位后出现的空位均填0</p><p>对于负数，其空位的添补规则不同：</p><ol><li>原码，其空位均添0</li><li>反码，其空位均添1</li><li>补码，左移空位添0，右移其空位添1</li></ol><p>逻辑移位的规则是（无符号数）：</p><p>逻辑左移，高位丢失，低位添0</p><p>逻辑右移，低位丢失，高位添0</p><h1 id="八、非数值数据的表示"><a href="#八、非数值数据的表示" class="headerlink" title="八、非数值数据的表示"></a>八、非数值数据的表示</h1><p>ASCII码，美国信息交换标准代码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码</p><p>汉子的编码：GB2312-80，简称国标码</p><h1 id="九、数据校验码"><a href="#九、数据校验码" class="headerlink" title="九、数据校验码"></a>九、数据校验码</h1><p>奇偶校验码，在被传送的n位有效信息代码上增加一位校验位，并使其配置后n+1位代码中1的个数为奇数，则称其为奇校验，如果是偶数则称为偶校验</p><p>循环冗余校验码（CRC），基于摸2运算建立的校验码，将待编码的有效信息左移若干位，用另一个约定的多项式去除，所产生的余数就是校验位。有效信息和校验位相拼接就构成了CRC</p><p>接受到的数据除以校验位，如果有余数发生错误，如果除尽了就代表是正确的</p><p>海明校验码是目前广泛采用的一种有效的校验码。在有效信息中加入几个校验位形成海明码，当某一位出现错误后，就会引起有关的几个校验位的值发生变化，因此海明码不但可以发现错误，还能指出错误的位置，为自动纠错提供位置</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、非十进制数转换为十进制数&quot;&gt;&lt;a href=&quot;#一、非十进制数转换为十进制数&quot; class=&quot;headerlink&quot; title=&quot;一、非十进制数转换为十进制数&quot;&gt;&lt;/a&gt;一、非十进制数转换为十进制数&lt;/h1&gt;&lt;p&gt;（一）方法&lt;/p&gt;
&lt;p&gt;每位上的数码乘以基的位次方，然后求和&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记（一）：计算机系统概述</title>
    <link href="https://liangggggg.github.io/2020/09/08/CO1/"/>
    <id>https://liangggggg.github.io/2020/09/08/CO1/</id>
    <published>2020-09-08T01:47:42.000Z</published>
    <updated>2020-09-08T11:20:57.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算机的发展"><a href="#一、计算机的发展" class="headerlink" title="一、计算机的发展"></a>一、计算机的发展</h1><p>1946年，世界上第一台计算机（ENIAC）诞生于美国宾夕法尼亚大学，可以分为4个阶段</p><ul><li>第一代：1946-1957年，电子管计算机</li><li>第二代：1958-1964年，晶体管计算机</li><li>第三代：1965-1971年，中小规模或电路计算机</li><li>第四代：1972-至今，大规模和超大规模集成电路计算机</li></ul><a id="more"></a><h1 id="二、计算机的应用"><a href="#二、计算机的应用" class="headerlink" title="二、计算机的应用"></a>二、计算机的应用</h1><ol><li>科学计算</li><li>过程控制</li><li>人工智能</li><li>数据处理</li><li>计算机辅助应用</li><li>网络应用</li><li>多媒体技术</li><li>电子商务</li></ol><h1 id="三、计算机的发展趋势"><a href="#三、计算机的发展趋势" class="headerlink" title="三、计算机的发展趋势"></a>三、计算机的发展趋势</h1><ol><li>巨型化：指计算机的运算速度更高，存储容量更大，功能更强</li><li>微型化</li><li>智能化</li><li>网络化</li><li>多媒体化</li></ol><h1 id="四、计算机的特点"><a href="#四、计算机的特点" class="headerlink" title="四、计算机的特点"></a>四、计算机的特点</h1><ol><li>计算机速度快</li><li>运算精度高</li><li>逻辑运算能力强</li><li>存储容量大</li><li>自动化程度高</li><li>性价比高</li></ol><h1 id="五、计算机的分类"><a href="#五、计算机的分类" class="headerlink" title="五、计算机的分类"></a>五、计算机的分类</h1><p>（一）按数据处理方式</p><ol><li><p>数字式计算机：是当今世界电子计算机行业中的主流</p></li><li><p>模拟式计算机：问世较早，内部所使用的电信号模拟自然界的实际信号</p></li><li><p>数字模拟混合式计算机</p></li></ol><p>（二）按计算机用途</p><ol><li><p>专用计算机</p></li><li><p>通用计算机</p></li></ol><p>（三）按计算机性能</p><ol><li>巨型计算机</li><li>大/中型计算机</li><li>小型计算机</li><li>微型计算机</li><li>单片机</li></ol><p>（四）按计算机使用方式</p><ol><li>桌面型计算机</li><li>服务器型计算机</li><li>嵌入式计算机</li></ol><h1 id="六、计算机的性能指标"><a href="#六、计算机的性能指标" class="headerlink" title="六、计算机的性能指标"></a>六、计算机的性能指标</h1><p>（一）字长</p><p>字长以二进制为单位，是CPU一次能够处理二进制数据的位数，它直接关系到计算机的计算精度和运算能力</p><p>（二）运算速度</p><p>用来衡量运算速度的指标有MIPS（百万条指令/秒）、MFLOPS（百万次浮点运算/秒）、CPI（执行一条指令所需要的时钟周期）</p><p>（三）时钟频率</p><p>指CPU在单位时间内发出的脉冲次数，以兆赫（MHz）和吉赫（GHz）为单位</p><p>（四）内存容量</p><h1 id="七、计算机系统和组成结构"><a href="#七、计算机系统和组成结构" class="headerlink" title="七、计算机系统和组成结构"></a>七、计算机系统和组成结构</h1><p>（一）冯·诺依曼计算机</p><p>存储程序的概念由冯·诺依曼于1945年提出，奠定了现在计算机的结构基础。现在计算机均为冯诺依曼体系结构</p><ol><li>计算机的五大组成：运算器、控制器、存储器、输入设备和输出设备五大部件</li><li>采用二进制</li><li>存储程序：是冯诺依曼思想的核心，将实现编号的程序存入计算机中，计算机按照这些程序自动运行</li></ol><p>（二）冯·诺依曼的工作原理</p><ol><li>存储程序：将要执行的程序和数据事先编程二进制形式的编码存入主存储其中</li><li>程序控制：自动地、连续的从主存储器中依次取出指令并执行</li></ol><p>典型的冯诺依曼以运算器为中心，但是现代的计算机已转为存储器为中心</p><p>（三）计算机系统的构成</p><p>一个计算机系统包括硬件系统和软件系统两大部分</p><p>硬件包括运算器、控制器、存储器、输入设备和输出设备等五个基本部分</p><p>而硬件中包括：</p><ol><li>主机系统：运算器、控制器与内存储器</li><li>外部设备：外存储器、输入设备、输出设备</li></ol><p>运算器和控制器统称为CPU</p><ul><li>随机存储器（RAM）：随时读写，速度很快</li><li>只读存储器（ROM）：一般是事先写好的，计算机工作过程中只能读出，ROM数据稳定，断电后不会改变</li></ul><p>软件则是程序和有关文档的总称，通常存放在计算机的主存或辅存内</p><p>计算机软件系统包括软件系统和应用软件两大类</p><p>（四）计算机系统的层次机构</p><ol start="0"><li>微程序机器层</li><li>机器语言层</li><li>操作系统层</li><li>汇编语言层</li><li>高级语言层</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、计算机的发展&quot;&gt;&lt;a href=&quot;#一、计算机的发展&quot; class=&quot;headerlink&quot; title=&quot;一、计算机的发展&quot;&gt;&lt;/a&gt;一、计算机的发展&lt;/h1&gt;&lt;p&gt;1946年，世界上第一台计算机（ENIAC）诞生于美国宾夕法尼亚大学，可以分为4个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一代：1946-1957年，电子管计算机&lt;/li&gt;
&lt;li&gt;第二代：1958-1964年，晶体管计算机&lt;/li&gt;
&lt;li&gt;第三代：1965-1971年，中小规模或电路计算机&lt;/li&gt;
&lt;li&gt;第四代：1972-至今，大规模和超大规模集成电路计算机&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记（一）递归</title>
    <link href="https://liangggggg.github.io/2020/09/03/algorithm/"/>
    <id>https://liangggggg.github.io/2020/09/03/algorithm/</id>
    <published>2020-09-03T01:47:42.000Z</published>
    <updated>2020-09-04T07:42:21.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-递归的概念"><a href="#1-递归的概念" class="headerlink" title="1 递归的概念"></a>1 递归的概念</h1><ul><li>一个函数调用其自身</li></ul><p><strong>求N！的递归函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int F(int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if (n&#x3D;&#x3D;0)</span><br><span class="line">return 1;</span><br><span class="line">else </span><br><span class="line">return n*F(n-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归和普通函数调用一样是通过栈实现的</p><a id="more"></a><h1 id="2-递归的作用"><a href="#2-递归的作用" class="headerlink" title="2 递归的作用"></a>2 递归的作用</h1><ol><li>替代多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解为更小规模子问题进行求解</li></ol><p><strong>汉诺塔问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Hanoi(n,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Hanoi(int n , char src, char mid, char dest)</span><br><span class="line">&#x2F;&#x2F;将src座上的n个盘子，以mid座为中转，移动到dest座</span><br><span class="line">&#123;</span><br><span class="line">if(n&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;只需要移动一个盘子</span><br><span class="line">cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dext&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;直接将盘子从src移动到dest即可</span><br><span class="line">return; &#x2F;&#x2F;递归终止</span><br><span class="line">&#125;</span><br><span class="line">Hanoi(n-1,src,dest,mid) &#x2F;&#x2F;先将n-1个盘子从src移动到mid</span><br><span class="line">cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;再将盘子从src移动到dest</span><br><span class="line">Hanoi(n-1,mid,src,dest);&#x2F;&#x2F;最后将N-1个盘子从Mid移动到dest</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>N皇后</strong></p><p>n皇后问题：输入整数n，要求n个国际象棋的皇后，摆在n*n的棋盘上，相互不能攻击，输出全部方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int N;</span><br><span class="line">int queenPos[100];</span><br><span class="line">&#x2F;&#x2F;用来存放算好的皇后位置，最左上角是（0，0）</span><br><span class="line">void NQueen(int k);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt;N;</span><br><span class="line">NQueen(0);&#x2F;&#x2F;从0行开始摆皇后</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NQueen(int k)&#123; &#x2F;&#x2F;在0~k-1行皇后已经摆好的情况下，摆第k行及其后的皇后</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">if(k&#x3D;&#x3D;N)&#123;&#x2F;&#x2F; N个皇后已经摆好</span><br><span class="line">for(i&#x3D;0; i&lt;N; i++)</span><br><span class="line">cout &lt;&lt; queenPos[i]+1 &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;0; i&lt;N; i++)&#123; &#x2F;&#x2F;逐尝试第k个皇后的位置</span><br><span class="line">int j;</span><br><span class="line">for(j&#x3D;0; j&lt;k ; j++)&#123;</span><br><span class="line">&#x2F;&#x2F;和已经摆好的k各皇后的位置比较，看是否冲突</span><br><span class="line">if(queenPos[j]&#x3D;&#x3D;i || abs(queenPos[j]-1)&#x3D;&#x3D; abs(k-j))&#123;</span><br><span class="line">break; &#x2F;&#x2F;冲突，则试下一个位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(j&#x3D;&#x3D;k)&#123;</span><br><span class="line">queenPos[k]&#x3D;i; &#x2F;&#x2F;将第k个皇后摆放在位置i</span><br><span class="line">NQueen(k+1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-递归的概念&quot;&gt;&lt;a href=&quot;#1-递归的概念&quot; class=&quot;headerlink&quot; title=&quot;1 递归的概念&quot;&gt;&lt;/a&gt;1 递归的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个函数调用其自身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;求N！的递归函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int F(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (n&amp;#x3D;&amp;#x3D;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return n*F(n-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;递归和普通函数调用一样是通过栈实现的&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://liangggggg.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://liangggggg.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库与SQL知识总结</title>
    <link href="https://liangggggg.github.io/2020/08/29/DB/"/>
    <id>https://liangggggg.github.io/2020/08/29/DB/</id>
    <published>2020-08-29T02:20:59.000Z</published>
    <updated>2020-08-29T10:28:41.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常见问题总结"><a href="#1-常见问题总结" class="headerlink" title="1 常见问题总结"></a>1 常见问题总结</h2><h2 id="1-1-什么是MySQL"><a href="#1-1-什么是MySQL" class="headerlink" title="1.1 什么是MySQL"></a>1.1 什么是MySQL</h2><p>MySQL是一种关系型数据库，默认端口号是33006，默认的存储引擎是InnoDB，只有InnoDB是事务性存储引擎</p><p><strong>MyISAM和InnoDB区别</strong></p><p>MyISAM是MySQL的默认数据引擎（5.5版之前）虽然性能极佳，但是不支持事务和行级锁，却最大的缺陷就是崩溃后无法安全恢复，在5.5版之后，MySQL就引入了InnoDB(事务性数据库引擎)</p><a id="more"></a><p><strong>两者对比</strong></p><ol><li>是否支持行级锁</li><li>是否支持事务和崩溃后的安全恢复</li><li>是否支持外键</li><li>是否支持MVCC</li></ol><p><strong>字符集和校对规则</strong></p><p>字符集指的是一种从二进制编码到某类字符符号的映射，校对规则是指某种字符集下的排序规则</p><p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承</p><p><strong>索引</strong></p><p>MySQL索引使用的数据结构主要有BTree索引和哈希索引，对哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单挑记录查询的时候，可以选择哈希索引，查询性能最快，其余大部分场景，建议选择BTree索引</p><p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的</p><ul><li>MyISAM：B+树叶结点的data域存放的是数据记录地址，在检索索引的时候，先按照B+树搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，被称为非聚簇索引</li><li>InnoDB：其数据本身就是索引文件，索引文件和数据文件是分离的，其表数据文件本身就是按B+树组织的一个索引结构，树的叶结点data域保存了完整的数据记录，这个索引key时数据表的主键，因此InonoDB表数据文件本身就是主索引。这被称为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。</li></ul><p>在根据主索引搜索时，直到找到key所在的结点即取出数据，在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引，因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非常单调的字段作为主键，这样会造成主索引频繁分裂</p><h2 id="1-2-什么是事务？"><a href="#1-2-什么是事务？" class="headerlink" title="1.2 什么是事务？"></a>1.2 什么是事务？</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><p>事务的四大特性（ACID）</p><ol><li>原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li><li>一致性（Consistency）：执行事务前后，数据保持一致，多个事务对统一数据读取的结果是相同的</li><li>隔离性（IsoIation）：并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库时独立的</li><li>持久性（Durability）：一个事务被提交之后。对数据库中数据的改变是永久的，即使数据库发送故障也不应该对齐有任何影响</li></ol><p><strong>并发事务带来哪些问题？</strong></p><ul><li>脏度（Dirty read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到这个数据是“脏数据”，依据“脏”数据所做的操作可能是不正确的</li><li>丢失修改（Lost to modify）：指一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失</li><li>不可重复读（Unrepeatableread）：指一个事务内多次读同一个数据，这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，就发生了在一个事务内两次读到的数据是不一样的情况</li><li>幻读（Phantom read）：幻读与不可重复读类似，它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录</li></ul><p><strong>不可重复读和幻读的区别</strong></p><p>不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，比如多读取一条记录发现记录增多或减少了</p><p><strong>事务隔离级别有哪些？MySQL的默认隔离级别是？</strong></p><p>SQL标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED（读取未提交）：最低的隔离界别，允许读取尚未提交的数据，可能会导致脏度，幻读，不可重复读</li><li>READ-COMMITTED（读取已提交）：允许读取并发事务已提交的数据，可以阻止脏度，但是幻读和不可重复读还是有可能发生</li><li>REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据被本身事务自己所修改，可以阻止脏度和不可重复读，但幻读仍有可能发生</li><li>SERIALIZABLE（可串行化）：最高的隔离级别，完全俯冲ACID的隔离级别，所有事务依次逐个执行</li></ul><p>注意：与SQL标准不同的地方在于InnoDB存储引擎在<strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的Next-key Lock锁算法，因此可以避免幻读的产生。已经可以完全保证了事务的隔离性要求</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别</p><p><strong>锁机制与InnoDB锁算法</strong></p><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁</li><li>InnoDB支持行级锁和表级锁，默认为行级锁</li></ul><p><strong>表级锁和行级锁对比：</strong></p><ul><li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗较少，不会出现死锁，但出发锁冲突的概率最高，并发度最低</li><li>行级锁：MySQL中粒度最小的一种锁，只针对当前的行进行加锁，行级锁能大大减少数据库操作的冲突，其并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><p><strong>大表优化</strong></p><p>当MySQL单表记录过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li>限定数据的范围</li><li>读/写分离</li><li>垂直分区：根据数据库里数据表的相关性进行拆分，把一张列比较多的表拆分为多张表</li><li>水平分区：数据表行的拆分</li></ol><p><strong>池化设计思想，什么是数据库连接池？为什么需要数据库连接池？</strong></p><p>数据库连接本质是一个socket连接，数据库服务端还要维护一些缓存和用户权限信息之类的，可以把数据库连接池看作是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，即昂贵又浪费资源。在连接池中，创建链接后，将其放置池中，并再次使用它，因此不必建立新的连接，如果使用了所有连接，则建立一个新连接并将其添加到池中。</p><h1 id="2-MySQL与SQL常用操作命令"><a href="#2-MySQL与SQL常用操作命令" class="headerlink" title="2 MySQL与SQL常用操作命令"></a>2 MySQL与SQL常用操作命令</h1><h2 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Windows服务 *&#x2F;</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath&#x3D; mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">&#x2F;* 连接与断开服务器 *&#x2F;</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure><h2 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据库操作 *&#x2F; ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure><h2 id="2-3-表的操作"><a href="#2-3-表的操作" class="headerlink" title="2.3 表的操作"></a>2.3 表的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET &#x3D; charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE &#x3D; engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory&#x2F;Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    AUTO_INCREMENT &#x3D; 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT &#x3D; &#39;string&#39;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &#39;pattern&#39;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表结构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 &#x2F; DESCRIBE 表名 &#x2F; EXPLAIN 表名 &#x2F; SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE&#x3D;MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="2-4-数据操作"><a href="#2-4-数据操作" class="headerlink" title="2.4 数据操作"></a>2.4 数据操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据操作 *&#x2F; ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名&#x3D;值[, 字段名&#x3D;值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名&#x3D;新值[, 字段名&#x3D;新值] [更新条件]</span><br></pre></td></tr></table></figure><h2 id="2-5-字符集编码"><a href="#2-5-字符集编码" class="headerlink" title="2.5 字符集编码"></a>2.5 字符集编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 字符集编码 *&#x2F; ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 &#x3D; 变量值</span><br><span class="line">    SET character_set_client &#x3D; gbk;</span><br><span class="line">    SET character_set_results &#x3D; gbk;</span><br><span class="line">    SET character_set_connection &#x3D; gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]&#x2F;SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure><h2 id="2-6-数据类型（列类型）"><a href="#2-6-数据类型（列类型）" class="headerlink" title="2.6 数据类型（列类型）"></a>2.6 数据类型（列类型）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据类型（列类型） *&#x2F; ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2&#x3D;65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset&#x3D;utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)&#x2F;3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );</span><br><span class="line">    insert into tab values (&#39;男, 女&#39;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure><h2 id="2-7-列属性（列约束）"><a href="#2-7-列属性（列约束）" class="headerlink" title="2.7 列属性（列约束）"></a>2.7 列属性（列约束）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 列属性（列约束） *&#x2F; ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &#39;val&#39;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment &#x3D; x进行设置，或 alter table tbl auto_increment &#x3D; x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &#39;注释内容&#39;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint &#96;t1_t2_fk&#96; foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure><h2 id="2-8-建表规范"><a href="#2-8-建表规范" class="headerlink" title="2.8 建表规范"></a>2.8 建表规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 建表规范 *&#x2F; ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure><h2 id="2-9-SELECT"><a href="#2-9-SELECT" class="headerlink" title="2.9 SELECT"></a>2.9 SELECT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SELECT *&#x2F; ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            &#x3D;, &lt;&#x3D;&gt;, &lt;&gt;, !&#x3D;, &lt;&#x3D;, &lt;, &gt;&#x3D;, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is&#x2F;is not 加上ture&#x2F;false&#x2F;unknown，检验某个值的真假</span><br><span class="line">            &lt;&#x3D;&gt;与&lt;&gt;功能相同，&lt;&#x3D;&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段&#x2F;别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段&#x2F;别名 排序方式 [,排序字段&#x2F;别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure><h2 id="2-10-UNION"><a href="#2-10-UNION" class="headerlink" title="2.10 UNION"></a>2.10 UNION</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* UNION *&#x2F; ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure><h2 id="2-11-子查询"><a href="#2-11-子查询" class="headerlink" title="2.11 子查询"></a>2.11 子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 子查询 *&#x2F; ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money &#x3D; (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    !&#x3D; all()    相当于 not in</span><br><span class="line">    &#x3D; some()    相当于 in。any 是 some 的别名</span><br><span class="line">    !&#x3D; some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure><h2 id="2-12-连接查询-join"><a href="#2-12-连接查询-join" class="headerlink" title="2.12 连接查询(join)"></a>2.12 连接查询(join)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 连接查询(join) *&#x2F; ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num &#x3D; extra_info.stu_id;</span><br></pre></td></tr></table></figure><h2 id="2-13-TRUNCATE"><a href="#2-13-TRUNCATE" class="headerlink" title="2.13 TRUNCATE"></a>2.13 TRUNCATE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* TRUNCATE *&#x2F; ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure><h2 id="2-14-备份与还原"><a href="#2-14-备份与还原" class="headerlink" title="2.14 备份与还原"></a>2.14 备份与还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 备份与还原 *&#x2F; ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure><h2 id="2-15-视图"><a href="#2-15-视图" class="headerlink" title="2.15 视图"></a>2.15 视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure><h2 id="2-16-事务"><a href="#2-16-事务" class="headerlink" title="2.16 事务"></a>2.16 事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据完整性方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit &#x3D; 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure><h2 id="2-17-锁表"><a href="#2-17-锁表" class="headerlink" title="2.17 锁表"></a>2.17 锁表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 锁表 *&#x2F;</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure><h2 id="2-18-触发器"><a href="#2-18-触发器" class="headerlink" title="2.18 触发器"></a>2.18 触发器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 触发器 *&#x2F; ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure><h2 id="2-19-SQL编程"><a href="#2-19-SQL编程" class="headerlink" title="2.19 SQL编程"></a>2.19 SQL编程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SQL编程 *&#x2F; ------------------</span><br><span class="line">--&#x2F;&#x2F; 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--&#x2F;&#x2F; 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var &#x3D; value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免&#x3D;被当作关系运算符看待，使用:&#x3D;代替。（set语句可以使用&#x3D; 和 :&#x3D;）。</span><br><span class="line">select @var:&#x3D;20;</span><br><span class="line">select @v1:&#x3D;id, @v2&#x3D;name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:&#x3D;30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var&#x3D;10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--&#x2F;&#x2F; 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--&#x2F;&#x2F; 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) &#x3D; 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) &#x3D; 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) &#x3D; 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) &#x3D; 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3&#x3D;1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分</span><br><span class="line">time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分</span><br><span class="line">date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--&#x2F;&#x2F; 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &#39;partten&#39;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--&#x2F;&#x2F; 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure><h2 id="2-10-存储过程"><a href="#2-10-存储过程" class="headerlink" title="2.10 存储过程"></a>2.10 存储过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 存储过程 *&#x2F; ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="2-11-用户和权限管理"><a href="#2-11-用户和权限管理" class="headerlink" title="2.11 用户和权限管理"></a>2.11 用户和权限管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用户和权限管理 *&#x2F; ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE &#96;user&#96; SET PASSWORD&#x3D;PASSWORD(&quot;密码&quot;) WHERE &#96;user&#96; &#x3D; &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 &#x3D; PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限&#x2F;添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON &#96;pms&#96;.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure><h2 id="2-12-表维护"><a href="#2-12-表维护" class="headerlink" title="2.12 表维护"></a>2.12 表维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 表维护 *&#x2F;</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="2-13-杂项"><a href="#2-13-杂项" class="headerlink" title="2.13 杂项"></a>2.13 杂项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 杂项 *&#x2F; ------------------</span><br><span class="line">1. 可用反引号（&#96;）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 &#x2F;* 注释内容 *&#x2F;</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#39;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-常见问题总结&quot;&gt;&lt;a href=&quot;#1-常见问题总结&quot; class=&quot;headerlink&quot; title=&quot;1 常见问题总结&quot;&gt;&lt;/a&gt;1 常见问题总结&lt;/h2&gt;&lt;h2 id=&quot;1-1-什么是MySQL&quot;&gt;&lt;a href=&quot;#1-1-什么是MySQL&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是MySQL&quot;&gt;&lt;/a&gt;1.1 什么是MySQL&lt;/h2&gt;&lt;p&gt;MySQL是一种关系型数据库，默认端口号是33006，默认的存储引擎是InnoDB，只有InnoDB是事务性存储引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM和InnoDB区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM是MySQL的默认数据引擎（5.5版之前）虽然性能极佳，但是不支持事务和行级锁，却最大的缺陷就是崩溃后无法安全恢复，在5.5版之后，MySQL就引入了InnoDB(事务性数据库引擎)&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux知识点总结</title>
    <link href="https://liangggggg.github.io/2020/08/29/linux/"/>
    <id>https://liangggggg.github.io/2020/08/29/linux/</id>
    <published>2020-08-29T00:20:59.000Z</published>
    <updated>2020-08-29T01:16:00.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux文件类型"><a href="#1-Linux文件类型" class="headerlink" title="1 Linux文件类型"></a>1 Linux文件类型</h1><p>Linux支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字等</p><ul><li>普通文件</li><li>目录文件(d, directory file)</li><li>符号链接文件(l, symbolic link)：保留了指向文件的地址而不是文件本身</li><li>字符设备(c, char)：用来访问字符设备比如硬盘</li><li>设备文件(b,block)：用来访问设备比如硬盘、软盘</li><li>管道文件(p,pipe)：用于进程之间的通信</li><li>套接字(s,socket)：进程间网络通信，也可以用于本机之间的非网络通信<a id="more"></a></li></ul><h1 id="2-Linux目录树"><a href="#2-Linux目录树" class="headerlink" title="2 Linux目录树"></a>2 Linux目录树</h1><p>Linux的目录结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/0C7AA0164FE549559D468081C86A2731?method=download&shareKey=f44a7c3f8e85e2be6d1b8beeb0d25216" alt></p><p>常用目录说明：</p><ul><li><code>/bin</code>：存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里</li><li><code>/etc</code>：存放系统管理和配置文件</li><li><code>/home</code>：存放所有用户文件的根目录，是用户目录的基点</li><li><code>/usr</code>：用于存放系统应用程序</li><li><code>/opt</code>：额外安装的可选应用程序包所放置的位置</li><li><code>/proc</code>：虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息</li><li><code>/root</code>：超级用户（系统管理员）的主目录</li><li><code>/sbin</code>：存放二进制可执行文件，只有root才能访问，系统级别的管理命令和程序</li><li><code>/dev</code>：用于存放设备文件</li><li><code>/mnt</code>：系统管理员安装临时文件系统的安装点</li><li><code>/boot</code>：存放用于系统引导时使用的各种文件</li><li><code>/lib</code>：存放着和系统运行相关的库文件</li><li><code>/tmp</code>：用于存放各种临时文件</li><li><code>/var</code>：用于存放运行时需要改变数据的文件，比如各服务的日志文件</li><li><code>/lost+found</code>：系统非正常关机而留下的文件</li></ul><h1 id="3-Linux基本命令"><a href="#3-Linux基本命令" class="headerlink" title="3 Linux基本命令"></a>3 Linux基本命令</h1><p>Linux 命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h2 id="3-1-目录切换命令"><a href="#3-1-目录切换命令" class="headerlink" title="3.1 目录切换命令"></a>3.1 目录切换命令</h2><ul><li><code>cd usr</code>：切换到该目录下的usr目录</li><li><code>cd ..</code>：切换到上一层目录</li><li><code>cd /</code>：切换到系统根目录</li><li><code>cd ~</code>：切换到用户主目录</li><li><code>cd -</code>：切换到上一个操作所在目录</li></ul><h2 id="3-2-目录的操作命令（增删改查）"><a href="#3-2-目录的操作命令（增删改查）" class="headerlink" title="3.2 目录的操作命令（增删改查）"></a>3.2 目录的操作命令（增删改查）</h2><ul><li><code>mkdir</code> 目录名称：增加目录</li><li><code>ls/ll（ll是 ls -l的别名，可以查看该目录下的所有目录文件的详细信息）</code>：查看目录信息</li><li><code>find 目录 参数</code>：找到目录</li><li><code>mv 目录：新目录名称</code>：修改目录的名称</li><li><code>mu 目录名称 新目录名称</code>：修改目录的位置（剪切）</li><li><code>cp -r 目录名称 目录拷贝的目标位置</code>：拷贝目录</li><li><code>rm [-rf] 目录</code>：目录删除</li></ul><h2 id="3-3-文件的操作命令"><a href="#3-3-文件的操作命令" class="headerlink" title="3.3 文件的操作命令"></a>3.3 文件的操作命令</h2><ul><li><code>touch 文件名称</code>：文件的创建</li><li><code>cat/more/less/tail 文件名称</code>：文件的查看</li><li><code>vim 文件</code>：修改文件的内容</li><li><code>rm -rf 文件</code>：删除文件</li></ul><h2 id="3-4-压缩文件的操作命令"><a href="#3-4-压缩文件的操作命令" class="headerlink" title="3.4 压缩文件的操作命令"></a>3.4 压缩文件的操作命令</h2><p>1）打开并压缩文件</p><p>Linux中的打包和压缩是一起进行的，打包并压缩文件的后缀名一般为<code>.tar.gz</code></p><ul><li><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></li></ul><p>其中：</p><ul><li>z：调用gzip压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>2）解压压缩包：</p><ul><li><code>tar [-xvf] 压缩文件</code></li></ul><p>其中：</p><ul><li>x：代表解压</li></ul><h2 id="3-5-Linux的权限命令"><a href="#3-5-Linux的权限命令" class="headerlink" title="3.5 Linux的权限命令"></a>3.5 Linux的权限命令</h2><p>linux中权限一般分为读(readable)、写(writable)、执行(excutable)三组。分别对应文件的属主(owner)、属组(group)和其他用户(other)</p><p>通过<code>ls -l</code>命令</p><p><img src="https://note.youdao.com/yws/api/personal/file/E17C3D4A7E5B4CD3B7097099277E7B70?method=download&shareKey=1d7ba2648463666978de2b54a718b3b0" alt></p><p>第一列的内容信息解释如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/3608EE6D1AAD49ABB8C7DB547871DEE1?method=download&shareKey=b86faced23e0328c128443cf66255de1" alt></p><p>文件的类型：</p><ul><li>d：目录</li><li>-：文件</li><li>l：软连接</li></ul><p>Linux中权限分为以下几种：</p><ul><li>r：可读</li><li>w：可写</li><li>x：可执行</li></ul><p>文件和目录权限的区别：</p><p>对文件和目录而言，读写执行表示不同的意义</p><p>对于文件：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以使用cat查看文件内容</td></tr><tr><td align="left">w</td><td align="right">可以修改文件内容</td></tr><tr><td align="left">x</td><td align="right">可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以查看目录下列表</td></tr><tr><td align="left">w</td><td align="right">可以创建和删除目录下文件</td></tr><tr><td align="left">x</td><td align="right">可以使用cd进入目录</td></tr></tbody></table><p>超级用户可以无视普通用户的权限</p><p>在Linux中的每一个用户必须属于一个组，不能独立于组外，在Linux中每个文件有所有者、所在组、其它组的概念</p><ul><li>所有者(u)：一般为文件的创建者，谁创建了该文件，就天然的称为该文件的所有者</li><li>文件所在组(g)：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</li><li>其他组(o)：除开文件的所有者和所在组用户外，系统的其他用户都是文件的其他组</li></ul><p>修改文件/目录的权限命令</p><ul><li>chmod</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/D0D5A242004E4058AB3D4D0AF2795B10?method=download&shareKey=84cd39dd258f0930b7bb7fdb91ddfea3" alt></p><h2 id="3-6-Linux用户管理"><a href="#3-6-Linux用户管理" class="headerlink" title="3.6 Linux用户管理"></a>3.6 Linux用户管理</h2><ul><li><code>useradd 选项 用户名</code>：添加用户账号</li><li><code>userdel 选项 用户名</code>：删除用户账号 </li><li><code>usermod 选项 用户名</code>：修改账号</li><li><code>passwd 用户名</code>：更改或创建用户的密码</li><li><code>passwd -S 用户名</code>：显示用户账号密码信息</li><li><code>passwd -d 用户名</code>：清除用户密码</li></ul><h2 id="3-7-系统用户组的管理"><a href="#3-7-系统用户组的管理" class="headerlink" title="3.7 系统用户组的管理"></a>3.7 系统用户组的管理</h2><ul><li><code>groupadd 选项 用户组</code>：添加一个新的用户组</li><li><code>groupedl 用户组</code>：要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code>：修改用户组的属性</li></ul><h2 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8 其他常用命令"></a>4.8 其他常用命令</h2><ul><li><code>pwd</code>：显示当前所在位置</li><li><code>sudo + 其他命令</code> ： 以系统管理者的身份执行命令</li><li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令， –color代表高亮显示</li><li><code>ps -ef/ps -aux</code>：查看当前系统正在运行进程</li><li><code>kill -9 进程的Pid</code>：杀死进程</li><li><code>shutdown</code>：关机</li><li><code>reboot</code>：重启</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Linux文件类型&quot;&gt;&lt;a href=&quot;#1-Linux文件类型&quot; class=&quot;headerlink&quot; title=&quot;1 Linux文件类型&quot;&gt;&lt;/a&gt;1 Linux文件类型&lt;/h1&gt;&lt;p&gt;Linux支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通文件&lt;/li&gt;
&lt;li&gt;目录文件(d, directory file)&lt;/li&gt;
&lt;li&gt;符号链接文件(l, symbolic link)：保留了指向文件的地址而不是文件本身&lt;/li&gt;
&lt;li&gt;字符设备(c, char)：用来访问字符设备比如硬盘&lt;/li&gt;
&lt;li&gt;设备文件(b,block)：用来访问设备比如硬盘、软盘&lt;/li&gt;
&lt;li&gt;管道文件(p,pipe)：用于进程之间的通信&lt;/li&gt;
&lt;li&gt;套接字(s,socket)：进程间网络通信，也可以用于本机之间的非网络通信&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://liangggggg.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://liangggggg.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（五）：输入输出管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os5/"/>
    <id>https://liangggggg.github.io/2020/08/28/os5/</id>
    <published>2020-08-28T15:12:59.000Z</published>
    <updated>2020-08-28T12:10:27.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO管理概述"><a href="#1-IO管理概述" class="headerlink" title="1 IO管理概述"></a>1 IO管理概述</h1><h2 id="1-1-IO设备"><a href="#1-1-IO设备" class="headerlink" title="1.1 IO设备"></a>1.1 IO设备</h2><p>IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。</p><a id="more"></a><p>计算机系统中的IO设备按使用特性可以分为一下类型：</p><ol><li><p>人机交互类外部设备，又称慢速IO设备，用于桶计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。</p></li><li><p>存储设备，用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。</p></li><li><p>网络通信设备，用于与远程设备通信的设备，如各种网络接口、调制解调器等。其数据交换速度介于外部设备与存储设备之间。网络通信设备在使用和管理上与前两者设备有很大的不同。</p></li></ol><h2 id="1-2-IO管理目标"><a href="#1-2-IO管理目标" class="headerlink" title="1.2 IO管理目标"></a>1.2 IO管理目标</h2><p>IO设备管理的主要目标有以下三个方面。</p><p>方便使用：方便用户使用外部设备，控制设备工作完成用户的输入输出要求。</p><p>提高效率：提高系统的并行工作能力，提高设备的使用效率。</p><p>方便控制：提高外围设备和系统的可靠性和安全性，以使系统能正常工作。</p><h2 id="1-3-IO管理功能"><a href="#1-3-IO管理功能" class="headerlink" title="1.3 IO管理功能"></a>1.3 IO管理功能</h2><p>IO设备管理的功能是按照输入输出子系统的结构和设备类型制定分配和使用设备的策略，主要包括：</p><p>设备的分配和回收。</p><p>外围设备的启动。</p><p>对磁盘的驱动调度。</p><p>外部设备中断处理。</p><p>虚拟设备的实现。</p><h2 id="1-4-IO应用接口"><a href="#1-4-IO应用接口" class="headerlink" title="1.4 IO应用接口"></a>1.4 IO应用接口</h2><p>划分IO设备所属的通用类型的依据：</p><ul><li><p>字符设备还是块设备。</p></li><li><p>顺序访问还是随机访问。</p></li><li><p>IO传输是同步还是异步。</p></li><li><p>共享设备还是独占设备。</p></li><li><p>操作速度的高低。</p></li><li><p>访问模式是读写、只读还是只写。</p></li></ul><h2 id="1-5-设备控制器"><a href="#1-5-设备控制器" class="headerlink" title="1.5 设备控制器"></a>1.5 设备控制器</h2><p>设备控制器的主要功能为：</p><ul><li><p>接收和识别CPU或通道发来的命令，如磁盘控制器能就收读、写、查找、搜索等命令。</p></li><li><p>实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。</p></li><li><p>发现和记录设备及自身的状态信息，供CPU处理使用。</p></li><li><p>设备地址识别。</p></li></ul><h2 id="1-6-IO控制方式"><a href="#1-6-IO控制方式" class="headerlink" title="1.6 IO控制方式"></a>1.6 IO控制方式</h2><p>中断驱动方式中，CPU仍然需要主动处理在存储器和IO设备之间的数据传送，所以速度还是受限，而直接内存存取（DMA）方式的基本思想是在外围设备和内存之间开辟直接的数据交换通路，彻底解放CPU。该方式的特点是：</p><ul><li><p>基本单位是数据块。</p></li><li><p>所传诵的数据，是从设备直接送入内存的，或者相反。</p></li><li><p>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p></li></ul><p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p><ul><li><p>命令/状态寄存器（CR）。用于接收从CPU发来的IO命令或有关控制信息，或设备的状态。</p></li><li><p>内存地址寄存器（MAR）。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</p></li><li><p>数据寄存器（DR）。用于暂存从设备到内存或从内存到设备的数据。</p></li><li><p>数据计数器（DC）。存放本次CPU要读或写的字节数。</p></li></ul><p>DMA的工作过程是：CPU读写数据时，他给IO控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把这个操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此，只有在传送开始和结束时才需要CPU的参与。</p><h1 id="2-IO核心子系统"><a href="#2-IO核心子系统" class="headerlink" title="2 IO核心子系统"></a>2 IO核心子系统</h1><h2 id="2-1-IO层次结构"><a href="#2-1-IO层次结构" class="headerlink" title="2.1 IO层次结构"></a>2.1 IO层次结构</h2><p>一个比较合理的层次划分为四个层次的系统结构，各层次及其功能如下：</p><ol><li><p>用户层IO软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与IO操作有关的库函数，对设备进行操作。</p></li><li><p>设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p></li><li><p>设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。</p></li><li><p>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并回复被中断进程的现场后，返回到被中断进程。</p></li></ol><h2 id="2-2-IO调度概念"><a href="#2-2-IO调度概念" class="headerlink" title="2.2 IO调度概念"></a>2.2 IO调度概念</h2><p>调度一组IO请求就是确定确定一个好的顺序来执行这些请求。应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要调度来改善系统整体性能，是进程之间公平的共享设备访问，减少IO完成所需要的平均等待时间。</p><p>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞IO系统调用时，该请求就加到相应设备的队列上。IO调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。</p><p>IO子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等。</p><h2 id="2-3-高速缓存与缓冲区"><a href="#2-3-高速缓存与缓冲区" class="headerlink" title="2.3 高速缓存与缓冲区"></a>2.3 高速缓存与缓冲区</h2><p>在设备管理子系统中，引入缓冲区的目的有：</p><ol><li><p>缓和CPU与IO 设备间速度不匹配的矛盾。</p></li><li><p>减少对CPU的中断频率，放宽对CPU 中断响应时间的限制。</p></li><li><p>解决基本数据单元大小不匹配的问题。</p></li><li><p>提高CPU和IO设备之间的并行性。</p></li></ol><h2 id="2-4-设备的分配与回收"><a href="#2-4-设备的分配与回收" class="headerlink" title="2.4 设备的分配与回收"></a>2.4 设备的分配与回收</h2><p>设备分配的基本任务是根据用户的IO请求，为他们分配所需的设备。设备分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类。</p><h2 id="2-5-假脱机技术"><a href="#2-5-假脱机技术" class="headerlink" title="2.5 假脱机技术"></a>2.5 假脱机技术</h2><p>为了缓和CPU的高速型与IO设备低速性之间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速IO设备上的数据传送到高速磁盘上；或者相反。SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO管理概述&quot;&gt;&lt;a href=&quot;#1-IO管理概述&quot; class=&quot;headerlink&quot; title=&quot;1 IO管理概述&quot;&gt;&lt;/a&gt;1 IO管理概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-IO设备&quot;&gt;&lt;a href=&quot;#1-1-IO设备&quot; class=&quot;headerlink&quot; title=&quot;1.1 IO设备&quot;&gt;&lt;/a&gt;1.1 IO设备&lt;/h2&gt;&lt;p&gt;IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（四）：文件系统</title>
    <link href="https://liangggggg.github.io/2020/08/28/os4/"/>
    <id>https://liangggggg.github.io/2020/08/28/os4/</id>
    <published>2020-08-28T14:12:59.000Z</published>
    <updated>2020-08-28T12:10:16.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件系统基础"><a href="#1-文件系统基础" class="headerlink" title="1 文件系统基础"></a>1 文件系统基础</h1><h2 id="1-1-文件的概念"><a href="#1-1-文件的概念" class="headerlink" title="1.1 文件的概念"></a>1.1 文件的概念</h2><p>文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。</p><a id="more"></a><p>用户通过文件系统建立文件，提供应用程序的输入输出，对资源进行管理。首先了解文件的结构，我们通过自底向上的方式来定义。</p><ol><li>数据项：数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：基本数据项和组合数据项</li><li>记录：记录是一组相关的数据项集合，用于描述一个对象在某方面的属性</li><li>文件：文件是指由穿件这所定义的一组相关信息的集合，可分为有结构文件和无结构文件两种。</li></ol><p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：</p><ul><li>名称</li><li>标识符</li><li>类型</li><li>位置</li><li>大小</li><li>保护</li><li>时间、日期和用户标识</li></ul><p>文件属于抽象数据类型。为了恰当的定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，他对文件进行创建、写、读、定位和截断。</p><p>每个打开文件都有如下关联信息：</p><ul><li>文件指针</li><li>文件打开计数</li><li>文件磁盘位置</li><li>访问权限</li></ul><h2 id="1-2-文件的逻辑结构"><a href="#1-2-文件的逻辑结构" class="headerlink" title="1.2 文件的逻辑结构"></a>1.2 文件的逻辑结构</h2><p>按逻辑结构，文件有无结构文件和有结构文件两种类型：</p><ol><li>顺序文件</li><li>索引文件</li><li>索引顺序表</li><li>直接文件或散列文件</li></ol><h1 id="1-3-目录结构"><a href="#1-3-目录结构" class="headerlink" title="1.3 目录结构"></a>1.3 目录结构</h1><p>与文件管理系统和文件集合相关联的是文件目录，它包含有文件的信息，包括属性、位置和所有权等，这些信息都由操作系统进行管理。首先我们来看目录管理的基本要求 ：从用户的角度看，目录在用户所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在共享系统中，目录还需要提供用于控制访问文件的信息。此外，文件允许重名也是用户的合理和必然要求，目录管理通过树形结构来解决和实现。</p><h1 id="1-4-文件共享"><a href="#1-4-文件共享" class="headerlink" title="1.4 文件共享"></a>1.4 文件共享</h1><p>文件共享十多个用户进程共享同一份文件，系统中只需保留该文件的一份副本。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。</p><p>随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过c/s模型共享网络中的服务器文件。</p><h1 id="1-5-文件保护"><a href="#1-5-文件保护" class="headerlink" title="1.5 文件保护"></a>1.5 文件保护</h1><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p><p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了方式用户文件被他人存取或盗取，而访问控制则用于控制用户对文件的访问方式。</p><p>对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：</p><ul><li><p>读：从文件中读。</p></li><li><p>写：向文件中写。</p></li><li><p>执行：将文件装入内存并执行。</p></li><li><p>添加：将信息添加到文件结尾部分。</p></li><li><p>删除：删除文件，释放空间。</p></li><li><p>列表清单：列出文件名和文件属性。</p></li></ul><h1 id="2-文件系统实现"><a href="#2-文件系统实现" class="headerlink" title="2 文件系统实现"></a>2 文件系统实现</h1><h2 id="2-1-文件系统层次结构"><a href="#2-1-文件系统层次结构" class="headerlink" title="2.1 文件系统层次结构"></a>2.1 文件系统层次结构</h2><p>现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。</p><p>文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。</p><h2 id="2-2-目录实现"><a href="#2-2-目录实现" class="headerlink" title="2.2 目录实现"></a>2.2 目录实现</h2><p>在读文件前，必须先打开文件。打开文件时，操作系统利用路径名吵到相应目录项，目录项中提供了查找文件磁盘块所需要的信息，目录实现的基本方法有线性列表和哈希表两种方法。</p><h2 id="2-3-文件实现"><a href="#2-3-文件实现" class="headerlink" title="2.3 文件实现"></a>2.3 文件实现</h2><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方式有三种：连续分配、链接分配和索引分配。有的系统对三种方式都支持，但是更普遍的是一个系统只提供一种方法支持。</p><h1 id="3-磁盘组织与管理"><a href="#3-磁盘组织与管理" class="headerlink" title="3 磁盘组织与管理"></a>3 磁盘组织与管理</h1><h2 id="3-1-磁盘的结构"><a href="#3-1-磁盘的结构" class="headerlink" title="3.1 磁盘的结构"></a>3.1 磁盘的结构</h2><p>磁盘是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称谓磁头的到体系安全从磁盘中存取数据。在读写操作期间，磁头固定，磁盘在下面高速旋转。</p><h2 id="3-2-磁盘调度算法"><a href="#3-2-磁盘调度算法" class="headerlink" title="3.2 磁盘调度算法"></a>3.2 磁盘调度算法</h2><p>1、先来先服务（FCFS）算法</p><p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度处理，这是一种最简单的调度算法。这种算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则会达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往低于随即调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。</p><p>2、最短寻找时间优先（SSTF）算法</p><p>SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，一是每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能。这种算法会产生饥饿现象</p><p>3、扫描（SCAN）算法</p><p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最扫描过的区域不公平，因此，他在访问局部性方面不如FCFS算法和SSTF算法好。</p><p>4、循环扫描算法（C-SCAN）</p><p>在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p><h2 id="3-3-磁盘的管理"><a href="#3-3-磁盘的管理" class="headerlink" title="3.3 磁盘的管理"></a>3.3 磁盘的管理</h2><p>了使用磁盘存储文件。操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为一个或多个柱面组成分区；低而不对物理分区进行逻辑格式化，操作系统将出师的文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-文件系统基础&quot;&gt;&lt;a href=&quot;#1-文件系统基础&quot; class=&quot;headerlink&quot; title=&quot;1 文件系统基础&quot;&gt;&lt;/a&gt;1 文件系统基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-文件的概念&quot;&gt;&lt;a href=&quot;#1-1-文件的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件的概念&quot;&gt;&lt;/a&gt;1.1 文件的概念&lt;/h2&gt;&lt;p&gt;文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（三）：内存管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os3/"/>
    <id>https://liangggggg.github.io/2020/08/28/os3/</id>
    <published>2020-08-28T12:12:59.000Z</published>
    <updated>2020-08-31T05:24:16.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-内存管理基础"><a href="#1-内存管理基础" class="headerlink" title="1 内存管理基础"></a>1 内存管理基础</h1><h2 id="1-1-内存管理的概念"><a href="#1-1-内存管理的概念" class="headerlink" title="1.1 内存管理的概念"></a>1.1 内存管理的概念</h2><p>内存管理是操作系统设计中最重要和最复杂的内容之一，内存管理的功能有：</p><ol><li>内存空间的分配与回收，包括分配与共享</li><li>地址转换，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存</li><li>内存保护，保证各道作业在各自存储空间内运行，互不干扰</li></ol><a id="more"></a><p>创建进程首先要将程序和数据装入内存，将用户原程序编程可在内存中执行的程序，通常需要以下几个步骤</p><ol><li>编译，由编译程序将用户源代码编译成若干个目标模块</li><li>链接，由链接程序将编译后形成一组目标模块</li><li>装入，由装入程序将装入模块装入内存</li></ol><p>程序的连接有以下三种方式</p><ol><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完成的可执行程序，以后不再拆开</li><li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，再装入内存时，采用边装入边链接方式</li><li>运行时动态链接：对某些目标模块的连接，是在程序执行中需要该目标模块时，才进行链接，其优点是便于修改和更新</li></ol><p>装入内存时，同样有以下三种方式：</p><ol><li>绝对装入：在编译时，产生绝对地址的目标代码</li><li>可重定位装入：在多道程序环境下，多个目标目标的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的</li><li>动态运行时装入：程序在内存中发生移动，需要采用动态装入方式，地址转换推迟到程序真正要执行时才进行，装入内存后的所有地址都仍是相对地址</li></ol><h2 id="1-2-覆盖与交换"><a href="#1-2-覆盖与交换" class="headerlink" title="1.2 覆盖与交换"></a>1.2 覆盖与交换</h2><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法</p><p>覆盖的基本思想：</p><p>由于程序运行时并非任何时候都要访问程序和数据的各个部分，因此可以把用户控件分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定区，其余部分按照调用关系分段</p><p>交换的基本思想：</p><p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的进程从内存移到辅存，把内存空间腾出来，把准备好竞争CPU运行的进程从辅存移到内存</p><p>有关交换需要注意以下问题：</p><ul><li>交换需要备份存储</li><li>为了有效使用CPU，需要每个进程的执行时间比交换时间长</li><li>如果换出进程，必须确保该进程是完全处于空闲状态</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常有许多进程运行且内存空间吃紧的时候开始启动</li><li>普通的交换使用不多，但交换策略的某些变种在许多系统中仍发挥作用</li></ul><h2 id="1-3-连续分配管理方式"><a href="#1-3-连续分配管理方式" class="headerlink" title="1.3 连续分配管理方式"></a>1.3 连续分配管理方式</h2><p>连续分配，是指为一个用户程序分配一个连续的内存空间，主要包括单一连续分配、固定分区分配和动态分区分配</p><p>内存在此方式下分为系统区和用户区</p><p>固定分区分配是最简单的一种多道程序储存管理方式，将内存划分为若干个固定大小的区域，每个分区只装入一道作业</p><p>固定分区分配在划分分区时，有两种不同的方法</p><ol><li>分区大小相等</li><li>分区大小不等</li></ol><p>固定分区不能实现多进程共享一个主存区，空间利用率低</p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好合适进程的需要，但是随着时间的推移，内存中会产生越来越多的碎片</p><p>动态分区的分配策略，可以考虑以下几种算法：</p><ol><li>首次适应算法：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区</li><li>最佳适应算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区</li><li>最坏适应算法：空闲分区以容量递减次序链接，找到第一个能满足要求的空闲分区</li><li>临近适应算法：由首次适应算法演变而成，不同之处是分配内存时从查找结束的位置开始继续查找</li></ol><p>首次适应被认为最好、最快，其次是循环，最佳最差（每次分配后剩下小碎片，难再分）</p><p>可重定位分区分配：允许在主存中移动，将小内存拼接在一起</p><h2 id="1-4-非连续分配管理方式"><a href="#1-4-非连续分配管理方式" class="headerlink" title="1.4 非连续分配管理方式"></a>1.4 非连续分配管理方式</h2><p>非连续分配允许一个程序分散的装入不相邻的内存分区中，根据分区的大小是否固定为分页存储管理方式和分段存储管理方式</p><p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本页存储管理和请求页存储管理方式</p><p>1、分页存储的几个基本概念</p><ul><li>页面和页面大小：进程中的块称为页，内存中的块称为页框。外存也以同样单位划分，直接称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</li><li>地址变换机构：分页存储管理的地质结构包含两部分：前一部分为页号，后一部分为页内偏移量</li><li>页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</li><li>分页：把用户程序按逻辑页划分成大小相等的部分，称为页或虚页。从0开始编制页号，页内地址是相对于0编址</li><li>主存分配：把用户程序的任一页，可以分配到内存中的任一物理块，从而实现非连续内存分配</li></ul><p>2、基本地址变换机构</p><p>实现从逻辑地址到物理地址的转换，将逻辑地址中页号转换为内存中的物理块号，通过页表是实现，页表大多贮存在内存中</p><p>当进程要访问某个进程的逻辑地中的数据时，分为页号和页内地址两部分，如果超过页表长度则发生越界中断</p><p>3、具有快表的地址变换机构</p><p>命中率，是指使用块表并在其中成功查找到所需页面的表项的比率</p><p>4、两级和多级页表</p><p>将页表分页，并离散地将各个页面分别存放在不同的物理块中，同样要为离散分配的页表再建立一张页表，称为外层页表</p><p>对于32位机器，采用两级页表是合适的，但对于64位机器必须采用多级页表，将外层页再进行分页，也是将各分页离散地装入到不相接的物理地址中</p><h1 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2 虚拟内存"></a>2 虚拟内存</h1><h2 id="2-1-虚拟内存的基本概念"><a href="#2-1-虚拟内存的基本概念" class="headerlink" title="2.1 虚拟内存的基本概念"></a>2.1 虚拟内存的基本概念</h2><p>内存管理策略有两个共同特质：</p><ol><li>一次性：作业必须一次全部装入内存后，方可运行</li><li>驻留性：作业被装入内存后，就一直驻留在内存中</li></ol><p>局部性原理表现在以下两个方面：</p><ol><li><p>时间局部性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p></li><li><p>空间局部性。一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p></li></ol><p>时间局部性是通过将进来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。</p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行，这样，计算机好像为用户提供了一个比实际内存大得多的储存器，称为虚拟储存器，主要有以下三个主要特征：</p><ol><li>多次性：无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性：无需作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出</li><li>虚拟性：逻辑上扩充内存的容量</li></ol><p>虚拟存储器具有请求调入功能和置换功能，逻辑容量由内存容量和外存容量之和决定</p><p>虚拟内存建立在离散分配的内存管理方式的基础上，有以下三种方式</p><ol><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ol><p>不管哪种方式，都需要有一定的硬件支持</p><ol><li>一定的内存和外存</li><li>页表机制或段表机制</li><li>中断机构</li><li>地址变换机构</li></ol><h2 id="2-2-请求分页管理方式"><a href="#2-2-请求分页管理方式" class="headerlink" title="2.2 请求分页管理方式"></a>2.2 请求分页管理方式</h2><p>请求分页系统建立在基本分页系统基础上，为了支持寻你存储器功能而增肌阿勒请求分页功能和页面置换功能</p><h2 id="2-3-页面置换算法"><a href="#2-3-页面置换算法" class="headerlink" title="2.3 页面置换算法"></a>2.3 页面置换算法</h2><p>进程运行时，若访问的页面不在内存，需要将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘兑换区，常见的置换算法有以下四种：</p><ol><li>最佳置换算法</li><li>先进先出页面置换算法</li><li>最近最久未使用置换算法</li><li>最少使用置换算法</li></ol><h2 id="2-4-页面分配策略"><a href="#2-4-页面分配策略" class="headerlink" title="2.4 页面分配策略"></a>2.4 页面分配策略</h2><p>给特定的进程分配多大的主存空间，需要考虑以下几点：</p><ol><li>分配给一个进程的存储量越小，在任何时候驻留在主存的进程数越多，可以提高处理器的时间利用率</li><li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高</li><li>如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</li></ol><p>基于这些因素，现代操作系统通常采用三种策略：</p><ol><li>固定分配局部置换：它为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发现缺页，则只能从该进程在内存的页面中选出一个换出，然后再调入需要的页面。</li><li>可变分配全局置换：这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数量的物理块，操作系统自身也保持一个空闲物理块队列。当某进程发现缺页时，系统从空闲物理块队列中取出物理块分配给该进程，并将于调入的页装入其中。</li><li>可变分配局部置换：它为每个进程分配一定数目的物理块，当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁的换页，系统需再为该进程分配若干附加物理块，直至该进程缺页率趋于适当程度为止；反之，若一个进程在运行过程中缺页率特别低，则此时可适当减少该进程的物理块。</li></ol><p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：</p><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页可能比一次调入一页更高效。但如果调入的一批页面中大厦多数都未被访问，则又是低效的。所以就需要采用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。股这种策略主要用于进程的首次调入时，有程序员指出应该先调入哪些页。</li><li>请求调页策略：进程在运行中需要访问的页面不在内存而提出的请求，由系统将所需页面调入内存。这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。它的缺点在于每次调入一页，会花费过多的IO开销。</li><li>从何处调入页面。请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘IO速度比文件区高。这里从何处调入页面有三种情况</li></ol><h2 id="2-5-抖动和工作集"><a href="#2-5-抖动和工作集" class="headerlink" title="2.5 抖动和工作集"></a>2.5 抖动和工作集</h2><p>在进程的页面置换过程中，频繁的页面调度行为成为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>使用虚拟内存技术，操作系统中进程通常只有一部分块位于主存中，从而可以在内存中保留更多的进程以提高系统效率。此外，由于未用到的块不需要换入换出内存，因为节省了时间。但是系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被禁成块占据，处理器和操作系统可以直接访问到尽可能多的进程。但如果管理不当，系统发生抖动现象，处理器的大部分时间都将用于交换快，及请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。前面讲解的页面置换算法就是是讨论这里的分配方案，尽量避免抖动现象。</p><p>另外，为了防止出现抖动现象，需要选择合适的驻留集大小。驻留集（或工作集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。驻留集模型使用较为简单：操作系统跟踪每个进程的驻留集，并为进程分配大于驻留集的的空间。如果还有空闲，那么可启动另一个进程。如果所有驻留集之和增加一直超过了可用物理块啊的总数，那么系统会怎听一个进程，将其页面调出并且将其物理块分配给其他进程。</p><p>正确选择驻留集的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。</p><h2 id="2-6-请求分段管理方式"><a href="#2-6-请求分段管理方式" class="headerlink" title="2.6 请求分段管理方式"></a>2.6 请求分段管理方式</h2><p>请求分段存储管理系统已基本短时存储管理为基础，为用户提供一个比主存容量更大的虚拟存储器。作业的若干分段别放入内存，就可以开始作业运行，作业的其他部分被放在外存中，等到需要的时候才被调入内存。</p><ul><li>分段：作业的地址空间被分成若干个段，每个段定义了一组逻辑信息</li><li>段表：每个进程建立一张映射表，每个段表中占一个表项，其中记录了该段内存地址信息</li></ul><p>分页和分段的主要区分</p><ol><li>页式信息的物理单位，段是信息的逻辑单位</li><li>页的大小固定且由系统决定，段的长度不固定取决于用户编程</li><li>分页的作业地址空间是一维的，分段的作业地址空间是二维的</li></ol><h2 id="2-7-请求段页式管理方式"><a href="#2-7-请求段页式管理方式" class="headerlink" title="2.7 请求段页式管理方式"></a>2.7 请求段页式管理方式</h2><p>请求段页式管理方式只要求将作业若干页或段装入内存就可以开始运行作业，作业的其他部分别放在外存中，等待运行需要的时候才被调入内存，</p><p>请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</p><h1 id="3-常见面试题总结"><a href="#3-常见面试题总结" class="headerlink" title="3 常见面试题总结"></a>3 常见面试题总结</h1><h2 id="3-1-内存管理介绍"><a href="#3-1-内存管理介绍" class="headerlink" title="3.1 内存管理介绍"></a>3.1 内存管理介绍</h2><p>操作系统的内存管理主要负责内存的分配与回收，另外地址转换也就是将逻辑地址转换成相应的物理地址等功能</p><h2 id="3-2-操作系统的内存管理机制"><a href="#3-2-操作系统的内存管理机制" class="headerlink" title="3.2 操作系统的内存管理机制"></a>3.2 操作系统的内存管理机制</h2><p>简单分配连续分配管理方式和非连续管理分配方式，连续分配管理方式是指为了一个用户程序分配一个连续的内存空间，常见的块管理，非连续分配管理方式允许一个程序使用的内存分布在离散或不相邻的内存中，常见的页式管理和段式管理</p><ol><li>块管理：远古时代的计算机操作系统的内存管理方式，将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间称为碎片</li><li>页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对比较于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表和对应逻辑地址和物理地址</li><li>段式管理：每一段定义了一组逻辑信息，通过管理段表对应逻辑地址和物理地址。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。</li></ol><h2 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h2><p>分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快</li><li>解决页表占用空间大</li></ol><p><strong>快表</strong></p><p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础上引入了快表来加速虚拟地址到物理地址的转换，我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容，作为页表的Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时CPU要访问两次主存，有了快表，有时只要访问一次告诉缓冲存储器，一次主存，这样可加快查找速度并提高指令速度</p><p>使用快表之后的地址转换流程是这样的:</p><ol><li>根据虚拟地址中的页号查找表</li><li>如果该页在快表中，直接从快表中读取相应的物理地址</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射添加到快表中</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页</li></ol><p><strong>多级页表</strong></p><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p><h2 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="3.4 分页机制和分段机制的共同点和区别"></a>3.4 分页机制和分段机制的共同点和区别</h2><p>1.共同点</p><ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式，但是每个页和段中的内存时连续的</li></ul><p>2.区别：</p><ul><li>页的大小是固定的，有操作系统决定；段的大小不是固定的，取决于我们当前运行的程序</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能更好满足用户的需求</li></ul><h2 id="3-5-虚拟地址和物理地址"><a href="#3-5-虚拟地址和物理地址" class="headerlink" title="3.5 虚拟地址和物理地址"></a>3.5 虚拟地址和物理地址</h2><p>逻辑地址由操作系统决定，物理地址是指内存地址寄存器的地址，是内存单元真正的地址</p><h2 id="3-6-CPU寻址与虚拟地址空间"><a href="#3-6-CPU寻址与虚拟地址空间" class="headerlink" title="3.6 CPU寻址与虚拟地址空间"></a>3.6 CPU寻址与虚拟地址空间</h2><p>现在处理器使用的一种称为虚拟寻址的寻址方式，使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址的硬件CPU中含有一个被称为内存管理单元的硬件</p><p>为什么要有虚拟地址空间？</p><p>如果没有虚拟地址空间，程序都是直接访问和操作物理内存，容易造成以下问题：</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样很容易破坏操作系统，造成操作系统崩溃</li><li>想要同时运行多个程序特别苦难</li></ol><p>通过虚拟地址访问内存有以下几个优势：</p><ol><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘。</li><li>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存</li></ol><h2 id="3-7-局部性原理"><a href="#3-7-局部性原理" class="headerlink" title="3.7 局部性原理"></a>3.7 局部性原理</h2><p>局部性原理主要表现在以下两个方面：</p><ol><li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因是由于程序中存在着大量的循环操作</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间锁访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组等形式存储的</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h2 id="3-8-虚拟存储器"><a href="#3-8-虚拟存储器" class="headerlink" title="3.8 虚拟存储器"></a>3.8 虚拟存储器</h2><p>基于局部性原理，在程序装入时，可将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行，由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上可以比计算机实际的内存大。在程序执行过程中，当访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放要将调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器————虚拟存储器</p><p>实际上是一种时间换空间的策略</p><h2 id="3-9-虚拟内存的技术实现"><a href="#3-9-虚拟内存的技术实现" class="headerlink" title="3.9 虚拟内存的技术实现"></a>3.9 虚拟内存的技术实现</h2><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</p><ol><li>请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。加入在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不同的页面置换到外存中</li><li>请求分段存储管理：建立在分段存储管理之上，增加了请求掉段功能，分段置换功能。请求分段存储管理方式就如同请求分页存储管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断状态装入要访问但又不在内存的程序段，当内存空间已满，又要装入新的段时，根据置换功能调出某个段，以便腾出空间而装入新的段</li><li>请求段页式存储管理：请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</li></ol><p><strong>请求分页与分页存储管理的区别</strong></p><p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h2 id="3-10-页面置换算法"><a href="#3-10-页面置换算法" class="headerlink" title="3.10 页面置换算法"></a>3.10 页面置换算法</h2><ul><li>OPT页面置换算法（最佳页面置换算法）：最佳置换算法所选择的被淘汰页面将式以后永不使用的，或者是在最长时间内部再被访问的页面，但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间不再被访问的，因而该算法无法实现</li><li>FIFO页面置换算法（先进先出页面置换算法）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰</li><li>LRU（最近最久未使用页面置换算法）：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当必须淘汰一个页面时，选择T值最大的，即最近最久未使用的页面予以淘汰</li><li>LFU（最少使用页面置换算法）：使用之前使用最少的页面最为淘汰页面</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-内存管理基础&quot;&gt;&lt;a href=&quot;#1-内存管理基础&quot; class=&quot;headerlink&quot; title=&quot;1 内存管理基础&quot;&gt;&lt;/a&gt;1 内存管理基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-内存管理的概念&quot;&gt;&lt;a href=&quot;#1-1-内存管理的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 内存管理的概念&quot;&gt;&lt;/a&gt;1.1 内存管理的概念&lt;/h2&gt;&lt;p&gt;内存管理是操作系统设计中最重要和最复杂的内容之一，内存管理的功能有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存空间的分配与回收，包括分配与共享&lt;/li&gt;
&lt;li&gt;地址转换，把逻辑地址转换成相应的物理地址&lt;/li&gt;
&lt;li&gt;内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存&lt;/li&gt;
&lt;li&gt;内存保护，保证各道作业在各自存储空间内运行，互不干扰&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（二）：进程管理</title>
    <link href="https://liangggggg.github.io/2020/08/28/os2/"/>
    <id>https://liangggggg.github.io/2020/08/28/os2/</id>
    <published>2020-08-28T11:12:59.000Z</published>
    <updated>2020-08-30T14:18:26.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h1><h2 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h2><p>（1）进程的概念</p><p>从不同的角度，进程可以由不同的定义：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理器上顺序执行时发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</li></ol><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><a id="more"></a><p>（2）进程的特征</p><ol><li>动态性：他有着创建、活动、暂停、终止过程</li><li>并发性：多个进程实体，同存于内存中，能在一段时间内同时运行</li><li>独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li><li>异步性：由于进程的相互制约，是进程具有执行的间断性</li><li>结构性：进程实体是由程序段、数据段和进程控制段三部分组成</li></ol><h2 id="1-2-进程的状态和转换"><a href="#1-2-进程的状态和转换" class="headerlink" title="1.2 进程的状态和转换"></a>1.2 进程的状态和转换</h2><ol><li>运行状态</li><li>就绪状态：准备运行的状态</li><li>阻塞状态：等待状态，等待某一时间而暂停运行</li><li>创建状态：进程正在被创建，尚未转到就绪状态</li><li>结束状态</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/6D5D188BA55446DFB84D2D1071280B51?method=download&shareKey=c78907ea956c694fbab1ef69a75a8d42" alt></p><h2 id="1-3-进程控制"><a href="#1-3-进程控制" class="headerlink" title="1.3 进程控制"></a>1.3 进程控制</h2><p>在操作系统中，一般把进程控制用的程序段称为原语:由若干条指令构成的院子操作，作为一个整体不可分割，要么全都做，要么全部做</p><p>允许一个进程创建另一个进程</p><p>创建一个新进程的过程如下</p><ol><li>为新进程分配一个唯一进程标示号，申请一个空白PCB</li><li>为进程分配资源</li><li>初始化PCB，主要包括初始化标识信息，初始化处理器状态信息和初始化处理器控制信息</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行</li></ol><p>终止进程的过程如下：</p><ol><li>根据终止进程标识符，检索PCB，从中读出该进程的状态</li><li>若被终止进程处于执行状态，立即终止进程的执行，将处理器资源分配给其他进程</li><li>若该进程还有子进程，则应将其所有子进程终止</li><li>将该进程拥有所有资源返还给操作系统</li><li>将该PCB从所在队列中删除</li></ol><p>进程的阻塞如下：</p><ol><li>找到将要被阻塞的标示号对应PCB，如果该进程为运行状态，则保护线程，将其状态改为阻塞状态，停止运行</li><li>若为就绪状态，则将其状态改为阻塞状态，把它溢出就绪队列，插入等待队列</li></ol><p><strong>进程的阻塞是进程自身的一种主动行为</strong></p><p>进程唤醒如下：</p><ol><li>在改时间的等待队列中找到相应进程的PCB，然后把该PCB插入到就绪队列中，等待调度程序调度</li></ol><p>进程切换过程如下：</p><ol><li>保存处理器上下文</li><li>更新PCB信息</li><li>把PCB移入相应队列</li><li>选择另一个进程执行</li><li>恢复处理器上下文</li></ol><h1 id="1-4-进程的组织"><a href="#1-4-进程的组织" class="headerlink" title="1.4 进程的组织"></a>1.4 进程的组织</h1><p>PCB主要包括：进程描述信息、进程控制和管理信息、资源分配清淡和处理器相关信息等</p><p>放了方便进程调度和管理，需要将各进程的PCB用适当的方法组织起来，目前常用的组织方式有连接方式和索引方式两种。连接方式将同一状态的PCB连接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项只想相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p><h1 id="1-5-进程的通信"><a href="#1-5-进程的通信" class="headerlink" title="1.5 进程的通信"></a>1.5 进程的通信</h1><p>（1）共享存储</p><p>在通信的进程之间存在着一款可以直接访问的共享空间，通过对这块共享空间的读写操作时间进程之间的信息交换。</p><p>（2）消息传递</p><p>进程之间的数据交换，是以格式化的消息为单位，在计算机网络中，又称为报文</p><p>（3）管道通信</p><p>管道是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件</p><ul><li>互斥，即当一个进程执行读写操作，其它进程必须等待</li><li>同步</li></ul><h1 id="1-6-线程概念和多线程模型"><a href="#1-6-线程概念和多线程模型" class="headerlink" title="1.6 线程概念和多线程模型"></a>1.6 线程概念和多线程模型</h1><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单元，线程是进程中的一个实体，是被系统独立调度和分配的基本单位</p><p>（1）线程和进程的比较</p><ol><li>调度：线程是独立调度的基本单位，进程是资源拥有的基本单位</li><li>拥有资源：进程是拥有资源的基本单位，而线程只拥有必不可少的资源</li><li>并发性：进程和线程都有并发性，一个进程间的多个线程可并发</li><li>系统开销：线程的开销极小</li><li>地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程共享进程的资源</li><li>通信方面：进程需要保证数据的一致性，而线程可以直接读写进程数据段来进行通信</li></ol><p>（2）线程的属性</p><ol><li>线程是一个轻型实体，只拥有必不可少的资源</li><li>不同的线程可以执行相同的程序</li><li>同一进程中的各个线程共享该进程所有用的系统资源</li><li>线程是处理器的独立调度单位，多个线程是可以并发执行的</li><li>一个线程创建后开始了声明周期，直至终止，会经历等待态、就绪态和运行态</li></ol><p>（3）线程的实现方法</p><p>线程的实现可分为两类：用户级线程和内核级线程</p><ul><li>用户级线程速度快，不用调用核心，但若核心阻塞进程，则进程中所有线程都被阻塞，同一进程中的两个线程不能同时运行于两个处理器上</li></ul><p>（4）多线程模型</p><ol><li>多对一模型：多个用户级线程映射到一个内核级线程</li><li>一对一模型</li><li>多对多模型</li></ol><h1 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2 线程的调度"></a>2 线程的调度</h1><h2 id="2-1-调度的概念"><a href="#2-1-调度的概念" class="headerlink" title="2.1 调度的概念"></a>2.1 调度的概念</h2><p>作业时用户在一次解题或事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据命令等</p><p>一个作业从提交开始直到完成，要经历以下三级调度</p><p>1、作业调度</p><p>作业调度又称高级调度，按照一定原则挑选一个或多个作业，分配内存、输入输出设备等必要资源，并建立相应的进程</p><p>2、中级调度</p><p>又称为内存调度，为了提高内存利用率和系统吞吐率</p><p>3、进程调度</p><p>又称为低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理器分配给它</p><h2 id="2-2-调度的时机、切换与过程"><a href="#2-2-调度的时机、切换与过程" class="headerlink" title="2.2 调度的时机、切换与过程"></a>2.2 调度的时机、切换与过程</h2><p>不能进行进程的调度与切换的情况有以下几种</p><p>1、处理中断过程中：中断处理是系统工作的一部分，逻辑上不属于某一进程</p><p>2、进程在操作系统内存程序临界区中</p><p>3、其他需要完全屏蔽中断的院子操作过程：如加锁、解锁、中断现场保护、恢复等</p><p>如果在上述过程中引发了调度的条件，并不能马上进行调度和切换，系统请求调度标志，上述过程结束后才能进行相应的调度</p><p>应当进行进程调度与切换的情况有</p><p>1、当发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换</p><p>2、当中断处理结束后或自陷处理结束后</p><p>进程切换往往在调度完成后立即发生</p><h2 id="2-3-进程调度方式"><a href="#2-3-进程调度方式" class="headerlink" title="2.3 进程调度方式"></a>2.3 进程调度方式</h2><p>1、非剥夺调度方式</p><p>非剥夺调度方式又称为非抢占式调度，指一个进程正在处理器上执行，有某个更为重要的进程进入就绪状态，仍然让正在执行进程继续执行，直到该进程完成或发生某种事件进入阻塞状态，才把处理器分配给更为重要的进程</p><p>2、剥夺调度方式</p><p>又称为抢占方式，若有某个更为重要的进程需要使用处理器，立即暂停正在执行的进程，将处理器分配给这个更为重要或紧迫的进程</p><h2 id="2-4-调度的基本原则"><a href="#2-4-调度的基本原则" class="headerlink" title="2.4 调度的基本原则"></a>2.4 调度的基本原则</h2><p>1、CPU利用率</p><p>应尽可能使CPU保持在忙状态</p><p>2、系统吞吐量</p><p>表示单位时间内CPU完成作业的数量</p><p>3、周转时间</p><p>4、等待时间</p><p>5、响应时间</p><p>6、具有公平性</p><h2 id="2-5-经典的调度算法"><a href="#2-5-经典的调度算法" class="headerlink" title="2.5 经典的调度算法"></a>2.5 经典的调度算法</h2><p>1、FIFS先来先服务/先进先出（FIFO）调度算法：可用于作业调度，也可以用于进程调度</p><ul><li>有利于长作业，而不利于短作业</li><li>有利于CPU繁忙，不利于IO繁忙</li><li>适用于批处理</li></ul><p>2、SJF短作业优先调度算法</p><p>选择估计运行时间最短的作业先运行  </p><p>3、优先级调度算法</p><ul><li>静态优先权：默认优先数<ul><li>进程的类型</li><li>进程对资源的要求</li><li>用户要求</li></ul></li><li>动态优先权<ul><li>岁等待时间的增加而改变</li></ul></li></ul><p>4、高响应比优先调度算法</p><p>是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</p><p>优先权=（等待时间+要求服务时间）/ 要求服务时间</p><p>对短作业、等待时间越长越有利</p><p>5、时间轮片调度算法</p><p>6、多级反馈队列调度算法</p><h1 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3 进程同步"></a>3 进程同步</h1><h2 id="3-1-进程同步的基本概念"><a href="#3-1-进程同步的基本概念" class="headerlink" title="3.1 进程同步的基本概念"></a>3.1 进程同步的基本概念</h2><p>进程是并发进行的，不同进程存在不同的相互制约关系，为了避免进程之间的冲突，引入进程同步的概念</p><p>1、临界资源</p><p>一次只允许一个进程使用的资源称为邻接资源，对邻接资源的访问，必须互斥的进行</p><p>把临界资源的访问过程分为四个部分</p><ol><li>进入区</li><li>临界区</li><li>退出区</li><li>剩余区</li></ol><p>2、同步</p><p>为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置协调他们的工作次序而等待，传递信息所产生的制约关系，进程间的直接制约关系就是他们之间的相互合作</p><p>遵循的原则：</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待：对要求访问临界资源的进程，应保证在有限时间内进入自己的临界区，防止“死等”</li><li>让权等待：进程不能进入自己临界区时，应立即释放处理机制，防止“忙等”</li></ul><p>3、互斥</p><p>互斥称为间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待</p><h2 id="3-2-实现临界区互斥的基本方法"><a href="#3-2-实现临界区互斥的基本方法" class="headerlink" title="3.2 实现临界区互斥的基本方法"></a>3.2 实现临界区互斥的基本方法</h2><p>1、硬件实现方法</p><ol><li><p>中断屏蔽法</p></li><li><p>硬件指令法（TS）</p></li></ol><h2 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h2><p>1、整型信号量</p><p>被定义为一个用于表示资源个数的整型量</p><p>2、记录型号量</p><p>P(S)和V(S)操作可描述为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(semaphore S)&#123;</span><br><span class="line">S.value&#x3D;S.vauel-1; ##请求一个资源</span><br><span class="line">if(S.value&lt;0) Block(S.L) # 自我阻塞，插入到信号链表S.L中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore S)&#123;</span><br><span class="line">S.value +&#x3D;1</span><br><span class="line">if(S.value&lt;&#x3D;0) wakeup(S.L); # 有进程被阻塞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、利用信号量实现同步</p><p>4、利用信号量实现互斥</p><p>5、利用信号量实现前驱关系</p><h2 id="3-4-管程"><a href="#3-4-管程" class="headerlink" title="3.4 管程"></a>3.4 管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据</p><p>管程由三部分组成：</p><ul><li>局部于管程的共享变量说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部管程的数据设置初始值语句</li><li>管程还必须有一个名字</li></ul><p>在实现管程，必须考虑</p><ol><li>互斥：通常编译程序对每个管程自动产生一个互斥信号量，每次只准许一个进程进入管程，其他调用管程者必须等待</li><li>同步：当某进程通过管程请求临界资源而不能满足时，管程便调用wait原语使用该进程等待，并将它排在等待队列上</li></ol><h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4 死锁"></a>4 死锁</h1><h2 id="4-1-死锁的概念"><a href="#4-1-死锁的概念" class="headerlink" title="4.1 死锁的概念"></a>4.1 死锁的概念</h2><p>多个进程因竞争资源造成的一种僵局，若无外力作用，这些进程都将无法向前推进</p><p>1、系统资源的竞争</p><p>2、进程推进顺序非法</p><p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁</p><p>3、死锁产生的必要条件</p><ol><li><p>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程占用</p></li><li><p>不剥夺条件：进程所获得的资源在未使用完毕前，不能被其它进程强行夺走</p></li><li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p></li><li><p>循环等待条件：存在一种进程循环等待链</p></li></ol><ul><li>参与死锁的进程最少是两个</li><li>至少有两个已经占有资源</li><li>死锁所有进程都在等待资源</li><li>参与死锁的进程是当前系统中所有进程的子集</li></ul><h2 id="4-2-死锁处理策略"><a href="#4-2-死锁处理策略" class="headerlink" title="4.2 死锁处理策略"></a>4.2 死锁处理策略</h2><p>1、破坏死锁的四个必要条件之一</p><p>2、用某种方式防止系统进入不安全状态</p><p>3、允许进程在运行过程中发生死锁，通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁</p><p><strong>死锁预防</strong></p><ul><li>摒弃请求和保持条件：所有进程必须一次性的申请整个运行过程所需的全部资源</li><li>摒弃不可剥夺条件：进程逐个申请所需资源，但是申请新资源不能得到满足时，必须放弃自己所保持的资源</li><li>摒弃环路等待：将资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序</li></ul><p><strong>死锁避免</strong></p><p>在避免死锁的方法，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性</p><p>所谓安全状态，是指系统能按某种进程顺序来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，如果系统无法找到这样一个安全序列，则称系统处于不安全状态</p><p>可以用银行家算法检测安全状态</p><p><strong>死锁检测</strong></p><ul><li>死锁定理：某一时刻系统状态S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全化简的，此充分条件称为死锁定理</li></ul><p><strong>死锁解除</strong></p><p>死锁解除的主要方法有</p><ol><li>资源剥夺法：挂起某些死锁进程，抢占其资源，将这些资源分配给其他死锁进程</li><li>进程撤销法：强制撤销一个或一部分进程并剥夺这些进程的资源</li><li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺</li></ol><hr><h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-进程和线程的区别"><a href="#5-1-进程和线程的区别" class="headerlink" title="5.1 进程和线程的区别"></a>5.1 进程和线程的区别</h2><p>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，而进程正相反</p><h2 id="5-2-进程有哪几种状态"><a href="#5-2-进程有哪几种状态" class="headerlink" title="5.2 进程有哪几种状态"></a>5.2 进程有哪几种状态</h2><ul><li>创建状态：进程正在被创建，尚未到就绪状态</li><li>就绪状态：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行</li><li>运行状态：进程正在处理器上运行（单核CPU下任意时刻只有一个进程处于运行状态）</li><li>阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成，即使处理器空闲，该进程也不能运行</li><li>结束状态：进程正在从系统中消失，可能是进程正常结束或其他原因中断退出运行</li></ul><h2 id="5-3-进程间的通信方式"><a href="#5-3-进程间的通信方式" class="headerlink" title="5.3 进程间的通信方式"></a>5.3 进程间的通信方式</h2><ol><li>管道/匿名管道：用于具有亲缘关系的父子进程或兄弟进程之间的通信</li><li>有名管道：有名管道严格遵循先进先出，以磁盘文件的方式存在，可以实现本机任意两个进程通信</li><li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列克服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>信号量：信号量是一个计数器，用于多线程对共享数据的访问，信号量的意图在于进程间同步，这种通信方式主要用于解决与同步相关的问题并避免竞争条件</li><li>共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量，可以说是最有用的进程间通信方式</li><li>套接字：此方法主要用于客户端和服务器之间的网络通信</li></ol><h2 id="5-4-线程间的同步方式"><a href="#5-4-线程间的同步方式" class="headerlink" title="5.4 线程间的同步方式"></a>5.4 线程间的同步方式</h2><p>线程同步是两个或多个共享关键资源的线程的并发执行，同步线程以避免关键资源使用冲突</p><ol><li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限</li><li>信号量：允许统一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>时间：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先极的比较</li></ol><h2 id="5-5-进程的调度算法"><a href="#5-5-进程的调度算法" class="headerlink" title="5.5 进程的调度算法"></a>5.5 进程的调度算法</h2><ul><li>先到先服务：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某时间而被阻塞放弃占用CPU时再重新调度</li><li>短作业优先调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源</li><li>时间片轮转调度算法：每个进程被分配一段时间</li><li>优先极调度：为每个流程分配优先级</li><li>高响应比优先调度算法：是FCFS和SJF的结合，克服了两种算法的缺点，响应比最高的作业优先启动</li><li>多级反馈队列调度算法：即能使高优先级的作业得到响应，又能使短作业迅速完成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1 进程与线程&quot;&gt;&lt;/a&gt;1 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;1-1-进程的概念和特征&quot;&gt;&lt;a href=&quot;#1-1-进程的概念和特征&quot; class=&quot;headerlink&quot; title=&quot;1.1 进程的概念和特征&quot;&gt;&lt;/a&gt;1.1 进程的概念和特征&lt;/h2&gt;&lt;p&gt;（1）进程的概念&lt;/p&gt;
&lt;p&gt;从不同的角度，进程可以由不同的定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程是程序的一次执行过程&lt;/li&gt;
&lt;li&gt;进程是一个程序及其数据在处理器上顺序执行时发生的活动&lt;/li&gt;
&lt;li&gt;进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结（一）：操作系统概述</title>
    <link href="https://liangggggg.github.io/2020/08/27/os/"/>
    <id>https://liangggggg.github.io/2020/08/27/os/</id>
    <published>2020-08-27T01:12:59.000Z</published>
    <updated>2020-08-30T03:51:00.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统的概念、特征、功能和提供的服务"><a href="#1-操作系统的概念、特征、功能和提供的服务" class="headerlink" title="1 操作系统的概念、特征、功能和提供的服务"></a>1 操作系统的概念、特征、功能和提供的服务</h1><h2 id="1-1-操作系统的概念"><a href="#1-1-操作系统的概念" class="headerlink" title="1.1 操作系统的概念"></a>1.1 操作系统的概念</h2><p>操作系统的目标</p><ol><li>方便性</li><li>有效性</li><li>可扩充性</li><li>开放性</li></ol><a id="more"></a><h2 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h2><p>（1）并发</p><p>并行性和并发性是即详细又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个时间在同一时间间隔内发生</p><p>在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的实施程序能并发执行。</p><p>（2）共享</p><p>指系统中的可供内存中多个并发执行的进程（线程）共同使用</p><p>1、互斥共享方式</p><p>系统中的某些资源，如打印机、磁带机，虽然他们可以提供给多个进程使用，但为使所打印的内容不致造成混淆，应规定在同一段时间内只允许一个进程方位该资源。</p><p>2、同时访问方式</p><p>系统中还有一种资源，允许在一段时间内由多个进程“同时”对它进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问即“分时共享”。典型的可供多个进程同时访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p><p>（3）虚报</p><p>通过某种技术把一个物理实体变为若干个逻辑上的对应物，物理实体是实的，后者是虚的，用于实现虚拟的技术称为虚拟技术，利用时分复用和控分复用技术实现</p><p>（4）异步</p><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h2 id="1-3-操作系统的功能"><a href="#1-3-操作系统的功能" class="headerlink" title="1.3 操作系统的功能"></a>1.3 操作系统的功能</h2><p>（1）处理机管理功能</p><ol><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>调度<ul><li>作业调度</li><li>进程调度</li></ul></li></ol><p>（2）存储器管理功能</p><ol><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ol><p>（3）设备管理功能</p><ol><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ol><p>（4）文件管理功能</p><ol><li>文件存储空间的管理</li><li>目录管理</li><li>文件读/写管理和保护</li></ol><h2 id="1-4-操作系统所能提供的服务"><a href="#1-4-操作系统所能提供的服务" class="headerlink" title="1.4 操作系统所能提供的服务"></a>1.4 操作系统所能提供的服务</h2><p>（1）OS作为用户与计算机硬件系统之间的接口</p><p>（2）OS作为计算机系统资源的管理者</p><p>硬件和软件资源分为四类：处理机、存储器、I/O设备和文件，OS的主要功能是对这类资源进行有效的管理</p><p>（3）实现了对计算机资源的抽象</p><h1 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2 操作系统的发展与分类"></a>2 操作系统的发展与分类</h1><h2 id="2-1-操作系统的发展"><a href="#2-1-操作系统的发展" class="headerlink" title="2.1 操作系统的发展"></a>2.1 操作系统的发展</h2><p>（1）未配置操作系统的计算机系统</p><p>（2）单道批处理系统</p><p>（3）多道批处理系统</p><p>（4）分时系统</p><p>（5）实时系统</p><h1 id="3-操作系统的运行环境"><a href="#3-操作系统的运行环境" class="headerlink" title="3 操作系统的运行环境"></a>3 操作系统的运行环境</h1><h2 id="3-1-内核态与用户态"><a href="#3-1-内核态与用户态" class="headerlink" title="3.1 内核态与用户态"></a>3.1 内核态与用户态</h2><p>特权指令：有少数指令是为编制系统管理程序专门设置的，只有操作系统才能使用</p><ol><li>有关I/0的指令</li><li>访问程序状态字寄存器的指令</li><li>存取特殊寄存器指令</li><li>其他访问系统状态和直接访问系统资源的指令</li></ol><p>多数系统将处理器工作状态划分为内核态和用户态，前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为特权太、系统太或管态；后者一般指用户程序运行时的状态，具有较低的特权级别，又称普通态、目态</p><p>目态：程序执行时不可使用特权指令</p><p>管态：可以使用特权指令</p><h2 id="3-2-中断、异常"><a href="#3-2-中断、异常" class="headerlink" title="3.2 中断、异常"></a>3.2 中断、异常</h2><p>中断是由与现指令无关的中断信号触发的，且中断的发生与CPU处在用户模型或内核模式无关，在两条机器指令之间才可相应中断</p><p>异常处理程序提供的服务是为当前进程所用的</p><h2 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h2><p>当系统调用发生时，处理器通过一种特殊的机制，通常是中断或者异常处理，把控制流程序转移到监控程序内的一些特定的位置。</p><h1 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4 操作系统体系结构"></a>4 操作系统体系结构</h1><ol><li>无结构操作系统</li><li>模块化结构OS</li><li>分层式结构OS</li><li>微内核OS结构</li></ol><hr><h1 id="5-常见面试题总结"><a href="#5-常见面试题总结" class="headerlink" title="5 常见面试题总结"></a>5 常见面试题总结</h1><h2 id="5-1-什么是操作系统？"><a href="#5-1-什么是操作系统？" class="headerlink" title="5.1 什么是操作系统？"></a>5.1 什么是操作系统？</h2><ol><li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石</li><li>操作系统本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源</li><li>操作系统存在屏蔽了硬件的复杂性</li><li>操作系统的内核是操作系统的核心部分，它负责内存管理，硬件设备的管理，文件管理以及应用程序的管理</li></ol><h2 id="5-2-系统调用"><a href="#5-2-系统调用" class="headerlink" title="5.2 系统调用"></a>5.2 系统调用</h2><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态：用户态运行的进程或可以直接读取用户程序的数据</li><li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</li></ol><p>在运行用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等）都必须经过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p><p>按系统调用功能大致可以分为如下几类：</p><ol><li>设备管理：完成设备请求或释放，以及设备启动等功能</li><li>文件管理：完成文件的读、写、创建以及删除等功能</li><li>进程控制：完成进程的创建、撤销、阻塞、唤醒等功能</li><li>进程通信：完成进程之间的消息传递或信号传递等功能</li><li>内存管理：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-操作系统的概念、特征、功能和提供的服务&quot;&gt;&lt;a href=&quot;#1-操作系统的概念、特征、功能和提供的服务&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统的概念、特征、功能和提供的服务&quot;&gt;&lt;/a&gt;1 操作系统的概念、特征、功能和提供的服务&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统的概念&quot;&gt;&lt;a href=&quot;#1-1-操作系统的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 操作系统的概念&quot;&gt;&lt;/a&gt;1.1 操作系统的概念&lt;/h2&gt;&lt;p&gt;操作系统的目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方便性&lt;/li&gt;
&lt;li&gt;有效性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;开放性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://liangggggg.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（六）：排序</title>
    <link href="https://liangggggg.github.io/2020/08/18/Data6/"/>
    <id>https://liangggggg.github.io/2020/08/18/Data6/</id>
    <published>2020-08-18T01:12:59.000Z</published>
    <updated>2020-08-28T02:44:02.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>逐个向有序表中进行插入操作</p><p>初始关键字序列：  [7]    4    -2    19    13    6    ；<br>第一趟排序后：    [4    7]    -2    19    13    6    ；<br>第二趟排序后：    [-2    4    7]    19    13    6    ；<br>第三趟排序后：    [-2    4    7    19]    13    6    ；<br>第四趟排序后：    [-2    4    7    13    19]    6    ；<br>第五趟排序后：    [-2    4    6    7    13    19]    ；</p><a id="more"></a><p><img src="https://note.youdao.com/yws/api/personal/file/FF99682334F14D6C8BDC28A7D301BB17?method=download&shareKey=18c14c8e31ea2e76032d125fea69224f" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def insertionSort(arr): </span><br><span class="line">  </span><br><span class="line">    for i in range(1, len(arr)): </span><br><span class="line">  </span><br><span class="line">        key &#x3D; arr[i] </span><br><span class="line">  </span><br><span class="line">        j &#x3D; i-1</span><br><span class="line">        while j &gt;&#x3D;0 and key &lt; arr[j] : </span><br><span class="line">                arr[j+1] &#x3D; arr[j] </span><br><span class="line">                j -&#x3D; 1</span><br><span class="line">        arr[j+1] &#x3D; key </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6] </span><br><span class="line">insertionSort(arr) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(len(arr)): </span><br><span class="line">    print (&quot;%d&quot; %arr[i])</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：仅用了一个辅助单元，空间复杂度为$O(1)$</p><p>（2）时间效率：向有序表逐个插入记录操作，进行了$n-1$趟，每趟操作分为比较关键码和移动记录，直接插入最好情况为$O(n)$，平均时间复杂度$O(n^2)$</p><p>（3）稳定性：稳定</p><h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>折半插入排序是利用折半查找实现在有序表$R[1,i-1]$中查找$R[i]$的插入位置</p><p>对下列序列进行排序：{30，13，70，85，39，42，6，20}，并写出排序的过程。<br>对排序表：30，13，70，85，39，42，6，20 进行划分<br>设初始状态：</p><p>第一趟排序：    (30) 13    70    85    39    42    6 20<br>第二趟排序：    (13    30)    70    85    39    42    6 20<br>第三趟排序：    (13    30    70)    85    39    42    6 20<br>第七趟排序：    (6    13    30    39    42    70    85)    20<br>第八趟排序：    (6    13    30    39    42    70    85)    20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def binaryInsert(a):</span><br><span class="line"># 折半插入排序: 小-&gt;大</span><br><span class="line"># 在直接插入排序的基础上使用了折半查找的方法 </span><br><span class="line">    for i in xrange(1, len(a)):</span><br><span class="line">        index &#x3D; a[i]</span><br><span class="line">        low &#x3D; 0</span><br><span class="line">        hight &#x3D; i - 1</span><br><span class="line">        while low &lt;&#x3D; hight:</span><br><span class="line">            mid &#x3D; (low + hight) &#x2F; 2</span><br><span class="line">            if index &gt; a[mid]:</span><br><span class="line">                low &#x3D; mid + 1</span><br><span class="line">            else:</span><br><span class="line">                hight &#x3D; mid - 1</span><br><span class="line">        # 跳出循环后 low, mid 都是一样的, hight &#x3D; low - 1</span><br><span class="line">        for j in xrange(i, low, -1):</span><br><span class="line">            a[j] &#x3D; a[j - 1]</span><br><span class="line">        a[low] &#x3D; index</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h2><p>交换排序是通过两两比较待排序记录的关键码，若发生排序要求相逆，则交换之</p><p>对下列序列排序{23，38，22，45，23，67，31，15，41}写出冒泡排序的过程。</p><p>初始关键字序列：  23    38    22    45    23    67    31    15    41；<br>第一趟排序后：    23    22    38    33    45    31    15    41    61；<br>第二趟排序后：    22    23    23    38    31    15    41    45    67；<br>第三趟排序后：    22    23    23    31    15    38    41    45    67；<br>第四趟排序后：    22    23    23    15    31    38    41    45    67；<br>第五趟排序后：    22    23    15    23    31    38    41    45    67；<br>第六趟排序后：    22    15    23    23    31    38    41    45    67；<br>第七趟排序后：    15    22    23    23    31    38    41    45    67；</p><p><img src="https://note.youdao.com/yws/api/personal/file/7761644612D44FC58115EF304F360F80?method=download&shareKey=16637b3bb70a29545e6cd6dcae641d40" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(arr):</span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line"> </span><br><span class="line">    # 遍历所有数组元素</span><br><span class="line">    for i in range(n):</span><br><span class="line"> </span><br><span class="line">        # Last i elements are already in place</span><br><span class="line">        for j in range(0, n-i-1):</span><br><span class="line"> </span><br><span class="line">            if arr[j] &gt; arr[j+1] :</span><br><span class="line">                arr[j], arr[j+1] &#x3D; arr[j+1], arr[j]</span><br><span class="line"> </span><br><span class="line">arr &#x3D; [64, 34, 25, 12, 22, 11, 90]</span><br><span class="line"> </span><br><span class="line">bubbleSort(arr)</span><br><span class="line"> </span><br><span class="line">print (&quot;排序后的数组:&quot;)</span><br><span class="line">for i in range(len(arr)):</span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：最好情况$O(n)$，平均时间复杂度为$O(n^2)$</p><p>（3）稳定性：稳定</p><h1 id="3-简单选择排序"><a href="#3-简单选择排序" class="headerlink" title="3 简单选择排序"></a>3 简单选择排序</h1><p>从无序序列$R[i..n]$的$n-i+1$记录中选出关键字最小的记录加入有序序列</p><p>对下列序列排序{49，14，38，74，96，65，49，8，55，27}；</p><p>第 1 趟之后：8    14    38    74    96    65    49    49    55    27<br>第 2 趟之后：8    14    38    74    96    65    49    49    55    27<br>（在本位就不用交换）<br>第 3 趟之后：8    14    27    74    96    65    49    49    55    38<br>第 4 趟之后：8    14    27    49    96    65    74    49    55    38</p><p><img src="https://note.youdao.com/yws/api/personal/file/6A3A3EAE3343434E8E6699BAA353F38F?method=download&shareKey=58632ab023763519c4fb1b6d1bbd7abf" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import sys </span><br><span class="line">A &#x3D; [64, 25, 12, 22, 11] </span><br><span class="line">  </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line">    min_idx &#x3D; i </span><br><span class="line">    for j in range(i+1, len(A)): </span><br><span class="line">        if A[min_idx] &gt; A[j]: </span><br><span class="line">            min_idx &#x3D; j </span><br><span class="line">                </span><br><span class="line">    A[i], A[min_idx] &#x3D; A[min_idx], A[i] </span><br><span class="line">  </span><br><span class="line">print (&quot;排序后的数组：&quot;) </span><br><span class="line">for i in range(len(A)): </span><br><span class="line">    print(&quot;%d&quot; %A[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：最好和平均时间复杂度均为$O(n^2)$</p><p>（3）稳定性：从前往后比较稳定，从后往前比较不稳定</p><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h1><p>直接插入排序的改进版本，希尔排序把序列按一定间隔分组，对每组使用直接插入排序；随着间隔减小，一直到1，使得整个序列有序</p><p><img src="https://note.youdao.com/yws/api/personal/file/7A971CDA8CA34300AE79B58854A8067B?method=download&shareKey=a6c84b288f98376985ad2214b2179a2f" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(arr): </span><br><span class="line">  </span><br><span class="line">    n &#x3D; len(arr)</span><br><span class="line">    gap &#x3D; int(n&#x2F;2)</span><br><span class="line">  </span><br><span class="line">    while gap &gt; 0: </span><br><span class="line">  </span><br><span class="line">        for i in range(gap,n): </span><br><span class="line">  </span><br><span class="line">            temp &#x3D; arr[i] </span><br><span class="line">            j &#x3D; i </span><br><span class="line">            while  j &gt;&#x3D; gap and arr[j-gap] &gt;temp: </span><br><span class="line">                arr[j] &#x3D; arr[j-gap] </span><br><span class="line">                j -&#x3D; gap </span><br><span class="line">            arr[j] &#x3D; temp </span><br><span class="line">        gap &#x3D; int(gap&#x2F;2)</span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 34, 54, 2, 3] </span><br><span class="line">  </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序前:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]), </span><br><span class="line">  </span><br><span class="line">shellSort(arr) </span><br><span class="line">  </span><br><span class="line">print (&quot;\n排序后:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print(arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：依赖于步长的选取</p><p>（3）稳定性：不稳定</p><h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h1><p>以某个记录为界（该点称为支点）,将待排序列分成两部分。其中，一部分所有记录的关键码大于等于支点记录的关键码，另一部分所有记录的关键码小于支点记录的关键码，将此过程称为一次划分，对各部分不断划分，直到整个序列按关键码有序</p><p>设置指针low,high，初始值为第一个和最后一个记录的位置，设两个变量$i,j$，令$i=low，j=high$，以$R[low].key$作为基准（将$R[low]保存在R[0]$）</p><ol><li><p>从$j$所指位置向前搜索：将$R[0].key$与$R[j].key$进行比较</p><ul><li>若$R[0].key&lt;=R[j].key$：令$j=j-1$，然后继续进行比较，直到$i=j$或$R[0].key&gt;=R[j].key$为止；</li><li>若$R[0].key&gt;R[j].key$：$R[j]=R[i]$，腾出$R[j]$的位置，且令$i=i+1$;</li></ul></li><li><p>从$i$所指位置起向后搜索：将$R[0].key$与$R[i].key$进行比较：</p><ul><li>若$R[0].key&gt;=R[i].key$:令$i=i+1$，然后进行比较，直到$i=j$或$R[0].key&lt;R[i].key$为止；</li><li>若$R[0].key&lt;R[i].key$:令$R[i]=R[j]$，腾出$R[i]$的位置，且令$j=j-1$;</li></ul></li><li><p>重复1，2直至$i=j$为止，$i$就是$R[0]$所应放置的位置</p></li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/519327C530694B5594AF6E9DFE3077DF?method=download&shareKey=7556ec6121cdbc1262ee7d150e0de45e" alt></p><p>当进行一趟快速排序后，采用相同方法分别对两个子序列快速排序，直至子序列记录个为1为止<br><img src="https://note.youdao.com/yws/api/personal/file/4A0267871158449CBE0A83CCA16D8393?method=download&shareKey=da100567e02c7e17747e6d32b1edba56" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def partition(arr,low,high): </span><br><span class="line">    i &#x3D; ( low-1 )         # 最小元素索引</span><br><span class="line">    pivot &#x3D; arr[high]     </span><br><span class="line">  </span><br><span class="line">    for j in range(low , high): </span><br><span class="line">  </span><br><span class="line">        # 当前元素小于或等于 pivot </span><br><span class="line">        if   arr[j] &lt;&#x3D; pivot: </span><br><span class="line">          </span><br><span class="line">            i &#x3D; i+1 </span><br><span class="line">            arr[i],arr[j] &#x3D; arr[j],arr[i] </span><br><span class="line">  </span><br><span class="line">    arr[i+1],arr[high] &#x3D; arr[high],arr[i+1] </span><br><span class="line">    return ( i+1 ) </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"># arr[] --&gt; 排序数组</span><br><span class="line"># low  --&gt; 起始索引</span><br><span class="line"># high  --&gt; 结束索引</span><br><span class="line">  </span><br><span class="line"># 快速排序函数</span><br><span class="line">def quickSort(arr,low,high): </span><br><span class="line">    if low &lt; high: </span><br><span class="line">  </span><br><span class="line">        pi &#x3D; partition(arr,low,high) </span><br><span class="line">  </span><br><span class="line">        quickSort(arr, low, pi-1) </span><br><span class="line">        quickSort(arr, pi+1, high) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [10, 7, 8, 9, 1, 5] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">quickSort(arr,0,n-1) </span><br><span class="line">print (&quot;排序后的数组:&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(nlog_2n)$</p><p>（2）时间效率：最好$O(nlog_2n)$，最坏$O(n^2)$</p><p>（3）稳定性：不稳定</p><h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h1><h2 id="6-1-堆的性质"><a href="#6-1-堆的性质" class="headerlink" title="6.1 堆的性质"></a>6.1 堆的性质</h2><ol><li>堆是一棵采用顺序存储结构的完全二叉树，$k_1$是根结点</li><li>根结点是关键字序列中最小（或最大）值，分别称为小（或大）根堆</li><li>从根结点到每一叶子结点路径上的元素组成的序列都是按元素值非递减（或非递增）</li><li>堆中的任一子树也是堆</li></ol><p>利用堆顶记录的关键字最小（或最大）性质，从当前待排序的记录中依次选取关键字最小（或最大）的记录，实现对数据记录的排序，称为堆排序</p><h2 id="6-2-堆排序思想"><a href="#6-2-堆排序思想" class="headerlink" title="6.2 堆排序思想"></a>6.2 堆排序思想</h2><ol><li>对一组待排序的记录，按堆定义建堆</li><li>将堆顶记录和最后一个记录交换位置，则前$n-1$个记录是无序的，最后一个记录有序的</li><li>堆顶记录被交换后，前$n-1$个记录不再是堆，需要重新调整为一个堆，重复2操作，直到全部记录排好序</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/548842621E8D4AACAB1CD7FD7DC5DD5A?method=download&shareKey=b859872f37b596a5ded5f420bf786943" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def heapify(arr, n, i): </span><br><span class="line">    largest &#x3D; i  </span><br><span class="line">    l &#x3D; 2 * i + 1     # left &#x3D; 2*i + 1 </span><br><span class="line">    r &#x3D; 2 * i + 2     # right &#x3D; 2*i + 2 </span><br><span class="line">  </span><br><span class="line">    if l &lt; n and arr[i] &lt; arr[l]: </span><br><span class="line">        largest &#x3D; l </span><br><span class="line">  </span><br><span class="line">    if r &lt; n and arr[largest] &lt; arr[r]: </span><br><span class="line">        largest &#x3D; r </span><br><span class="line">  </span><br><span class="line">    if largest !&#x3D; i: </span><br><span class="line">        arr[i],arr[largest] &#x3D; arr[largest],arr[i]  # 交换</span><br><span class="line">  </span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">  </span><br><span class="line">def heapSort(arr): </span><br><span class="line">    n &#x3D; len(arr) </span><br><span class="line">  </span><br><span class="line">    # Build a maxheap. </span><br><span class="line">    for i in range(n, -1, -1): </span><br><span class="line">        heapify(arr, n, i) </span><br><span class="line">  </span><br><span class="line">    # 一个个交换元素</span><br><span class="line">    for i in range(n-1, 0, -1): </span><br><span class="line">        arr[i], arr[0] &#x3D; arr[0], arr[i]   # 交换</span><br><span class="line">        heapify(arr, i, 0) </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [ 12, 11, 13, 5, 6, 7] </span><br><span class="line">heapSort(arr) </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;排序后&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(1)$</p><p>（2）时间效率：$O(nlog_2n)$</p><p>（3）稳定性：不稳定</p><h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h1><ol><li>将序列划分成$n$个待排的长度为1的子序列</li><li>对所有子序列进行两两归并，得到$n/2$个长度为2或1的有序子序列</li><li>重复2，直到得到长度为n的有序序列为止</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/550329FAA2224DA1909CCE2C53C7C862?method=download&shareKey=75cb313577311fe8a6540ffb19003dd3" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">def merge(arr, l, m, r): </span><br><span class="line">    n1 &#x3D; m - l + 1</span><br><span class="line">    n2 &#x3D; r- m </span><br><span class="line">  </span><br><span class="line">    # 创建临时数组</span><br><span class="line">    L &#x3D; [0] * (n1)</span><br><span class="line">    R &#x3D; [0] * (n2)</span><br><span class="line">  </span><br><span class="line">    # 拷贝数据到临时数组 arrays L[] 和 R[] </span><br><span class="line">    for i in range(0 , n1): </span><br><span class="line">        L[i] &#x3D; arr[l + i] </span><br><span class="line">  </span><br><span class="line">    for j in range(0 , n2): </span><br><span class="line">        R[j] &#x3D; arr[m + 1 + j] </span><br><span class="line">  </span><br><span class="line">    # 归并临时数组到 arr[l..r] </span><br><span class="line">    i &#x3D; 0     # 初始化第一个子数组的索引</span><br><span class="line">    j &#x3D; 0     # 初始化第二个子数组的索引</span><br><span class="line">    k &#x3D; l     # 初始归并子数组的索引</span><br><span class="line">  </span><br><span class="line">    while i &lt; n1 and j &lt; n2 : </span><br><span class="line">        if L[i] &lt;&#x3D; R[j]: </span><br><span class="line">            arr[k] &#x3D; L[i] </span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        else: </span><br><span class="line">            arr[k] &#x3D; R[j] </span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 L[] 的保留元素</span><br><span class="line">    while i &lt; n1: </span><br><span class="line">        arr[k] &#x3D; L[i] </span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    # 拷贝 R[] 的保留元素</span><br><span class="line">    while j &lt; n2: </span><br><span class="line">        arr[k] &#x3D; R[j] </span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">def mergeSort(arr,l,r): </span><br><span class="line">    if l &lt; r: </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        m &#x3D; int((l+(r-1))&#x2F;2)</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+1, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; [12, 11, 13, 5, 6, 7] </span><br><span class="line">n &#x3D; len(arr) </span><br><span class="line">print (&quot;给定的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]), </span><br><span class="line">  </span><br><span class="line">mergeSort(arr,0,n-1) </span><br><span class="line">print (&quot;\n\n排序后的数组&quot;) </span><br><span class="line">for i in range(n): </span><br><span class="line">    print (&quot;%d&quot; %arr[i]),</span><br></pre></td></tr></table></figure><p>性能分析：<br>（1）空间复杂度：$O(n)$</p><p>（2）时间复杂度：$O(nlog_2n)$</p><p>（3）稳定性：稳定</p><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h1><ol><li>待排序记录以指针相链，构成一个链表</li><li>分配时，按当前关键字所取值，将记录分配到不同的链队列中，每个队列中记录的关键字相同</li><li>收集时，按当前关键字位取值从小到大将各队列首尾相链成一个链表</li><li>对每个关键字位均重复2，3</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/E9DF1FF414E54E1286F6D076F1E31085?method=download&shareKey=9810a1638a78b374beff7ec84f5f424b" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def countSort(arr): </span><br><span class="line">  </span><br><span class="line">    output &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    count &#x3D; [0 for i in range(256)] </span><br><span class="line">  </span><br><span class="line">    ans &#x3D; [&quot;&quot; for _ in arr] </span><br><span class="line">  </span><br><span class="line">    for i in arr: </span><br><span class="line">        count[ord(i)] +&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(256): </span><br><span class="line">        count[i] +&#x3D; count[i-1] </span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        output[count[ord(arr[i])]-1] &#x3D; arr[i] </span><br><span class="line">        count[ord(arr[i])] -&#x3D; 1</span><br><span class="line">  </span><br><span class="line">    for i in range(len(arr)): </span><br><span class="line">        ans[i] &#x3D; output[i] </span><br><span class="line">    return ans  </span><br><span class="line">  </span><br><span class="line">arr &#x3D; &quot;wwwrunoobcom&quot;</span><br><span class="line">ans &#x3D; countSort(arr) </span><br><span class="line">print ( &quot;字符数组排序 %s&quot;  %(&quot;&quot;.join(ans)) )</span><br></pre></td></tr></table></figure><p>性能分析：</p><p>（1）空间效率：$O(rd)$</p><p>（2）时间效率：$O(d(n+rd))$</p><p>（3）稳定性：稳定</p><h1 id="9-各排序算法性能总结"><a href="#9-各排序算法性能总结" class="headerlink" title="9 各排序算法性能总结"></a>9 各排序算法性能总结</h1><table><thead><tr><th align="center">排序方法</th><th align="center">平均时间性能</th><th align="center">最好时间性能</th><th align="center">最坏性能</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">直接插入</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">简单选择</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">$O(nlog_2n)-O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(nlog_2n)-O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(nlog_2n)$</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+rd))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(n+rd)$</td><td align="center">稳定</td></tr></tbody></table><p>基数排序中，$r$代表关键字的基数，$d$代表长度，$n$代表关键字的个数</p><p>关于时间复杂度：</p><ol><li>平方阶（$O(n^2)$）排序，各类简单排序：直接插入、直接选择、冒泡排序</li><li>线性对数阶（$O(nlog2n)$）排序：快速排序，堆排序和归并排序</li><li>$O(n1+\epsilon)$：希尔排序</li><li>线性阶$O(n)$：计数排序</li></ol><p>关于稳定性：</p><ol><li>稳定：冒泡、插入、归并、计数</li><li>不稳定：选择、快速、希尔、堆排序</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1 插入排序&quot;&gt;&lt;/a&gt;1 插入排序&lt;/h1&gt;&lt;h2 id=&quot;1-1-直接插入排序&quot;&gt;&lt;a href=&quot;#1-1-直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.1 直接插入排序&quot;&gt;&lt;/a&gt;1.1 直接插入排序&lt;/h2&gt;&lt;p&gt;逐个向有序表中进行插入操作&lt;/p&gt;
&lt;p&gt;初始关键字序列：  [7]    4    -2    19    13    6    ；&lt;br&gt;第一趟排序后：    [4    7]    -2    19    13    6    ；&lt;br&gt;第二趟排序后：    [-2    4    7]    19    13    6    ；&lt;br&gt;第三趟排序后：    [-2    4    7    19]    13    6    ；&lt;br&gt;第四趟排序后：    [-2    4    7    13    19]    6    ；&lt;br&gt;第五趟排序后：    [-2    4    6    7    13    19]    ；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（六）：应用层</title>
    <link href="https://liangggggg.github.io/2020/08/17/network6/"/>
    <id>https://liangggggg.github.io/2020/08/17/network6/</id>
    <published>2020-08-17T01:47:42.000Z</published>
    <updated>2020-08-30T03:26:59.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络应用模型"><a href="#1-网络应用模型" class="headerlink" title="1 网络应用模型"></a>1 网络应用模型</h1><h2 id="1-1-客户-服务器模型"><a href="#1-1-客户-服务器模型" class="headerlink" title="1.1 客户/服务器模型"></a>1.1 客户/服务器模型</h2><p>分为客户和服务器</p><h2 id="1-2-P2P模型"><a href="#1-2-P2P模型" class="headerlink" title="1.2 P2P模型"></a>1.2 P2P模型</h2><p>两台主机通信不区分哪一个是服务请求那有个是服务器提供方，进行平等，对等连接通信</p><a id="more"></a><h1 id="2-DNS系统"><a href="#2-DNS系统" class="headerlink" title="2 DNS系统"></a>2 DNS系统</h1><p>DNS基于UDP协议实现</p><p>采用层次树桩结构的命名方式</p><p>（1）根域名服务器</p><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器</p><p>（2）顶级域名服务器</p><p>负责管理在该顶级域名服务器注册的所有二级域名</p><p>（3）权限域名服务器</p><p>（4）本地域名服务器</p><p>本地域名服务器采用迭代查询</p><h1 id="3-FTP"><a href="#3-FTP" class="headerlink" title="3 FTP"></a>3 FTP</h1><p>使用TCP可靠的传输服务，主进程工作步骤如下</p><p>（1）打开熟知端口，使客户进程能够连接上</p><p>（2）等待客户进程发出连接请求</p><p>（3）启动从属进程处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程</p><p>（4）回到等待状态，继续接受其他客户进程发来的请求</p><h1 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h1><p>（1）MIME</p><p>SMTP有以下缺点</p><ol><li>不能传送可执行文件或其他二进制对象</li><li>限于传送7位ASCII码</li><li>SMTP服务器会拒绝超过一定长度的邮件</li><li>某些SMTP的实现并没有完全按照SMTP互联网标准</li></ol><p>于是提出了互联网邮件扩充MIME</p><p>（2）SMTP协议</p><p>规定了两个相互通信的SMTP进程之间如何交换信息</p><p>（3）POP</p><p>邮局协议POP是一个非常简单、但功能有限的邮件读取协议</p><h1 id="5-WWW"><a href="#5-WWW" class="headerlink" title="5 WWW"></a>5 WWW</h1><p>并非某种特殊的计算机网络，是一个大规模的、联机式的信息储藏所，能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息，这种访问方式称为链接</p><h1 id="6-HTTP协议"><a href="#6-HTTP协议" class="headerlink" title="6 HTTP协议"></a>6 HTTP协议</h1><p>HTTP是面向事务的应用层协议</p><p><img src="https://note.youdao.com/yws/api/personal/file/A52B3CB112F24C5E9369903B8FEB75A7?method=download&shareKey=811633ce773f37161ee8950040f2b30c" alt></p><p>用户点击鼠标后所发生的时间</p><ol><li>浏览器分析超链接所指向页面的URL</li><li>浏览器想DNS请求<a href="http://www.tsinghua.edu.cn的IP地址" target="_blank" rel="noopener">www.tsinghua.edu.cn的IP地址</a></li><li>域名系统DNS解析出清华大学服务器IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器给出相应，把文件发给浏览器</li><li>TCP连接释放</li><li>浏览器显示文本文件内容</li></ol><p>HTTP两类报文：</p><p>（1）请求报文————从客户想服务器发送请求报文</p><p>（2）响应报文————从服务器到客户的回答</p><hr><h1 id="7-常见面试问题总结"><a href="#7-常见面试问题总结" class="headerlink" title="7 常见面试问题总结"></a>7 常见面试问题总结</h1><h2 id="7-1-在浏览器输入url地址，显示主页的过程"><a href="#7-1-在浏览器输入url地址，显示主页的过程" class="headerlink" title="7.1 在浏览器输入url地址，显示主页的过程"></a>7.1 在浏览器输入url地址，显示主页的过程</h2><p>总体来说分为以下几个过程</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理并换回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/73A4BC32978B40C59BA640BB36EC3F56?method=download&shareKey=f38ebfffcb05bc48176deed0c0ed2c7a" alt></p><h2 id="7-2-状态码"><a href="#7-2-状态码" class="headerlink" title="7.2 状态码"></a>7.2 状态码</h2><p><img src="https://note.youdao.com/yws/api/personal/file/3BEA8247A061405F821B87E697558037?method=download&shareKey=8281ad343ddc80a635d32d1eff1f3216" alt></p><h2 id="7-3-各种协议与HTTP协议之间的关系"><a href="#7-3-各种协议与HTTP协议之间的关系" class="headerlink" title="7.3 各种协议与HTTP协议之间的关系"></a>7.3 各种协议与HTTP协议之间的关系</h2><p><img src="https://note.youdao.com/yws/api/personal/file/DC3E01C9A25B4DCE99F6018F5A51636F?method=download&shareKey=5017d608dee88ba4252fd3c868f7d7c2" alt></p><h2 id="7-4-HTTP长连接，短连接"><a href="#7-4-HTTP长连接，短连接" class="headerlink" title="7.4 HTTP长连接，短连接"></a>7.4 HTTP长连接，短连接</h2><p>在HTTP/1.0中默认使用短连接，也就是说，客户端和服务端每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>从HTTP/1.1起，默认使用长连接，用以保持连接特性，在当一个网页打开完成后，客户端和服务器之间用于传输HTTP的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用一条已经建立的连接</p><h2 id="7-5-HTTP是不保存状态的协议，如何保存用户状态"><a href="#7-5-HTTP是不保存状态的协议，如何保存用户状态" class="headerlink" title="7.5 HTTP是不保存状态的协议，如何保存用户状态"></a>7.5 HTTP是不保存状态的协议，如何保存用户状态</h2><p>HTTP协议自身不对请求和相应之间的通信状态进行保存，Session机制的存在可以通过服务端记录用户的状态</p><p>在服务端保存Session的方法，最常用的就是内存和数据库，通过Cookie中附加一个Session ID来跟踪</p><p>Cookie被禁用怎么办？</p><p>最常用的就是利用URL重写把Session ID直接附加在URL路径的后面</p><h2 id="7-6-Cookie的作用是什么？和Session有什么区别？"><a href="#7-6-Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="7.6 Cookie的作用是什么？和Session有什么区别？"></a>7.6 Cookie的作用是什么？和Session有什么区别？</h2><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样</p><p>Cookie一般用来保存用户信息</p><p>Session主要作用就是通过服务端记录用户的状态</p><h2 id="7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？"><a href="#7-7-HTTP-1-0-和-HTTP-1-1的主要区别是什么？" class="headerlink" title="7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？"></a>7.7 HTTP 1.0 和 HTTP 1.1的主要区别是什么？</h2><ol><li>长连接</li><li>错误状态响应码</li><li>缓存处理</li><li>带宽优化及网络连接的使用</li></ol><h2 id="7-8-URI和URL的区别是什么？"><a href="#7-8-URI和URL的区别是什么？" class="headerlink" title="7.8 URI和URL的区别是什么？"></a>7.8 URI和URL的区别是什么？</h2><ul><li>URI是统一资源标志符，可以唯一标志一个资源</li><li>URL是统一资源定位符，可以提供该资源的路径</li></ul><h2 id="7-9-HTTP和HTTPS的区别"><a href="#7-9-HTTP和HTTPS的区别" class="headerlink" title="7.9 HTTP和HTTPS的区别"></a>7.9 HTTP和HTTPS的区别</h2><ol><li>端口：HTTP默认端口为80，而HTTPS默认端口443</li><li>安全性和资源消耗：HTTP协议运行在TCP纸上。所有传输的内容都是明文，客户端和服务器都无法验证对方的身份，HTTPS运行在SSL/TLS纸上的HTTP协议，所有传输内容都经过加密，加密采用对称加密，但密钥用服务器的证书使用非对称加密<ul><li>对称加密：密钥只有一个，加密解密为同一密码，典型的对称加密算法有：DES、AES等</li><li>非对称加密：密钥成对出现，加密解密使用不同密钥</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-网络应用模型&quot;&gt;&lt;a href=&quot;#1-网络应用模型&quot; class=&quot;headerlink&quot; title=&quot;1 网络应用模型&quot;&gt;&lt;/a&gt;1 网络应用模型&lt;/h1&gt;&lt;h2 id=&quot;1-1-客户-服务器模型&quot;&gt;&lt;a href=&quot;#1-1-客户-服务器模型&quot; class=&quot;headerlink&quot; title=&quot;1.1 客户/服务器模型&quot;&gt;&lt;/a&gt;1.1 客户/服务器模型&lt;/h2&gt;&lt;p&gt;分为客户和服务器&lt;/p&gt;
&lt;h2 id=&quot;1-2-P2P模型&quot;&gt;&lt;a href=&quot;#1-2-P2P模型&quot; class=&quot;headerlink&quot; title=&quot;1.2 P2P模型&quot;&gt;&lt;/a&gt;1.2 P2P模型&lt;/h2&gt;&lt;p&gt;两台主机通信不区分哪一个是服务请求那有个是服务器提供方，进行平等，对等连接通信&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结（五）：查找</title>
    <link href="https://liangggggg.github.io/2020/08/17/Data5/"/>
    <id>https://liangggggg.github.io/2020/08/17/Data5/</id>
    <published>2020-08-17T00:12:59.000Z</published>
    <updated>2020-08-27T03:28:25.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1 查找的基本概念"></a>1 查找的基本概念</h1><p>查找有两种基本形态：静态查找和动态查找</p><ul><li>静态查找：在查找时只对数据元素进行查询或检索，查找表称为静态查找表</li><li>动态查找：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录</li></ul><p>根据存储结构的不同，查找方法分为三大类：</p><ol><li>顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较，找到要查找的记录</li><li>散列表的查找：根据给定的K值直接访问查找表，从而找到要查找的记录</li><li>索引查找表的查找：首先根据索引确定待查找记录所在的块，然后再从块中找到要查找的记录</li></ol><a id="more"></a><p>平均查找长度</p><p>为确定数据元素在列表中的位置，需给定值进行比较的关键字个数的期望值</p><p>$$ASL = \sum_{i=1}^n p_i * C_i, \  \sum_{i=1}^n p_i = 1$$</p><p>$p_i$：查找第$i$个记录的概率<br>$C_i$：查找第$i$个记录需要进行比较的次数</p><h1 id="2-顺序查找法"><a href="#2-顺序查找法" class="headerlink" title="2. 顺序查找法"></a>2. 顺序查找法</h1><p>将查找表作为一个线性表，可以是顺序表，也可以使链表，依次进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_SIZE 100</span><br><span class="line">typedef struct SSTable</span><br><span class="line">&#123;</span><br><span class="line">RecType elem[MAX_SIZE]</span><br><span class="line">int length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line">int Seq_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">int p;</span><br><span class="line">ST.elem[0].key&#x3D;key; # 设置监视哨兵，失败返回0</span><br><span class="line">for(p&#x3D;ST.length; ST.elem[p].key!&#x3D;key;p--) return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设查找每个记录的概率相等，即$P_i = 1/n$，查找第$i$个元素成功的比较次数$C_i  = n-i+1$</p><p>查找成功时：<br>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{n+1}{2}$$</p><p>查找不成功时：比较次数为$n+1$，概率为$P_1 = 1/(2n)$</p><p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{2n}\sum_{i=1}^n(n-i+1)+\frac{n+1}{2}=\frac{3(n+1)}{4}$$</p><h1 id="3-分块查找法"><a href="#3-分块查找法" class="headerlink" title="3 分块查找法"></a>3 分块查找法</h1><p>分块查找的基本思想是：将表分成n块，每一块中的关键字不一定有序，但前一块中最大关键字必须小于后一块的最小关键字，即要求表示“分块有序的”。首先查找索引表，因为索引表是有序表，确定待查结点是在哪一块，然后再已确定的块中进行顺序查找</p><p>线性表中共有$n$个结点，分成大小相等的$b$块，每块有$s=n/b$个结点，假定对索引表也采用顺序查找，值考虑查找成功的情况，并假定对每个结点的查找概率是相等的</p><p>$$E_b = \sum_{i=1}^b(i* \frac{1}{b})=\frac{b+1}{2}$$</p><p>$$E_w = \sum_{i=1}^s(i*\frac{1}{s})=\frac{s+1}{2}$$</p><p>所以：</p><p>$$E(n)=E_b+E_w = \frac{b+1}{2}+\frac{s+1}{2}=\frac{n+s^2}{2s}+1$$</p><p>当$s=\sqrt{n}，E(n)取最小值$</p><p>$$E(n)=\sqrt{n}+1\approx \sqrt{n}$$</p><h1 id="4-折半查找法"><a href="#4-折半查找法" class="headerlink" title="4 折半查找法"></a>4 折半查找法</h1><p>折半查找要求查找表顺序存储结构且各数据元素按关键字有序排序，也就是说折半查找只适用于对有序顺序表进行查找</p><p>（1）查找思想<br>用Low、High和Mid表示待查找区间的下界、上届和中间位置指针，初值为Low=1,High=n</p><p>取中间位置$Mid: Mid = floor[(Low+High)/2]$</p><p>比较中间位置记录的关键字与给定的K值</p><ol><li>相等:查找成功</li><li>大于：待查找记录在区间的前半段，修改上界指针：High = Mid -1,转1</li><li>小于：待查记录在区间的后半段，修改下界指针：Low = Mid +1，转1</li></ol><p>直到越界(Low&gt;High)，查找失败 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Bin_Search(SSTable ST, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">int Low&#x3D;1, High&#x3D;ST.length, Mid;</span><br><span class="line">while(Low&lt;&#x3D;High)</span><br><span class="line">&#123;</span><br><span class="line">if(ST.elem[Mid].key&#x3D;&#x3D;key) return Mid;</span><br><span class="line">else if(ST.elem[Mid].key&lt;key) Low&#x3D;Mid+1;</span><br><span class="line">else High&#x3D;Mid-1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）算法分析<br>经过每一次查找，查找范围就缩小一半，该过程可用一颗二叉树表示，所得到的二叉树为判定书</p><p><img src="https://note.youdao.com/yws/api/personal/file/D88D43B8E643426EAB6B2364BFF63C6F?method=download&shareKey=3fa93bd5fbe81e5e524c115bc248e942" alt></p><p>ASL成功 = $(1+2 * 2+4 * 3+4 * 4)/11$</p><p>ASL不成功 = $(4 * 3 +8 * 4)/12$</p><p>将二叉判定书的第$\lfloor log_2 n \rfloor+1$层上的结点补齐就称为一颗满二叉树，深度不变，$h=\lfloor log_2(n+1) \rfloor$</p><p>由满二叉树性质知，第$i$层上的结点数为$2i-1(i&lt;=h)$，设表中每个记录的查找概率相等，即$P_1 = \frac{1}{n}$，查找成功时的平均查找长度ASL：</p><p>$$ASL = \sum_{i=1}^n P_i * C_i = \frac{1}{n}\sum_{j=1}^h j* 2^{j-1}=\frac{n+1}{n}log_2(n+1)-1$$</p><p>当$n$很大$(n&gt;50)$，$ASL\approx log_2(n+1)-1$</p><h1 id="5-B树及其基本操作、B-树的基本概念"><a href="#5-B树及其基本操作、B-树的基本概念" class="headerlink" title="5 B树及其基本操作、B+树的基本概念"></a>5 B树及其基本操作、B+树的基本概念</h1><p>一颗度m的B树称为m阶的B树，是一颗平衡（平衡因子为0）的查找树（排序树）</p><h2 id="5-1-B树"><a href="#5-1-B树" class="headerlink" title="5.1 B树"></a>5.1 B树</h2><p>（1）B树的定义</p><p>一棵m阶的B树，或者为空树，或为满足下列特性的m叉树：</p><ol><li>分枝的数量$\lceil m/2 \rceil&lt;=n&lt;=m$</li><li>关键码的数量$\lceil m/2 \rceil-1&lt;=n&lt;=m-1$</li></ol><p>（2）B树的查找</p><p>类似二叉排序树的查找，所不同的是B树每个节点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，按照对应的指针信息指向的子树中查找，当到达叶子节点时，则说明树中没有对应的关键码，查找失败</p><p>（3）B树的插入</p><ol><li>在B树中查找关键字$K$，若找到，表明关键字已存在，返回，否则$K$的查找操作失败于某个叶子结点，转2</li><li>将$K$插入到该叶子结点中，插入时，若：<ul><li>叶子节点的关键字数$&lt;m-1$:直接插入；</li><li>叶子节点的关键字数$=m-1$：将结点“分裂”</li></ul></li></ol><p>分裂的方法：</p><p>设待“分裂”结点包含信息为：<br>$(m,A_0,K_1,A_1,K_2,A_2,\dots,K_m,A_m)$，从其中间位置分为两个结点：</p><p>$$(\lceil m/2 \rceil -1,A_0,K_1,A_1,\dots,K_{\lceil m/2 \rceil-1},A_{\lceil m/2 \rceil-1})$$<br>$$(m-\lceil m/2 \rceil,A_{\lceil m/2 \rceil},K_{\lceil m/2 \rceil+1},A_{\lceil m/2 \rceil+1},\dots,K_{m},A_{m})$$</p><p>并将中间关键字$K_{\lceil m/2 \rceil}$插入到父节点中，以分裂后的两个结点作为其子结点</p><p><img src="https://note.youdao.com/yws/api/personal/file/E743781A41C048FBACF19AEA3B46CDE3?method=download&shareKey=fff65bef129a9f6c2e47f8fb66bd770a" alt></p><p>（4）B树的删除</p><p>在$B$树上删除一个关键字$K$，首先找到关键字所在的结点$N$，然后再$N$中进行关键字$K$的删除操作。</p><p>若$N$b不是叶子结点，设$K$是$N$的第$i$个关键字，将指针$A_{i-1}$所指子树中的最大关键字（或最小关键字）$K^{‘}$放在$(k)$的位置，然后删除$K^{‘}$，而$K^{‘}$一定在叶子结点上</p><p>从叶子结点中删除一个关键字的情况是：<br>（兄弟可借）</p><ol><li>若结点$N$中的关键字个数$&gt;\lceil m/2 \rceil-1$，在结点直接删除关键字K</li><li>若结点$N$中的关键字个数$=\lceil m/2 \rceil-1$，若结点$N$的左（右）兄弟结点中的关键字个数$&gt;\lceil m/2 \rceil-1$，则将节点$N$的左（或右）兄弟结点中的最大（或最小）关键字移到其父结点中，而父结点中大于（或小于）且紧靠上移关键字的关键字下移到结点$N$</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/2C8523525D4F45C494DF2BDD9E038DD6?method=download&shareKey=bb0f372b7208953b8ef2e463e228d3ac" alt></p><p>（兄弟不可借——合并结点）<br>3. 若结点$N$和其兄弟结点中的关键字$=\lceil m/2 \rceil-1$：删除结点$N$中的关键字，再将结点$N$中的关键字、指针域其兄弟结点以及分割二者的父结点的某个关键字$K_i$，合并为一个结点，若因此使父结点中的关键个数$&lt;=\lceil m/2 \rceil-1$，则以此类推<br>4. 若所删关键字为非终端结点中的$k_i$，则可以指针$A_i$所指子树中最小关键字$Y$替代$K_i$，然后再相应的结点中删去$Y$</p><p><img src="https://note.youdao.com/yws/api/personal/file/97818282DD604A05B09196BEAD6539F0?method=download&shareKey=c6f362679dd80a67908a2d6ca93ef7a4" alt></p><h2 id="5-2-B-树"><a href="#5-2-B-树" class="headerlink" title="5.2 $B+$树"></a>5.2 $B+$树</h2><p>$B+$树是文件系统所需要的一种$B$树的变形树，一棵$m$阶的$B+,B$树主要差异在于：</p><ol><li>有$n$棵子树的结点中含有$n$个关键码；</li><li>所有叶子结点中包含了全部关键码的信息，以及指向含有这些关键码记录的指针，且叶子结点本身依赖关键码的大小自小而大的顺序链接</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/1814D7A4B1B64A8F8C2DE97653835F25?method=download&shareKey=5296f5cd12ff30a14d50fb00a0eaa204" alt></p><h1 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6 哈希表"></a>6 哈希表</h1><h2 id="6-1-常用的哈希函数"><a href="#6-1-常用的哈希函数" class="headerlink" title="6.1 常用的哈希函数"></a>6.1 常用的哈希函数</h2><p>哈希函数“好坏”的主要评价因素有：散列函数的构造简单；能“均匀”地将散列表中的关键字映射到地址空间（发生冲突的可能性最少）</p><p>（1）直接定址法</p><p>$$H(key)=key, \ H(key)=a*key+b$$</p><p>此方法仅适用于：地址集合的大小等于关键字集合的大小</p><p>（2）数字分析法<br>假设关键字集合的每个关键字都是由$s$位数字组成$(k_1,k_2,\dots,k_n)$，分析关键字集中的全体，并从中提取分布均匀的若干位或他们的组合作为地址</p><p>（3）平方取中法</p><p>若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以扩大差别</p><p>（4）折叠法</p><p>若关键字的位数特别多，则可将其分割成几部分，然后取他们的叠加和为散列地址</p><ol><li>位移法：将各部分的最后一位对齐相加</li><li>间界叠加法：从一端向另一端沿各个部分分界来回折叠后，最后一位对齐相加</li></ol><p>适用于关键字的数字位数特别多</p><p>（5）除留余数法（重点）</p><p>$$H(key)=key\  MOD\  p\ (p&lt;=m)$$</p><p>选取适合的$p$很重要，一般选取质数</p><p>（6）随机数法</p><p>$$H(key)= Random(key)$$</p><h2 id="6-2-处理冲突的方法"><a href="#6-2-处理冲突的方法" class="headerlink" title="6.2 处理冲突的方法"></a>6.2 处理冲突的方法</h2><p>（1）开放定址法</p><p>一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p><ol><li>线性探测法</li></ol><p>$$H_i = (Hash(key)+d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p><p>这种方法的特点是：发生冲突，顺序表看表中下一单元，直接找出一个空单元或查遍全表。因此，可能出现很多元素在相邻的散列地址上“堆积”起来，大大降低了查找效率。为此，可采用二次探测法改善</p><ol start="2"><li>二次探测法</li></ol><p>$$H_i = (Hash(key)\pm d_i)\ mod\ m\ (1&lt;=i&lt;m)$$</p><p>其中：$Hash(key)$为散列函数，$m$为散列表长度，$m$要求是某个$4k+3$的质数，$d_i$为增量序列$1^2,-1^2,2^2,-2^2,\dots,q^2,-q^2,\ q&lt;=m/2$</p><ol start="3"><li>拉链法</li></ol><p>将所有散列表地址为$i$的元素构成一个同义词链的单链表，并将单链表的头指针存在散列表的第$i$个单元中</p><ol start="4"><li>建立公共溢出区</li></ol><p>建立一个溢出表保存与基本表中记录冲突的所有记录</p><h2 id="6-3-散列表的查找"><a href="#6-3-散列表的查找" class="headerlink" title="6.3 散列表的查找"></a>6.3 散列表的查找</h2><p>查找过程与造表一致，假设采用开放定址处理冲突，则查找过程：</p><ol><li>对给定值$K$，计算散列地址$i=H(K)$</li><li>若$r[i]=NULL$，则查找不成功</li><li>若$r[i].key=k$，则查找成功</li><li>否则求下一地址$H_i$，直至$r[H_i]=NULL$（查找不成功），或$r[H_i].key=k$（查找成功）</li></ol><p>哈希表的填满因子<br>$$\alpha=\frac{表中填入的记录数}{哈希表长度}$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-查找的基本概念&quot;&gt;&lt;a href=&quot;#1-查找的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1 查找的基本概念&quot;&gt;&lt;/a&gt;1 查找的基本概念&lt;/h1&gt;&lt;p&gt;查找有两种基本形态：静态查找和动态查找&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态查找：在查找时只对数据元素进行查询或检索，查找表称为静态查找表&lt;/li&gt;
&lt;li&gt;动态查找：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据存储结构的不同，查找方法分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较，找到要查找的记录&lt;/li&gt;
&lt;li&gt;散列表的查找：根据给定的K值直接访问查找表，从而找到要查找的记录&lt;/li&gt;
&lt;li&gt;索引查找表的查找：首先根据索引确定待查找记录所在的块，然后再从块中找到要查找的记录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liangggggg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（五）：传输层</title>
    <link href="https://liangggggg.github.io/2020/08/16/network5/"/>
    <id>https://liangggggg.github.io/2020/08/16/network5/</id>
    <published>2020-08-16T01:47:42.000Z</published>
    <updated>2020-08-30T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-传输层提供的服务"><a href="#1-传输层提供的服务" class="headerlink" title="1 传输层提供的服务"></a>1 传输层提供的服务</h1><h2 id="1-1-传输层的功能"><a href="#1-1-传输层的功能" class="headerlink" title="1.1 传输层的功能"></a>1.1 传输层的功能</h2><ul><li>传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务</li><li>传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网在技术、设计上的差异和服务质量的不足，想高层提供一个标准的完善的通信服务</li><li>从通信和信息处理的角度看，应用层是面向信息处理的，而传输层是为应用层提供通信服务的</li><li>对收到的报文进行差错校验</li><li>面向连接的TCP和无连接的UDP</li></ul><a id="more"></a><h2 id="1-2-传输层寻址与端口"><a href="#1-2-传输层寻址与端口" class="headerlink" title="1.2 传输层寻址与端口"></a>1.2 传输层寻址与端口</h2><p>TCP/IP传输层端口</p><ul><li>用16位端口</li><li>只具有本地含义</li><li>不同计算机的相同端口号没有联系</li></ul><p>两个计算机中的进程要相互通信，不仅要知道对方的IP地址，还要知道对方的端口号</p><p>两大类端口</p><p>（1）服务器</p><ul><li>熟知端口，一般0-1023</li><li>登记端口号，一般为1024-49151</li></ul><p>（2）客户端</p><ul><li>短暂端口号，留给客户进程使用，一般为49152-65535</li><li>端口为动态的</li></ul><h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2 UDP协议"></a>2 UDP协议</h1><p>（1）UPD无连接的</p><p>（2）使用尽最大努力交付，不保证可靠交付</p><p>（3）UPD是面向报文的</p><p>（4）UPD没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低</p><p>（5）UPD支持一对一、一对多、多对一和多对多的交互通信</p><p>（6）UPD的首部开销小，只有8个字节，比TCP的20字节小</p><h2 id="2-1-UDP首部格式"><a href="#2-1-UDP首部格式" class="headerlink" title="2.1 UDP首部格式"></a>2.1 UDP首部格式</h2><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8字节，由四个字段组成，每个字段长度都是两个字节</p><p>（1）源端口</p><p>（2）目的端口</p><p>（3）长度UPD用户数据报的长度</p><p>（4）检验和检测UDP用户数据报在传输中是否有错</p><p>UDP校验是伪首部和尾部一起校验</p><h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3 TCP协议"></a>3 TCP协议</h1><h2 id="3-1-TCP段"><a href="#3-1-TCP段" class="headerlink" title="3.1 TCP段"></a>3.1 TCP段</h2><ul><li>面向连接</li><li>只能有两个端点，只能是点对点</li><li>可靠交付</li><li>提供全双工</li><li>面向字节流</li><li>TCP连接是一条虚连接</li><li>根据对方给出的窗口值和当前网络拥塞程度来决定一个报文段应包含多少个字节</li><li>TCP可把太长的数据块划分短一些再传送</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/3CCDFBC7B5024E868952FBEC3B448C20?method=download&shareKey=4bfc577c3122e1322f3393d6719657e4" alt></p><h2 id="3-2-TCP的连接管理"><a href="#3-2-TCP的连接管理" class="headerlink" title="3.2 TCP的连接管理"></a>3.2 TCP的连接管理</h2><ul><li>TCP把连接作为最基本的抽象</li><li>每一条TCP连接有两个端点</li><li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口，TCP连接的端点叫做套接字或插口</li><li>端口号拼接到IP地址即构成了套接字</li><li>传输连接有三个阶段，即：建立连接，数据传送和连接释放</li><li>建立连接过程要解决一下三个问题<ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够传输实体资源</li></ul></li></ul><p>（1）建立连接（三次握手）</p><p>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段，称为三报文握手，主要是为了防止已失效的连接请求报文突然又传送到了，因而产生错误</p><p><img src="https://note.youdao.com/yws/api/personal/file/5CEAF751EA4C4C7C9704310F6F7FCBA0?method=download&shareKey=ad2bd6d9c823843d2879523899a3111a" alt></p><p>一开始TCP服务器创建传输控制块，准备接受客户进程的连接请求，然后服务器进程处理LISTEN收听状态，等待客户的连接请求，如有即作出响应</p><ol><li><p>TCP客户也创建传输控制模块，在打算建立TCP连接时，向服务端发出连接请求报文，TCP客户端进程进入SYN-SENT同步已发送状态</p></li><li><p>服务端到请求报文后，如同意建立连接，则发送确认，进入同步收到状态</p></li><li><p>TCP客户进程收到服务端的确认后，再给服务端给出确认，这时TCP连接已经建立，客户端进入已建立连接状态</p></li></ol><p>当服务端收到客户端的确认后，也进入已建立连接状态</p><p>（2）连接释放（四次握手）</p><p><img src="https://note.youdao.com/yws/api/personal/file/1F81C26CCC94472593D302BE252F06E1?method=download&shareKey=90481f9f275da417bc784de3e700f2b1" alt></p><ol><li>客户端先想服务端发出连接释放报文，并停止再发送数据，主动关闭TCP连接，等待服务端的确认</li><li>服务端收到连接释放报文后即发出确认，这时TCP连接处于半关闭状态，即服务端到客户端连接并未关闭</li><li>客户端收到服务端的确认后，等待服务端发送的连接释放报文，若服务端也没有要发送的数据，则发出连接释放报文，等待客户端的确认</li><li>客户端收到服务端的连接释放报文后，对此发出确认，经过时间等待计时器设置的时间后，进入关闭状态</li></ol><h2 id="3-3-TCP可靠传输"><a href="#3-3-TCP可靠传输" class="headerlink" title="3.3 TCP可靠传输"></a>3.3 TCP可靠传输</h2><ul><li>TCP连接的每一端都必须设有两个窗口，一个发送窗口和一个接受窗口</li><li>TCP的可靠传输机制用字节的序号进行控制，所有的确认都是基于序号而不是基于报文段</li><li>TCP两端的四个窗口处于动态变化之中</li><li>TCP连接的往返时间RTT也不是固定不变的，需要使用特点的算法估算较为合理的重传时间</li></ul><p>（1）TCP的滑动窗口</p><p>发送窗口的范围与接收方给发送方设置的“窗口”值有关，也与发送方已发送但未被确认的TCP报文段的数量有关，每当接收方正确收到一个TCP报文段并交给上层，便发回相应的确认报文，发送方收到相应的确认，便将对应已发并确认的发送缓冲释放，发送窗口同时向前滑动</p><h2 id="3-4-TCP流量控制与拥塞控制"><a href="#3-4-TCP流量控制与拥塞控制" class="headerlink" title="3.4 TCP流量控制与拥塞控制"></a>3.4 TCP流量控制与拥塞控制</h2><p>（1）流量控制</p><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受</p><p>（2）拥塞控制</p><p>TCP基于窗口进行拥塞控制，属于闭环控制方法</p><p>TCP发送方维持一个拥塞窗口CWND</p><ul><li>大小取决于网络的拥塞程度，并且动态地在变化</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量</li><li>发送窗口大小不仅取决于接收方公告的接受窗口，还取决于网络的拥塞情况，所以真正的发送窗口值为：</li></ul><p>真正的发送窗口值=MIN（公告接受窗口值，拥塞窗口值）</p><p>只要网络没有出现拥塞，拥塞窗口可以大一些，只要出现拥塞，就必须把拥塞窗口减小一点</p><p>拥塞的判断</p><ul><li>重传定时器超时</li><li>收到三个相同重复的ACK，预示可能会出现拥塞</li></ul><p>TCP拥塞控制算法</p><p>（1）慢开始</p><p>由小到大逐渐增大拥塞窗口数值</p><p>初始拥塞窗口cwnd设置：</p><ul><li>旧的规定：设置为1-2个发送方的最大报文段SMSS的数值</li><li>新的固定：设置2-4个SMSS</li></ul><p>没有特殊说明就是1个SMSS</p><p>慢开始门限：防止拥塞窗口增长过大</p><p>每收到一个新的报文段确认，可以把拥塞窗口增加多一个</p><p>每经过一个传输轮次，拥塞窗口加倍。窗口按指数增加</p><p><img src="http://note.youdao.com/noteshare?id=82b0ebf222a392a52865e1c74a15e32f&sub=9845A0F352624ADC8CBD58346DC17652" alt></p><p>（2）拥塞避免算法</p><p>没经过一个往返时间RTT就把拥塞窗口加1，使拥塞窗口按线性规律缓慢增大</p><p>当网络出现拥塞时</p><p>门限阈值设为窗口/2</p><p>窗口设置为1</p><p>执行慢开始算法</p><p><img src="https://note.youdao.com/yws/api/personal/file/E4D159D17BC24A0BBAC287D02DFFE98B?method=download&shareKey=a7eaab7740e883c4240ec1404c584dd8" alt></p><p>（3）快重传算法</p><p>只要收到三个重复确认，立即进行重传</p><p>（4）快恢复</p><p>当连续收到三个重复确认</p><ol><li>慢开始门限=当前拥塞窗口/2</li><li>新拥塞窗口=慢开始门限</li><li>执行拥塞避免算法</li></ol><hr><h1 id="4-面试常见问题总结"><a href="#4-面试常见问题总结" class="headerlink" title="4 面试常见问题总结"></a>4 面试常见问题总结</h1><h2 id="4-1-三次握手和四次握手"><a href="#4-1-三次握手和四次握手" class="headerlink" title="4.1 三次握手和四次握手"></a>4.1 三次握手和四次握手</h2><p>（1）三次握手</p><ul><li>客户端发送带有SYN标志的数据报给服务端</li><li>服务端发送带有SYN/ACK标志的数据报给客户端</li><li>客户端发送带有ACK标志的数据报给服务端</li></ul><blockquote><p>SYN同步序列编号，是TCP/IP建立连接时使用的握手信号，在客户机和服务器之间建立正常的TCP网络连接时，客户端首先发出一个SYN消息，服务器使用SYN-ACK应答表示接受到了这个消息，最后客户端再以ACK消息响应，这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户端和服务器之间传递</p></blockquote><p>三次握手的目的是建立可靠通信，能够使双方确认自己与对方的发送与接收都是正常的</p><p>（2）四次握手</p><ul><li>客户端发送一个FIN用来关闭客户端到服务器的数据发送</li><li>服务器收到FIN，发回一个ACK，确认序号为收到的序号加1</li><li>服务器关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态，当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接</p><h2 id="4-2-TCP和UDP协议的区别"><a href="#4-2-TCP和UDP协议的区别" class="headerlink" title="4.2 TCP和UDP协议的区别"></a>4.2 TCP和UDP协议的区别</h2><ul><li>UPD在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给任何确认，虽然UDP不提供可靠交付，但在某些情况下UDP却是一种罪有效的工作方式（一般永固即时通信），比如语音、视频、直播等</li><li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束要释放连接，TCP不提供广播或多播服务，由于TCP要提供可靠的，面向连接的传输服务，会增加许多开销，一般用于文件传送，接受邮件、远程登录等</li></ul><h2 id="4-3-TCP协议如何保证可靠传输"><a href="#4-3-TCP协议如何保证可靠传输" class="headerlink" title="4.3 TCP协议如何保证可靠传输"></a>4.3 TCP协议如何保证可靠传输</h2><ol><li>应用数据被分割成TCP认为最适合发送的数据块</li><li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层</li><li>校验和：TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测书剑在传送过程中的任何变化，如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li><li>TCP的接受端会丢弃重复的数据</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只会允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送速率，防止包丢失，TCP使用的流量控制协议是可变大小的滑动窗口协议</li><li>拥塞控制：当网络拥塞时，减少数据的发送</li><li>ARQ协议：每发完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li><li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段</li></ol><p>（1）ARQ协议</p><p>自动重传请求是OSI模型中数据链路层和传输层错误纠正协议之一，通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输，如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送，ARQ包括停止等待协议ARQ和连续ARQ</p><p><strong>停止等待ARQ协议</strong></p><ul><li>停止等待协议是为了实现可靠传输的，基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK），如果过了一段时间后，还没有收到ACK确认，就说明没有发送成功，需要重新发送，知道收到确认后再发送下一个分组</li><li>若收到重复分组，就丢弃该分组，但同时还要发送确认</li></ul><p>简单，但是信道利用率低</p><p><strong>无差错情况</strong></p><p>在规定时间能收到，并回复确认，发送方再次传送下一个数据</p><p><strong>出现差错情况（超时重传）</strong></p><p>每发送完一个分组需要设置一个超时计时器，重传时间比数据在分组传输的平均往返时间更长一些，称为自动重传请求ARQ。</p><p>而连续ARQ可提高信道利用率，发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p><p><strong>确认丢失和确认迟到</strong></p><ul><li>确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失，而A不知道，在超时计时后，A重传M1下次，B再次收到该消息后采取以下两点措施：1.丢弃这个重复的M1消息，不向上层交付。2.向A发送确认消息</li><li>确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认，在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息，此时A收到了B第二次发送的确认消息，接着发送其他数据，过了一会儿，A又收到了B第一次发送的迟到确认消息，处理如下：1.A收到重复的确认后，直接丢弃2.B收到重复的M1也直接丢弃重复的M1</li></ul><p><strong>连续ARQ协议</strong></p><p>连续ARQ协议可提高信道利用率，发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了</p><p>优点是信道利用率高，容易实现，即使确认丢失，也不必重传</p><p>缺点是不能像发送方反映出接受方已经正确收到的所有分组信息。当出现丢失时，需要退回重传已经发送过的N个消息</p><p>（2）滑动窗口和流量控制</p><p>TCP利用滑动窗口实现流量控制，为了控制发送方发送的速率，保证接收方来得及接收</p><p>（3）拥塞控制</p><p>拥塞控制是一个全局性的过程，设计到所有的主机，所有的路由器，以及降低网络传输性能有关的所有因素</p><p>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</p><p>TCP的拥塞控制采用了四种算法：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使用路由器采用适当的分组丢弃策略（主动队列管理AQM），以减少网络拥塞的发生</p><ul><li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入网络，那么可能会引起网络阻塞，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，cwnd初始值为1，每经过一个传播轮次，cwnd加倍</li><li>拥塞避免：拥塞避免算法的思路是rag拥塞窗口cwnd缓慢增大，没经过一个往返时间RTT就把发送的cwnd加1</li><li>快重传和快恢复：在TCP/IP中，快重传和恢复是一种拥塞控制算法，它能快速恢复丢失的数据报。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。有了FRR，如果接收机收到了一个不按顺序的数据段，它会立即给发送机发送一个重复确认，如果接受到三个重复确认，它会假定确认件直除的数据段丢失了，并立即重传这些丢失的数据段</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-传输层提供的服务&quot;&gt;&lt;a href=&quot;#1-传输层提供的服务&quot; class=&quot;headerlink&quot; title=&quot;1 传输层提供的服务&quot;&gt;&lt;/a&gt;1 传输层提供的服务&lt;/h1&gt;&lt;h2 id=&quot;1-1-传输层的功能&quot;&gt;&lt;a href=&quot;#1-1-传输层的功能&quot; class=&quot;headerlink&quot; title=&quot;1.1 传输层的功能&quot;&gt;&lt;/a&gt;1.1 传输层的功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务&lt;/li&gt;
&lt;li&gt;传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网在技术、设计上的差异和服务质量的不足，想高层提供一个标准的完善的通信服务&lt;/li&gt;
&lt;li&gt;从通信和信息处理的角度看，应用层是面向信息处理的，而传输层是为应用层提供通信服务的&lt;/li&gt;
&lt;li&gt;对收到的报文进行差错校验&lt;/li&gt;
&lt;li&gt;面向连接的TCP和无连接的UDP&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结（四）：网络层</title>
    <link href="https://liangggggg.github.io/2020/08/15/network4/"/>
    <id>https://liangggggg.github.io/2020/08/15/network4/</id>
    <published>2020-08-15T01:47:42.000Z</published>
    <updated>2020-08-27T12:24:53.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络层的功能"><a href="#1-网络层的功能" class="headerlink" title="1 网络层的功能"></a>1 网络层的功能</h1><h2 id="1-1-异构网络互联"><a href="#1-1-异构网络互联" class="headerlink" title="1.1 异构网络互联"></a>1.1 异构网络互联</h2><p>由于参加互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看作一个虚拟互联网络，所谓虚拟互联网络也就是逻辑互联网络，互联起来的各个捂脸网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。</p><a id="more"></a><h2 id="1-2-路由与转发"><a href="#1-2-路由与转发" class="headerlink" title="1.2 路由与转发"></a>1.2 路由与转发</h2><p>在路由表中，对每一条路由最主要的是以下两个信息：目的网络地址、下一跳地址</p><p>我们根据目的网络地址来确定下一跳路由器，这样可得出以下结果</p><p>（1）IP数据报最终一定可以找到目的主机所在目的网络上的路由器</p><p>（2）只有到达最后一个路由器时，才视图向目的主机进行直接交付</p><p>分组转发算法：</p><p>（1）从数据报的首部提取目的主机IP地址D，得出目的网络地址为N</p><p>（2）若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址D转换为具体的硬件地址）；否则就是间接交付，执行（3）</p><p>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</p><p>（4）路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器：否则，执行（5）</p><p>（5）若路由表中有一个默认路由，则把数据表传送给路由表中所指明的默认路由器；否则执行（6）</p><p>（6）报告转发分组出错</p><p>路由表想主要字段：目的网络、子网掩码、下一跳路由器、经由接口</p><p>默认路由：若匹配路由表中其它项都不匹配，则走默认路由指明的路由</p><p>若路由表项都不匹配且无默认路由，则向源主机发送错的ICMP包</p><p>主机路由：IP地址，255.255.255.255 下一跳 接口</p><h2 id="1-3-拥塞控制"><a href="#1-3-拥塞控制" class="headerlink" title="1.3 拥塞控制"></a>1.3 拥塞控制</h2><p>1、拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该网络来不及处理以致引起这部分乃至整个网络性能下降的现象，严重时会出现死锁。拥塞现象产生的原因主要有三个方面：路由器缓冲区不够；通信线路的带宽不够；处理器速度慢</p><p>2、拥塞控制：目的是确保子网能够承载所有到达流量，是全局问题，涉及节点包括：主机、路由器</p><p>3、流量控制：目的是确保发送端的发送速度小于接受端的接收速度，使接收端来得及正确接收。流量控制只与发送和接收端有关系，是局部问题</p><h1 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2 路由算法"></a>2 路由算法</h1><h2 id="2-1-静态路由与动态路由"><a href="#2-1-静态路由与动态路由" class="headerlink" title="2.1 静态路由与动态路由"></a>2.1 静态路由与动态路由</h2><p>静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由</p><p>动态路由选择也叫自适应路由选择，其特点是能较好地自适应网络状态的变化，但实现起来较为复杂，开销也较大，因此，适用于较复杂的大网络。</p><h2 id="2-2-距离-向量路由算法"><a href="#2-2-距离-向量路由算法" class="headerlink" title="2.2 距离-向量路由算法"></a>2.2 距离-向量路由算法</h2><h2 id="2-3-链路状态路由算法"><a href="#2-3-链路状态路由算法" class="headerlink" title="2.3 链路状态路由算法"></a>2.3 链路状态路由算法</h2><h2 id="2-4-层次路由"><a href="#2-4-层次路由" class="headerlink" title="2.4 层次路由"></a>2.4 层次路由</h2><p>（1）互联网的规模非常大，如果让所有路由器知道所有网络应该怎样到达，则这种路由表将非常大</p><p>（2）许多单位不愿意外界了解自己单位网络的布局细节和本部分所采用的路由选择协议</p><p>为此，将整个互联网划分成许多较小的自治系统</p><h1 id="3-IPv4"><a href="#3-IPv4" class="headerlink" title="3 IPv4"></a>3 IPv4</h1><h2 id="3-1-IPv4分组"><a href="#3-1-IPv4分组" class="headerlink" title="3.1 IPv4分组"></a>3.1 IPv4分组</h2><p>IP数据报的格式能够说明IP协议都具有什么功能，在TCP/IP的标准中，各种数据格式常常以32位（4字节）为单位来表述</p><p><img src="https://note.youdao.com/yws/api/personal/file/587F26252FD94B0A8E49E55E40988A0F?method=download&shareKey=d8379ce9bacd34421d0217526f1108b3" alt></p><p>（1）IP数据报首部的固定部分中的各字段</p><ol><li>版本占4位，指IP协议的版本，通信双方使用的IP协议版本必须一致，目前广泛使用的为4（即IPv4）</li><li>首部长度占4位</li><li>区分服务占8位，用来获得更好的服务</li><li>总长度指首部和数据之和的长度</li><li>标识占16位</li><li>标志占3位</li><li>片偏移占13位。较长的分组在分片后，某片在原分组中的相对位置</li><li>生存时间占8位</li><li>协议占8位，指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理</li><li>首部检验和占16位</li></ol><h2 id="3-2-IPv4地址与NAT"><a href="#3-2-IPv4地址与NAT" class="headerlink" title="3.2 IPv4地址与NAT"></a>3.2 IPv4地址与NAT</h2><p>（1）IP地址及其表示方法</p><p>IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配以个在全世界范围内是唯一的32位标识符，具有以下重要特点</p><ol><li>每一个IP地址都由网络号和主机号两部分组成</li><li>实际上IP地址标志一台主机（或路由器）和一条链路的接口。路由器至少应当有两个不同的IP地址</li><li>一个网络是指具有相同网络号net-id的主机的集合，因此用转发器或网桥连接起来的若干个局域网仍为一个网络</li><li>在IP地址中，所有分配到网络号的网络都是平等的</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/27C68544341842C9A1439F6AF31EC516?method=download&shareKey=dff0f29f2e04b88dca9d17e7bf85a20c" alt></p><p>主机号全0，或全1不使用</p><p>A类地址：网络号：0-127，主机地址24位：$2^24-2$个</p><p>B类地址：网络号：128.0-191.255,主机地址16位：$2^16-2$个</p><p>C类地址：网络号：192.0.0-223.255.255，主机地址8位：$2^8-2$</p><p>D类地址：网络号：224~239之间，一般用于多路广播用户</p><p>E类地址：网络号：240~250之间，保留地址</p><p>（2）NAT技术</p><p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件，装有NAT软件的路由器叫作NAT路由器，至少有一个有效的外部全球IP地址，这样，所有使用本地地址的主机和外界通信时，都要在NAT路由器上讲本地地址转换成全球IP地址，才能和互联网连接。</p><h2 id="3-3-子网划分、路由聚集、子网掩码、CIDR"><a href="#3-3-子网划分、路由聚集、子网掩码、CIDR" class="headerlink" title="3.3 子网划分、路由聚集、子网掩码、CIDR"></a>3.3 子网划分、路由聚集、子网掩码、CIDR</h2><p>（1）从两级IP地址到三级IP地址</p><p>划分子网的基本思路如下：</p><ol><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号，当然主机号也就相应减少了同样的位数，IP地址在单位内部变为三级IP地址：网络号、子网号、主机号</li><li>范式从其他网络发送给本单位某台主机的IP数据报，仍是根据IP数据报的目的网络号找到链接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，吧IP数据报交付目的主机</li></ol><p>（2）子网掩码</p><p>使用子网掩码的好处就是，不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的与运算，就立即得出网络地址来。</p><p><img src="https://note.youdao.com/yws/api/personal/file/15B0A407CC8747CAAB1084D4E6EA4484?method=download&shareKey=c11b3faa3b315d7e7c0b52a797c0fdb9" alt></p><p>（3）使用子网分组的转发</p><p>在划分子网的情况下，分组转发的算法必须做相应的改动，使用子网划分后，路由表必须包括以下三项内容：目的网络地址、子网掩码和下一跳地址，下划分子网情况下，路由转发分组的算法如下：</p><ol><li>从收到的数据报的首部提取目的IP地址D</li><li>先判断是否为直接交付，用各网络的子网掩码和D逐位相与，看结果是否和相应的网络地址匹配，若匹配进行直接交付，否则间接交付，执行（3）</li><li>若路由表中有目的地址为D的特点主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行（4）</li><li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相与，其结果为N，若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器，否则执行5</li><li>路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由器，否则执行6</li><li>报告转发分组出错</li></ol><h2 id="3-4-无分类编址CIDR（构造超网）"><a href="#3-4-无分类编址CIDR（构造超网）" class="headerlink" title="3.4 无分类编址CIDR（构造超网）"></a>3.4 无分类编址CIDR（构造超网）</h2><p>CIDR最主要的特点有两个：</p><p>（1）CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，把32位的IP地址划分为前后两个部分，前面部分是“网络前缀”，用来指明网络，后面部分则用来指明主机。因此CIDR使IP地址从三级编址回到了两级编址：IP地址=网络前缀、主机号，在IP地址后面加上斜线，然后写上网络前缀所占的位数</p><p>（2）CIDR把网络前缀都相同的连续的IP地址组成一个CIDR地址块。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数</p><p>路由聚合</p><p>这个ISP共拥有64个C类网络，如果不采用CIDR技术，则与该ISP的路由器交换路由信息的每一个路由器的路由表中，就需要有64个项目，但采用地址聚合后，就只需用路由聚合后的一个项目206.0.64.0/18就能找到该ISP</p><p><img src="https://note.youdao.com/yws/api/personal/file/C6F0B28F52FA4CBB8912A657C5DA19A7?method=download&shareKey=e71d81b3e28fa6b144aaac0811d2ff5a" alt></p><p>最长前缀匹配</p><p>每个项目由网络前缀和下一跳地址组成，但是在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由</p><h2 id="3-5-ARP协议、DHCP协议与ICMP协议"><a href="#3-5-ARP协议、DHCP协议与ICMP协议" class="headerlink" title="3.5 ARP协议、DHCP协议与ICMP协议"></a>3.5 ARP协议、DHCP协议与ICMP协议</h2><h3 id="3-5-1-地址解析协议ARP"><a href="#3-5-1-地址解析协议ARP" class="headerlink" title="3.5.1 地址解析协议ARP"></a>3.5.1 地址解析协议ARP</h3><p>从网络层使用的IP地址，解析出在数据链路层使用的硬件地址</p><ul><li>ARP请求分组：包含发送方硬件地址和IP地址，目标方硬件地址（未知填0），目标方IP地址</li><li>本地广播ARP请求（路由器不转发ARP请求）</li><li>ARP相应分组：发送方硬件地址、发送方IP地址、目标方硬件地址、目标方IP地址</li><li>ARP分组封装在物理网络的帧中传输</li></ul><h3 id="3-5-2-网络控制报文协议ICMP"><a href="#3-5-2-网络控制报文协议ICMP" class="headerlink" title="3.5.2 网络控制报文协议ICMP"></a>3.5.2 网络控制报文协议ICMP</h3><ul><li>为了提高IP数据交付成功的机会</li><li>允许主机或路由器报告差错情况和提供有关异常情况的报告</li><li>不是高层协议而是IP层的协议</li><li>作为IP层数据报的数据</li><li>有差错报告和询问报文</li><li>前4个字节是统一的格式，共有三个字段：即类型、代码和校验和，接着的4个字节的内容与ICMP的类型有关</li></ul><h3 id="3-5-3-动态主机设置协议DHCP"><a href="#3-5-3-动态主机设置协议DHCP" class="headerlink" title="3.5.3 动态主机设置协议DHCP"></a>3.5.3 动态主机设置协议DHCP</h3><ul><li>动态主机配置协议DHCP提供了即插即用连网的机制</li><li>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参加</li><li>需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就称为DHCP客户</li><li>本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文</li><li>DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文</li></ul><h1 id="4-IPv6"><a href="#4-IPv6" class="headerlink" title="4 IPv6"></a>4 IPv6</h1><h2 id="4-1-IPv6的主要特点"><a href="#4-1-IPv6的主要特点" class="headerlink" title="4.1 IPv6的主要特点"></a>4.1 IPv6的主要特点</h2><p>（1）地址从IPv4的32位增加到128位</p><p>（2）扩展地址层次结构</p><p>（3）灵活的首部格式</p><p>（4）改进的选项</p><p>（5）允许协议继续扩充</p><p>（6）支持资源的预分配</p><p>（7）支持即插即用</p><p>（8）首部8字节对齐</p><h2 id="4-2-IPv6的地址"><a href="#4-2-IPv6的地址" class="headerlink" title="4.2 IPv6的地址"></a>4.2 IPv6的地址</h2><p>（1）单播：传统的点到点通信</p><p>（2）组播：一点对多点通信</p><p>（3）任播：终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个</p><p>为了使地址再稍简洁，使用冒号十六进制法</p><h1 id="5-路由协议"><a href="#5-路由协议" class="headerlink" title="5 路由协议"></a>5 路由协议</h1><h2 id="5-1-自治系统"><a href="#5-1-自治系统" class="headerlink" title="5.1 自治系统"></a>5.1 自治系统</h2><ul><li>核心是路由寻址的“自治”</li><li>自治系统内部的路由器了解内部全部网路的路由信息</li><li>自治系统内部的路由器要向主干路由器报告内部路由信息</li></ul><h2 id="5-2-域内路由与域间路由"><a href="#5-2-域内路由与域间路由" class="headerlink" title="5.2 域内路由与域间路由"></a>5.2 域内路由与域间路由</h2><ul><li>内部网关协议IGP，如RIP,OSPF协议</li><li>外部网关协议EGP，如BGP-4</li></ul><h2 id="5-3-RIP路由协议"><a href="#5-3-RIP路由协议" class="headerlink" title="5.3 RIP路由协议"></a>5.3 RIP路由协议</h2><p>1、工作原理</p><ul><li>内部网关协议</li><li>分布式的基于距离向量</li><li>要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</li></ul><p>距离的定义：</p><ol><li>路由器到直接连接的网络距离定义为1</li><li>路由器到非直连的网络的距离为所经过的路由器加1</li><li>RIP协议的距离也称为跳数</li><li>距离指的是最短距离</li><li>允许一条路径最多只包含15个路由器</li><li>16个路由器则不可达，可见RIP适用于小型网络</li><li>不能再两个网络之间同时使用多条路由</li></ol><p>RIP三个要点：</p><ul><li>仅和相邻路由交换信息</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表</li><li>按固定的时间间隔交换路由信息</li></ul><p>2、距离向量算法</p><p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p><ol><li><p>对地址为X相邻路由器发来的RIP报文，先修改此报文中的所有项目：把下一跳字段中的地址都改为X，并把所有距离字段的值都加1，每一项目都有三个关键数据，即：目的网络N，距离d,下一跳路由X</p></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤:若原来的路由表中没有目的网络N，则把该项目添加到路由表中，否则（即在路由表中有目的网络N，这时就再查看下一跳路由地址）</p><ul><li>若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目，否则</li><li>若收到项目中的距离小于路由表中的距离，则进行更新，否则什么都不做</li></ul></li><li><p>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器</p></li></ol><h2 id="5-4-OSPF路由协议"><a href="#5-4-OSPF路由协议" class="headerlink" title="5.4 OSPF路由协议"></a>5.4 OSPF路由协议</h2><p>1、OSPF的三个要点</p><ul><li>向本自治系统中所有路由器发送信息</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</li><li>只有当链路状态发生变化时，路由器才想所有路由器用洪泛法发送此信息</li></ul><p>2、OSPF的五种分组类型</p><ul><li>问候分组</li><li>数据库描述</li><li>链路状态请求</li><li>链路状态更新</li><li>链路状态确认</li></ul><h2 id="5-5-BGP路由协议"><a href="#5-5-BGP路由协议" class="headerlink" title="5.5 BGP路由协议"></a>5.5 BGP路由协议</h2><ul><li>因特网的规模太大，寻找最佳路径不现实，只交换可达性的信息</li><li>自治系统之间的路由必须考虑有关策略</li><li>边界网关协议BGP只能是力求寻找一条能够到达目的地网络且比较好的路由</li></ul><h1 id="6-IP组播"><a href="#6-IP组播" class="headerlink" title="6 IP组播"></a>6 IP组播</h1><h2 id="6-1-组播的概念"><a href="#6-1-组播的概念" class="headerlink" title="6.1 组播的概念"></a>6.1 组播的概念</h2><p>在一对多的通信中，组播可大大节约网络资源，组播组的标识符就是IP地址的D类地址</p><h1 id="7-移动IP"><a href="#7-移动IP" class="headerlink" title="7 移动IP"></a>7 移动IP</h1><h2 id="7-1-移动IP的概念"><a href="#7-1-移动IP的概念" class="headerlink" title="7.1 移动IP的概念"></a>7.1 移动IP的概念</h2><p>这种技术允许计算机移动到外地时，仍然保留原来的IP地址，使用户的移动性对上层的网络应用是透明的</p><h1 id="8-网络层设备"><a href="#8-网络层设备" class="headerlink" title="8 网络层设备"></a>8 网络层设备</h1><ul><li>路由器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-网络层的功能&quot;&gt;&lt;a href=&quot;#1-网络层的功能&quot; class=&quot;headerlink&quot; title=&quot;1 网络层的功能&quot;&gt;&lt;/a&gt;1 网络层的功能&lt;/h1&gt;&lt;h2 id=&quot;1-1-异构网络互联&quot;&gt;&lt;a href=&quot;#1-1-异构网络互联&quot; class=&quot;headerlink&quot; title=&quot;1.1 异构网络互联&quot;&gt;&lt;/a&gt;1.1 异构网络互联&lt;/h2&gt;&lt;p&gt;由于参加互联的计算机网络都使用相同的网际协议IP，因此可以把互联以后的计算机网络看作一个虚拟互联网络，所谓虚拟互联网络也就是逻辑互联网络，互联起来的各个捂脸网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liangggggg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
